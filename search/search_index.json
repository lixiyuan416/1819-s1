{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CS1010 What's New Final Assessment: Comments and Answer Keys PE2 Answer Keys PE1 Comments and Answer Keys Updated for digits and square . Lecture 12 Slides | Screencast In this lecture, we will review what we have covered in CS1010 as well as to peak ahead to give you a teaser of CS2040C. There is no notes for this lecture. Lecture 11 Screencast (complete) In this lecture, we discussed a few C specific topics: struct , typedef , printf , and scanf . We covered Unit 28 and Unit 29 . Piazza Q&A Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010. Notes and Lectures Lecture 11 Screencast (complete) In this lecture, we discussed a few C specific topics: struct , typedef , printf , and scanf . We covered Unit 28 and Unit 29 . Lecture 10 Slides | Screencast In this lecture, we discussed three classic recursive algorithms: the Tower of Hanoi ( Unit 25 ), generating permutations ( Unit 26 ) and the n n -Queens Problem ( Unit 27 ). Lecture 9 Screencast In this lecture, we will discuss three classic algorithms: binary search (in Unit 23 ) bubble sort, and insertion sort (both in Unit 24: Sorting ). Note: There are no slides. Lecture 8 Slides | Screencast In this lecture, we introduced C pre-processing, the assert macros, and the notion of efficiency in algorithms. Units covered are Units 20 - 22: Unit 20: C Pre-processing , Unit 21: Assert , Unit 22: Efficiency . Lecture 7 Slides | Screencast In this lecture, we discussed how call-by-reference works in C, talked about memory allocation on the heap, and moved on the multi-dimensional arrays. Units covered are Units 17 - 19: Unit 17: Call by Reference , Unit 18: Heap , Unit 19: Multi-Dimensional Arrays . Lecture 6 Slides | Screencast In this lecture, we discussed how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns. We then discussed about pointers and arrays, ending with a brief introduction to strings as an array of char . Units covered are Units 13 - 16: Unit 13: Call Stack , Unit 14: Pointers , Unit 15: Arrays and Unit 16: Strings . Lecture 5 Slides | Screencast In this lecture, we talked about how to write loops, followed by using assertions to reason about the behavior and logic of our programs. Units covered are Units 10 Assertions , 11 Loops , and 12 Reasoning About Loops . Lecture 4 Slides | Screencast | Kahoot Quiz In this lecture, we learned how to write programs that involve branching execution paths, using if - else statements and logical expressions. Unit 8 If-Else , Unit 9 Logical Expression were covered. Lecture 3 Slides | Screencast We covered Unit 5: First C Program , Unit 6: CS1010 I/O Library and Unit 7: Arithmetic Operations . In this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result. Lecture 2 Slides | Screencast We covered Unit 3: functions and Unit 4: types . In this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum. We also learned about the concept of types. Lecture 1 Slides | Screencast (password posted on Piazza) After some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving. We covered Unit 1: What is a Program? and Unit 2: Computational Problems and Algorithms in the first lecture. Programming Exercises Exercises are ungraded programming questions for practicing on your own. Exercise 5: Square, Escape, MagicSquare Released 31 October 2018 Exercise 4: ID, Grade, Index, Max Released 20 September 2018 Exercise 3: Binary, Rectangle, Fibonacci, Prime Released 13 September 2018 Exercise 2: Leap, Suffix, Days Released 6 September 2018 Exercise 1: Freezer Released 3 September 2018 Programming Assignments Assignment 9: Digits Released 9 November 2018. Due 16 November 2018, 23:59pm Assignment 8: Maze, Fill Released 2 November 2018. Due 9 November 2018, 23:59pm Assignment 7: Peak, Scripts, Inversion Released 26 October 2018. Due 2 November 2018, 23:59pm. Assignment 6: Permutation 1 2 3 Released 19 October 2018. Due 26 October 2018, 23:59pm. Assignment 5: Social, Life Released 12 October 2018. Due 19 October 2018, 6pm. Assignment 4: SelectionSort, Add, Mastermind Released 5 October 2018. Due 12 October 2018, 6pm. Assignment 3: Kendall, Histogram, CountingSort Released 21 September 2018, Due 5 October 2018, 6pm. Assignment 2: Collatz, Weekday, Circle, Pattern Released 14 September 2018, Due 21 September 2018, 6pm. Assignment 1: Invest, Box, Digits, and Taxi Released 7 September 2018, Due 14 September 2018, 6pm.","title":"Home"},{"location":"index.html#cs1010","text":"","title":"CS1010"},{"location":"index.html#whats-new","text":"","title":"What's New"},{"location":"index.html#final-assessment-comments-and-answer-keys","text":"","title":"Final Assessment: Comments and Answer Keys"},{"location":"index.html#pe2-answer-keys","text":"","title":"PE2 Answer Keys"},{"location":"index.html#pe1-comments-and-answer-keys","text":"Updated for digits and square .","title":"PE1 Comments and Answer Keys"},{"location":"index.html#lecture-12","text":"Slides | Screencast In this lecture, we will review what we have covered in CS1010 as well as to peak ahead to give you a teaser of CS2040C. There is no notes for this lecture.","title":"Lecture 12"},{"location":"index.html#lecture-11","text":"Screencast (complete) In this lecture, we discussed a few C specific topics: struct , typedef , printf , and scanf . We covered Unit 28 and Unit 29 .","title":"Lecture 11"},{"location":"index.html#piazza-qa","text":"Piazza is the Q&A site for students and instructors to ask questions and discuss among each other on all matters related to CS1010.","title":"Piazza Q&amp;A"},{"location":"index.html#notes-and-lectures","text":"","title":"Notes and Lectures"},{"location":"index.html#lecture-11_1","text":"Screencast (complete) In this lecture, we discussed a few C specific topics: struct , typedef , printf , and scanf . We covered Unit 28 and Unit 29 .","title":"Lecture 11"},{"location":"index.html#lecture-10","text":"Slides | Screencast In this lecture, we discussed three classic recursive algorithms: the Tower of Hanoi ( Unit 25 ), generating permutations ( Unit 26 ) and the n n -Queens Problem ( Unit 27 ).","title":"Lecture 10"},{"location":"index.html#lecture-9","text":"Screencast In this lecture, we will discuss three classic algorithms: binary search (in Unit 23 ) bubble sort, and insertion sort (both in Unit 24: Sorting ). Note: There are no slides.","title":"Lecture 9"},{"location":"index.html#lecture-8","text":"Slides | Screencast In this lecture, we introduced C pre-processing, the assert macros, and the notion of efficiency in algorithms. Units covered are Units 20 - 22: Unit 20: C Pre-processing , Unit 21: Assert , Unit 22: Efficiency .","title":"Lecture 8"},{"location":"index.html#lecture-7","text":"Slides | Screencast In this lecture, we discussed how call-by-reference works in C, talked about memory allocation on the heap, and moved on the multi-dimensional arrays. Units covered are Units 17 - 19: Unit 17: Call by Reference , Unit 18: Heap , Unit 19: Multi-Dimensional Arrays .","title":"Lecture 7"},{"location":"index.html#lecture-6","text":"Slides | Screencast In this lecture, we discussed how call stack works, giving more insights about how a C program is executed, particularly when we call a function and when a function returns. We then discussed about pointers and arrays, ending with a brief introduction to strings as an array of char . Units covered are Units 13 - 16: Unit 13: Call Stack , Unit 14: Pointers , Unit 15: Arrays and Unit 16: Strings .","title":"Lecture 6"},{"location":"index.html#lecture-5","text":"Slides | Screencast In this lecture, we talked about how to write loops, followed by using assertions to reason about the behavior and logic of our programs. Units covered are Units 10 Assertions , 11 Loops , and 12 Reasoning About Loops .","title":"Lecture 5"},{"location":"index.html#lecture-4","text":"Slides | Screencast | Kahoot Quiz In this lecture, we learned how to write programs that involve branching execution paths, using if - else statements and logical expressions. Unit 8 If-Else , Unit 9 Logical Expression were covered.","title":"Lecture 4"},{"location":"index.html#lecture-3","text":"Slides | Screencast We covered Unit 5: First C Program , Unit 6: CS1010 I/O Library and Unit 7: Arithmetic Operations . In this lecture, we got started with writing simple C programs that read inputs, perform some calculations, and display the result.","title":"Lecture 3"},{"location":"index.html#lecture-2","text":"Slides | Screencast We covered Unit 3: functions and Unit 4: types . In this lecture, we learned the concepts of functions, with which we can build up a more complex algorithm from smaller building blocks, such as finding the maximum. We also learned about the concept of types.","title":"Lecture 2"},{"location":"index.html#lecture-1","text":"Slides | Screencast (password posted on Piazza) After some admin matters, we introduced what is a program, what is meant by programming, and what is computational problem solving. We covered Unit 1: What is a Program? and Unit 2: Computational Problems and Algorithms in the first lecture.","title":"Lecture 1"},{"location":"index.html#programming-exercises","text":"Exercises are ungraded programming questions for practicing on your own.","title":"Programming Exercises"},{"location":"index.html#exercise-5-square-escape-magicsquare","text":"Released 31 October 2018","title":"Exercise 5: Square, Escape, MagicSquare"},{"location":"index.html#exercise-4-id-grade-index-max","text":"Released 20 September 2018","title":"Exercise 4: ID, Grade, Index, Max"},{"location":"index.html#exercise-3-binary-rectangle-fibonacci-prime","text":"Released 13 September 2018","title":"Exercise 3: Binary, Rectangle, Fibonacci, Prime"},{"location":"index.html#exercise-2-leap-suffix-days","text":"Released 6 September 2018","title":"Exercise 2: Leap, Suffix, Days"},{"location":"index.html#exercise-1-freezer","text":"Released 3 September 2018","title":"Exercise 1: Freezer"},{"location":"index.html#programming-assignments","text":"","title":"Programming Assignments"},{"location":"index.html#assignment-9-digits","text":"Released 9 November 2018. Due 16 November 2018, 23:59pm","title":"Assignment 9: Digits"},{"location":"index.html#assignment-8-maze-fill","text":"Released 2 November 2018. Due 9 November 2018, 23:59pm","title":"Assignment 8: Maze, Fill"},{"location":"index.html#assignment-7-peak-scripts-inversion","text":"Released 26 October 2018. Due 2 November 2018, 23:59pm.","title":"Assignment 7: Peak, Scripts, Inversion"},{"location":"index.html#assignment-6-permutation-1-2-3","text":"Released 19 October 2018. Due 26 October 2018, 23:59pm.","title":"Assignment 6: Permutation 1 2 3"},{"location":"index.html#assignment-5-social-life","text":"Released 12 October 2018. Due 19 October 2018, 6pm.","title":"Assignment 5: Social, Life"},{"location":"index.html#assignment-4-selectionsort-add-mastermind","text":"Released 5 October 2018. Due 12 October 2018, 6pm.","title":"Assignment 4: SelectionSort, Add, Mastermind"},{"location":"index.html#assignment-3-kendall-histogram-countingsort","text":"Released 21 September 2018, Due 5 October 2018, 6pm.","title":"Assignment 3: Kendall, Histogram, CountingSort"},{"location":"index.html#assignment-2-collatz-weekday-circle-pattern","text":"Released 14 September 2018, Due 21 September 2018, 6pm.","title":"Assignment 2: Collatz, Weekday, Circle, Pattern"},{"location":"index.html#assignment-1-invest-box-digits-and-taxi","text":"Released 7 September 2018, Due 14 September 2018, 6pm.","title":"Assignment 1: Invest, Box, Digits, and Taxi"},{"location":"01-program.html","text":"Unit 1: What is a Program? Learning Outcomes After this unit, students should: have an idea of what is a program and how a program is executed by a computer understand the basic terminologies: machine code, assembly language, and higher-level programming languages What is a (computer) program? Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task. Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010. How computer executes a program In order to learn how to write a program, it is important to have an overview of how a computer executes a program. You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process. The two important components of a computer we will discuss for CS1010 is the CPU, or central processing unit and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so. A memory location is addressable using a memory address . The instructions to the CPU comes in the form of machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things. These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location. The data stored in the memory is also stored as a sequence of 1s and 0s. From Machine Code to High-level Programming Language While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system). The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human. Simple operations such as comparing which number is bigger might require several instructions to perform. To get around the readability problem, programmers can code in assembly language -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as decr , incr , store , add , etc.) Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming. Early programmers (in the fifties) understood this and designed high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent. A program written in one of these programming languages is then compiled into machine code for a specific CPU for execution using a compiler. The first commercially available language is FORTRAN from IBM in the 1950s. Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today, For many reasons , C is the language of choice for CS1010. The Goals of CS1010 This brings us to the goals of CS1010. First, you will learn the most important syntax element of the C programming language. Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory. Third, you will learn the various tools and techniques that will help you produce good and correct C programs. The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems. Learning to write a program that does what you want it to do is actually not difficult. Knowing what you want your program to do is the more challenging part!","title":"1. What is a Program?"},{"location":"01-program.html#unit-1-what-is-a-program","text":"","title":"Unit 1: What is a Program?"},{"location":"01-program.html#learning-outcomes","text":"After this unit, students should: have an idea of what is a program and how a program is executed by a computer understand the basic terminologies: machine code, assembly language, and higher-level programming languages","title":"Learning Outcomes"},{"location":"01-program.html#what-is-a-computer-program","text":"Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task. Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.","title":"What is a (computer) program?"},{"location":"01-program.html#how-computer-executes-a-program","text":"In order to learn how to write a program, it is important to have an overview of how a computer executes a program. You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process. The two important components of a computer we will discuss for CS1010 is the CPU, or central processing unit and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so. A memory location is addressable using a memory address . The instructions to the CPU comes in the form of machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things. These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location. The data stored in the memory is also stored as a sequence of 1s and 0s.","title":"How computer executes a program"},{"location":"01-program.html#from-machine-code-to-high-level-programming-language","text":"While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this is actually determined by the operating system). The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human. Simple operations such as comparing which number is bigger might require several instructions to perform. To get around the readability problem, programmers can code in assembly language -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as decr , incr , store , add , etc.) Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming. Early programmers (in the fifties) understood this and designed high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent. A program written in one of these programming languages is then compiled into machine code for a specific CPU for execution using a compiler. The first commercially available language is FORTRAN from IBM in the 1950s. Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today, For many reasons , C is the language of choice for CS1010.","title":"From Machine Code to High-level Programming Language"},{"location":"01-program.html#the-goals-of-cs1010","text":"This brings us to the goals of CS1010. First, you will learn the most important syntax element of the C programming language. Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory. Third, you will learn the various tools and techniques that will help you produce good and correct C programs. The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems. Learning to write a program that does what you want it to do is actually not difficult. Knowing what you want your program to do is the more challenging part!","title":"The Goals of CS1010"},{"location":"02-algo.html","text":"Unit 2: Computational Problems and Algorithms Learning Outcomes: After this unit, students should: understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment be familiar with the algorithm to find the maximum among a list of numbers be able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect Computational Problems So, what is computational problem solving? Let's start with the question, what is a computational problem ? A computational problem is a problem that can be solved step-by-step with a computer. These problems usually have a well-defined input, constraints, and conditions that the output must satisfied. Here are some types of computational problems: A decision problem is one where the answer is yes or no. For instance, \"given a number n , is n even?\" is a decision problem. Some decision problems take more steps to solve than others. For instance, \"given a number n , is n prime?\" takes more steps than just checking the parity of a number. A search problem is one where the solution consists of one or more values that satisfies a given condition. For instance, we may want to compute a path from one geographical location to another on a map. A counting problem is one where the answer is the number of solutions to a search problem. An optimization problem is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way. For instance, we may want to compute the fastest route from one location to another. Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1 are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy. In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems computationally -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. Example: Finding the maximum Let's start with a simple problem. Given a finite list L L of k k integers ( k k > 0), find the integer with the maximum value from the list. First, let's consider if this is a computational problem. The input is very well defined. We know what an integer is. We are told we have at least one, and we have a finite number of them 2 . Second, let's consider the output. What conditions must the output satisfy? First, it has to be equal or larger than every other integer on the list. Second, it must be an integer in the list. This is well defined by the problem statement, so we can say that it is a computational problem. Here is an example. Suppose the input consists of: 4 1 -4 0 9 9 3 5 8 The output should be 9 . Now, you should pause reading and think about how you would solve this step-by-step. Algorithm One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far. When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list. Let's look at an example: Integers Scanned Maximum So Far 4 4 4 1 4 4 1 -4 4 4 1 -4 0 4 4 1 -4 0 9 9 4 1 -4 0 9 9 9 4 1 -4 0 9 9 3 9 4 1 -4 0 9 9 3 5 9 4 1 -4 0 9 9 3 5 8 9 The English description above, however, is not detailed enough for computers to understand. What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"? how to tell if we have reached \"the end of the list\"? Let's work out all the details. First, we need a concise way of representing the integers in the list. Borrowing from mathematical notation, let's say that the list L L contains the integers l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation l_i l_i , which is the integer currently being \"checked\". We begin with i = 0 i = 0 , then i = 1 i = 1 , then i = 2 i = 2 , etc, until i = k-1 i = k-1 . At every step, we increase i i by 1. Second, we need a concise way of keeping track of the maximum so far. We introduce another notation, m m , to represent the maximum value so far. When i = 0 i = 0 , m = l_0 m = l_0 . Since we only scan a single integer, it has to be the maximum. When we check another integer l_i (i > 0) l_i (i > 0) , only two things can happen: if this l_i l_i is larger than m m , then l_i l_i has to be the maximum so far, so we update m m to be l_i l_i . if l_i l_i is equal to or smaller than m m , then m m is still the maximum value so far. We keep doing the above and increase i i , until we reach the end of the list when (after increasing i i ) we find that i i is k k . Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers. Such steps, which the computer can take to solve a problem, is called an algorithm . Flowchart There are different ways one can describe an algorithm. The easiest way I find is to use a diagram called a flowchart . The flowchart for the algorithm above looks like this. A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. Please spend some time to trace through the walkthrough above. The snapshot of the values of the i i , l_i l_i , k k , and m m , at the point after \"is i i equals k k \" is shown in the table below (except for the first row, which shows the value just before entering \"is i i equals k k \") . Integers Scanned i i l_i l_i k k Maximum So Far ( m m ) 4 1 4 1 9 4 4 1 1 1 9 4 4 1 -4 2 -4 9 4 4 1 -4 0 3 0 9 4 4 1 -4 0 9 4 9 9 4 4 1 -4 0 9 9 5 9 9 9 4 1 -4 0 9 9 3 6 3 9 9 4 1 -4 0 9 9 3 5 7 5 9 9 4 1 -4 0 9 9 3 5 8 8 8 9 9 4 1 -4 0 9 9 3 5 8 9 `` 9 9 Variables There are a few important things to take note here. m m , i i , k k , and the list L L are what we called states or variables . While in the above, we can think of them as mathematical variables which we can assign values to, in a computer program, a variable is a location in the memory which holds a value. We can perform two very basic operations on the variables: reading and writing. In other words, we can set their values and we can retrieve their values. We can assign the value of one variable to a constant (e.g., set i i to 1) or to the value of another variable (e.g., set m m to l_i l_i ). In the latter example, we first read the value of l_i l_i , from l_i l_i 's memory location and then we write that value to the memory location of m m . Once written, the value of m m will not change until the next time we update the value of m m . It is important to note that, when i i changes, m m does not change automatically to the new l_i l_i This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say A1 to be =B1 , when the value in cell B1 changes, the value A1 also changes automatically. We can also compare the values of two variables. We see two examples above: \" i i equals k k ?\" \" l_i > m l_i > m ?\" When we compare, we read the values of the variables from their memory location and checks their relations. We can perform arithmetic operations on the variables: addition, subtraction, etc. We see one example above: \"increment i i \". This operation is actually an assignment operation in disguise. We can write it as \"set i i to i i + 1\". Here, you see that i i is referred to twice. This operation reads the value from the memory location of i i , adds 1 to it, and then writes the resulting value back to the location of i i . Bugs If you follow the execution of the algorithm above, step-by-step, using the example input 4 1 -4 0 9 9 3 5 above, you will obtain the correct maximum value m m of 9 . But does that mean that the algorithm is correct? The answer is NO. For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem. If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect. Note that I say does not produce the correct output , which means that either the algorithm produces the wrong output or does not produce any output at all . In this case, we say that the algorithm or the program has a bug . A bug is a defect that causes the algorithm to behave incorrectly. As a software developer, you will spend some time finding bugs in your code, a process known as debugging . A debugger is a tool that helps programmers find bugs in their code. Before we even start the process of debugging, we first have to know if our algorithm is correct. Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs. So, one way to check if an algorithm is correct is to try it with all possible valid inputs. For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs. In practice, we craft a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and hope that it is correct for all possible inputs. With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code. There are also systematic ways of deriving test cases so that the test cases cover different paths of execution of the algorithm, but we won't be covering it in CS1010 3 . Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm. We will do this rather informally in CS1010, starting in 1-2 lectures from now. You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms). Finally, even if an algorithm is correct, the corresponding program might not be. Recall that an algorithm is a step-by-step process to solve a problem. It is what you want your program to do. You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to implement the algorithm ). This process of translating the algorithm to a computer program, called coding may introduce bugs as well. But we will worry about this later when we learn to program. In the problem set at the end of this lecture, you will see slight variations of the algorithm above. You should check through them to see whether they are correct or not. Problem Set Problem 1.1 The following algorithms are slight variations of the one in the notes above. The differences are highlighted in red. Do they correctly find the maximum integer from a finite list of k k integers ( k > 0 k > 0 )? If an algorithm is buggy, give a counter-example where the output is incorrect. In addition, give an example input where the algorithm still produces the correct output, where possible. (a). (b). \u00a9. (d). (e). Problem 1.2 Change the algorithm above to find the minimum value instead of the maximum value from the given list L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} . You can also assume that the list L L is finite and k > 0 k > 0 for this question . Problem 1.3 Draw the flowchart for an algorithm, that takes in a list of integers L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the sum of all the integers. Think about what variable(s) do you need. The answer is, by the way, always \"Yes.\" \u21a9 Think about why it is important to have a finite number of integers in the input. \u21a9 Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218. \u21a9","title":"2. Computational Problem &amp; Algorithms"},{"location":"02-algo.html#unit-2-computational-problems-and-algorithms","text":"","title":"Unit 2: Computational Problems and Algorithms"},{"location":"02-algo.html#learning-outcomes","text":"After this unit, students should: understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment be familiar with the algorithm to find the maximum among a list of numbers be able to trace through flowcharts and updates of variables, and argue if a given algorithm is correct or incorrect","title":"Learning Outcomes:"},{"location":"02-algo.html#computational-problems","text":"So, what is computational problem solving? Let's start with the question, what is a computational problem ? A computational problem is a problem that can be solved step-by-step with a computer. These problems usually have a well-defined input, constraints, and conditions that the output must satisfied. Here are some types of computational problems: A decision problem is one where the answer is yes or no. For instance, \"given a number n , is n even?\" is a decision problem. Some decision problems take more steps to solve than others. For instance, \"given a number n , is n prime?\" takes more steps than just checking the parity of a number. A search problem is one where the solution consists of one or more values that satisfies a given condition. For instance, we may want to compute a path from one geographical location to another on a map. A counting problem is one where the answer is the number of solutions to a search problem. An optimization problem is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way. For instance, we may want to compute the fastest route from one location to another. Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1 are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy. In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems computationally -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.","title":"Computational Problems"},{"location":"02-algo.html#example-finding-the-maximum","text":"Let's start with a simple problem. Given a finite list L L of k k integers ( k k > 0), find the integer with the maximum value from the list. First, let's consider if this is a computational problem. The input is very well defined. We know what an integer is. We are told we have at least one, and we have a finite number of them 2 . Second, let's consider the output. What conditions must the output satisfy? First, it has to be equal or larger than every other integer on the list. Second, it must be an integer in the list. This is well defined by the problem statement, so we can say that it is a computational problem. Here is an example. Suppose the input consists of: 4 1 -4 0 9 9 3 5 8 The output should be 9 . Now, you should pause reading and think about how you would solve this step-by-step.","title":"Example: Finding the maximum"},{"location":"02-algo.html#algorithm","text":"One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far. When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list. Let's look at an example: Integers Scanned Maximum So Far 4 4 4 1 4 4 1 -4 4 4 1 -4 0 4 4 1 -4 0 9 9 4 1 -4 0 9 9 9 4 1 -4 0 9 9 3 9 4 1 -4 0 9 9 3 5 9 4 1 -4 0 9 9 3 5 8 9 The English description above, however, is not detailed enough for computers to understand. What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"? how to tell if we have reached \"the end of the list\"? Let's work out all the details. First, we need a concise way of representing the integers in the list. Borrowing from mathematical notation, let's say that the list L L contains the integers l_0, l_1, ..., l_{k-1} l_0, l_1, ..., l_{k-1} . To \"check one-by-one,\" we introduce another notation l_i l_i , which is the integer currently being \"checked\". We begin with i = 0 i = 0 , then i = 1 i = 1 , then i = 2 i = 2 , etc, until i = k-1 i = k-1 . At every step, we increase i i by 1. Second, we need a concise way of keeping track of the maximum so far. We introduce another notation, m m , to represent the maximum value so far. When i = 0 i = 0 , m = l_0 m = l_0 . Since we only scan a single integer, it has to be the maximum. When we check another integer l_i (i > 0) l_i (i > 0) , only two things can happen: if this l_i l_i is larger than m m , then l_i l_i has to be the maximum so far, so we update m m to be l_i l_i . if l_i l_i is equal to or smaller than m m , then m m is still the maximum value so far. We keep doing the above and increase i i , until we reach the end of the list when (after increasing i i ) we find that i i is k k . Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers. Such steps, which the computer can take to solve a problem, is called an algorithm .","title":"Algorithm"},{"location":"02-algo.html#flowchart","text":"There are different ways one can describe an algorithm. The easiest way I find is to use a diagram called a flowchart . The flowchart for the algorithm above looks like this. A diamond box represents a \"question\" that can be true or false (yes or no), and we trace through the \"flow\" step by step, following the corresponding path depending on the answer. Please spend some time to trace through the walkthrough above. The snapshot of the values of the i i , l_i l_i , k k , and m m , at the point after \"is i i equals k k \" is shown in the table below (except for the first row, which shows the value just before entering \"is i i equals k k \") . Integers Scanned i i l_i l_i k k Maximum So Far ( m m ) 4 1 4 1 9 4 4 1 1 1 9 4 4 1 -4 2 -4 9 4 4 1 -4 0 3 0 9 4 4 1 -4 0 9 4 9 9 4 4 1 -4 0 9 9 5 9 9 9 4 1 -4 0 9 9 3 6 3 9 9 4 1 -4 0 9 9 3 5 7 5 9 9 4 1 -4 0 9 9 3 5 8 8 8 9 9 4 1 -4 0 9 9 3 5 8 9 `` 9 9","title":"Flowchart"},{"location":"02-algo.html#variables","text":"There are a few important things to take note here. m m , i i , k k , and the list L L are what we called states or variables . While in the above, we can think of them as mathematical variables which we can assign values to, in a computer program, a variable is a location in the memory which holds a value. We can perform two very basic operations on the variables: reading and writing. In other words, we can set their values and we can retrieve their values. We can assign the value of one variable to a constant (e.g., set i i to 1) or to the value of another variable (e.g., set m m to l_i l_i ). In the latter example, we first read the value of l_i l_i , from l_i l_i 's memory location and then we write that value to the memory location of m m . Once written, the value of m m will not change until the next time we update the value of m m . It is important to note that, when i i changes, m m does not change automatically to the new l_i l_i This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say A1 to be =B1 , when the value in cell B1 changes, the value A1 also changes automatically. We can also compare the values of two variables. We see two examples above: \" i i equals k k ?\" \" l_i > m l_i > m ?\" When we compare, we read the values of the variables from their memory location and checks their relations. We can perform arithmetic operations on the variables: addition, subtraction, etc. We see one example above: \"increment i i \". This operation is actually an assignment operation in disguise. We can write it as \"set i i to i i + 1\". Here, you see that i i is referred to twice. This operation reads the value from the memory location of i i , adds 1 to it, and then writes the resulting value back to the location of i i .","title":"Variables"},{"location":"02-algo.html#bugs","text":"If you follow the execution of the algorithm above, step-by-step, using the example input 4 1 -4 0 9 9 3 5 above, you will obtain the correct maximum value m m of 9 . But does that mean that the algorithm is correct? The answer is NO. For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem. If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect. Note that I say does not produce the correct output , which means that either the algorithm produces the wrong output or does not produce any output at all . In this case, we say that the algorithm or the program has a bug . A bug is a defect that causes the algorithm to behave incorrectly. As a software developer, you will spend some time finding bugs in your code, a process known as debugging . A debugger is a tool that helps programmers find bugs in their code. Before we even start the process of debugging, we first have to know if our algorithm is correct. Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs. So, one way to check if an algorithm is correct is to try it with all possible valid inputs. For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs. In practice, we craft a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and hope that it is correct for all possible inputs. With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code. There are also systematic ways of deriving test cases so that the test cases cover different paths of execution of the algorithm, but we won't be covering it in CS1010 3 . Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm. We will do this rather informally in CS1010, starting in 1-2 lectures from now. You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms). Finally, even if an algorithm is correct, the corresponding program might not be. Recall that an algorithm is a step-by-step process to solve a problem. It is what you want your program to do. You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to implement the algorithm ). This process of translating the algorithm to a computer program, called coding may introduce bugs as well. But we will worry about this later when we learn to program. In the problem set at the end of this lecture, you will see slight variations of the algorithm above. You should check through them to see whether they are correct or not.","title":"Bugs"},{"location":"02-algo.html#problem-set","text":"","title":"Problem Set"},{"location":"02-algo.html#problem-11","text":"The following algorithms are slight variations of the one in the notes above. The differences are highlighted in red. Do they correctly find the maximum integer from a finite list of k k integers ( k > 0 k > 0 )? If an algorithm is buggy, give a counter-example where the output is incorrect. In addition, give an example input where the algorithm still produces the correct output, where possible. (a). (b). \u00a9. (d). (e).","title":"Problem 1.1"},{"location":"02-algo.html#problem-12","text":"Change the algorithm above to find the minimum value instead of the maximum value from the given list L = \\{l_0, ..., l_{k-1}\\} L = \\{l_0, ..., l_{k-1}\\} . You can also assume that the list L L is finite and k > 0 k > 0 for this question .","title":"Problem 1.2"},{"location":"02-algo.html#problem-13","text":"Draw the flowchart for an algorithm, that takes in a list of integers L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 L = \\{l_0, ..., l_{k-1}\\}, k \\ge 0 , and compute the sum of all the integers. Think about what variable(s) do you need. The answer is, by the way, always \"Yes.\" \u21a9 Think about why it is important to have a finite number of integers in the input. \u21a9 Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218. \u21a9","title":"Problem 1.3"},{"location":"03-func.html","text":"Unit 3: Functions Let's start with another problem. Problem: Finding the Range The range of a finite list of at least one integers L L is defined as the difference between the maximum and the minimum. For example, the range for 4 1 -4 0 9 9 3 5 8 is 13 . How do we find the range of a given list? To find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two. From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)! So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve . Let's call our solution to find the maximum value from a given list L L as max max . max max takes as input (i) a list L L and (ii) k k , the number of integers in L L . It produces, or returns , the maximum value among the integers in L L . Borrowing from mathematical notation, we use the notation max(L, k) max(L, k) to represent the maximum value of L L . Suppose that min(L,k) min(L,k) returns the minimum value among the integers in L L , then, the algorithm to find the range of L L can be written in a single line: max(L, k) - min(L, k) max(L, k) - min(L, k) Functions max max and min min are examples of a powerful and important concept with many names: function , procedure , subroutine , method , subprogram . In the context of CS1010, we will use the term function . Functions allow us to solve a problem by thinking about the solution at a higher level. For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far. We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value. Such an assumption, that we already know how to solve a subproblem, is known as wishful thinking . Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later. For instance, consider the following problem: Given a finite list of k k integers ( k > 0 k > 0 ), find the mean. The algorithm again, can be written in one line: sum(L, k) / k sum(L, k) / k if we assume that we have a function sum sum that can help us find the total of all k k integers. It turns out, in this case, that you should also know how to solve the subproblem sum sum , since it is Problem 1.3 from last week. We can then make this into a function itself, mean(L, k) mean(L, k) , which we can now use to solve other more complex problems. Thinking in terms of functions also have another advantage: given a function, we only need to worry about what it does, but not how it is done. We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions. Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems. In CS1010, we will also provide you with some functions to help you with your lab assignments. You will also define your own functions when solving problems with C. In fact, a C program is just a collection of functions calling each other. Problem: Finding Standard Deviation Let's look at another problem: Given L L , a finite list of at least one integers, find the standard deviation of the integers in L L . First, recall that the (population) standard deviation is given by \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}} \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}} where \\mu \\mu is the mean of the integers in L L . To compute the standard deviation, we first need to compute \\mu \\mu , the mean. We already know how to do that: mean(L, k) mean(L, k) . Then, we need to compute \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 . We can break it down into two subproblems: Given a list L L and a constant value x x , subtract x x from every number in L L , giving us a new list. Given a list, square every number in the list, giving us a new list. For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions substract(L, k, x) substract(L, k, x) and square(L, k) square(L, k) , then, the formula \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 can be computed by the following steps: set \\mu \\mu to mean(L, k) mean(L, k) set L' L' to substract(L, k, \\mu) substract(L, k, \\mu) set L'' L'' to square(L', k) square(L', k) set total total to sum(L'', k) sum(L'', k) . We can also write it in one line: set total total to sum(square(substract(L, k, mean(L, k)), k), k) sum(square(substract(L, k, mean(L, k)), k), k) Now, to compute the standard deviation, we need to divide total total by k k and find the square root. But, finding total total and dividing the result by k k is just mean mean . To compute square root, we again apply wishful thinking and assume that there is a function sqrt sqrt to do so. We can now compute the standard deviation with one line: sqrt(mean(square(substract(L, k, mean(L, k)), k), k)) sqrt(mean(square(substract(L, k, mean(L, k)), k), k)) Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems. We also see an example of reuse here -- mean mean is used twice with different inputs. Returning a list While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant. Let's worry about that later. Now that we have seen how to compute standard deviation by breaking it down the four subproblems, sqrt sqrt , mean mean , square square , and substract substract , we have to make sure that things we wish can be done can actually be done. The C library, and many programming languages, provide a pre-defined method to compute sqrt sqrt . We already know how to compute mean mean . Computing square square can be done as follows: The implementation for substract substract is similar. Another Solution for Finding Maximum In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far. Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way. Let's suppose that we have a function max'(L, i, j) max'(L, i, j) , that finds the maximum integer among the elements l_i, l_{i+1}, ... l_j l_i, l_{i+1}, ... l_j . The function max(L, k) max(L, k) , which finds the maximum among all elements of L L , is therefore the same as max'(L, 0, k-1) max'(L, 0, k-1) . Do we know how to solve max'(L, i, j) max'(L, i, j) without checking the integers in L L one-by-one? Well, if i i equals to j j , i.e., there is only one element in the range of l_i, ..., l_j l_i, ..., l_j , then yes, the function should return the value of l_i l_i . But, what if there are multiple elements in the range? (i.e., i < j i < j )? By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- max'(L, i+1, j) max'(L, i+1, j) , so the maximum value for the range of l_i, ..., l_j l_i, ..., l_j is the larger of the two: either l_i l_i , or max'(L, i+1, j) max'(L, i+1, j) . We can express this algorithm as follows: Let's trace through the algorithm above, using our previous example: 4 1 -4 0 9 9 3 5 8 . Given this list, we compare the first element, 4 , with the maximum of the rest of the list 1 -4 0 9 9 3 5 8 . Since with wishful thinking, we know how to solve this already, we get 9 as maximum value of 1 -4 0 9 9 3 5 8 . Comparing 4 and 9 , 9 is larger. Thus, the maximum value for the whole list is 9 . Example: Finding a Factorial Let us look at another example of a function before we move on to another topic. Suppose we want to write a function factorial(n) factorial(n) for an integer n n ( n \\ge 0 n \\ge 0 ) that computes n! n! . Recall that n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! . As a special case, 0! 0! is defined to be 1 1 . The algorithm to do this can be expressed by the following diagram: Let's look at an example. Let's say we want to compute factorial(4) factorial(4) . We assume we know how to solve this for a smaller problem -- factorial(3) factorial(3) , which is 6. factorial(4) factorial(4) is thus 4 \\times \\times 6, i.e., 24. Recursion: Function Calling Itself max' max' and factorial factorial are examples of functions which calls itself to solve a simpler version of the problem. This is known as recursion . We will revisit this concept in much greater detail in the later part of CS1010. Problem Set Problem 3.1 : Getting MAD The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is. The absolute deviation is the absolute difference between an element in the list with the mean of values of the list. The mean absolute deviation is the mean of all the absolute difference. In other words, given L = \\{l_0, ... l_{k-1}\\} L = \\{l_0, ... l_{k-1}\\} , the MAD of L L is: \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k} \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k} How do you find MAD by composing various functions we have seen? Do you need a new function? Problem 3.2 : Ownself calls ownself (a) Give an algorithm for finding the sum of all the integers in the list L L with k k integers ( k > 0 k > 0 ) that is recursive. (b) The function pow(i, j) pow(i, j) computes i^j i^j . Give an algorithm to compute pow(i, j) pow(i, j) recursively.","title":"3. Functions"},{"location":"03-func.html#unit-3-functions","text":"Let's start with another problem.","title":"Unit 3: Functions"},{"location":"03-func.html#problem-finding-the-range","text":"The range of a finite list of at least one integers L L is defined as the difference between the maximum and the minimum. For example, the range for 4 1 -4 0 9 9 3 5 8 is 13 . How do we find the range of a given list? To find the range of a list, we can break the solution down into three subtasks: first find the maximum, then find the minimum, and finally, find the difference between the two. From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)! So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve . Let's call our solution to find the maximum value from a given list L L as max max . max max takes as input (i) a list L L and (ii) k k , the number of integers in L L . It produces, or returns , the maximum value among the integers in L L . Borrowing from mathematical notation, we use the notation max(L, k) max(L, k) to represent the maximum value of L L . Suppose that min(L,k) min(L,k) returns the minimum value among the integers in L L , then, the algorithm to find the range of L L can be written in a single line: max(L, k) - min(L, k) max(L, k) - min(L, k)","title":"Problem: Finding the Range"},{"location":"03-func.html#functions","text":"max max and min min are examples of a powerful and important concept with many names: function , procedure , subroutine , method , subprogram . In the context of CS1010, we will use the term function . Functions allow us to solve a problem by thinking about the solution at a higher level. For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far. We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value. Such an assumption, that we already know how to solve a subproblem, is known as wishful thinking . Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later. For instance, consider the following problem: Given a finite list of k k integers ( k > 0 k > 0 ), find the mean. The algorithm again, can be written in one line: sum(L, k) / k sum(L, k) / k if we assume that we have a function sum sum that can help us find the total of all k k integers. It turns out, in this case, that you should also know how to solve the subproblem sum sum , since it is Problem 1.3 from last week. We can then make this into a function itself, mean(L, k) mean(L, k) , which we can now use to solve other more complex problems. Thinking in terms of functions also have another advantage: given a function, we only need to worry about what it does, but not how it is done. We can treat a function as a black box -- given an input, it will produce an output satisfying certain conditions. Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems. In CS1010, we will also provide you with some functions to help you with your lab assignments. You will also define your own functions when solving problems with C. In fact, a C program is just a collection of functions calling each other.","title":"Functions"},{"location":"03-func.html#problem-finding-standard-deviation","text":"Let's look at another problem: Given L L , a finite list of at least one integers, find the standard deviation of the integers in L L . First, recall that the (population) standard deviation is given by \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}} \\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}} where \\mu \\mu is the mean of the integers in L L . To compute the standard deviation, we first need to compute \\mu \\mu , the mean. We already know how to do that: mean(L, k) mean(L, k) . Then, we need to compute \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 . We can break it down into two subproblems: Given a list L L and a constant value x x , subtract x x from every number in L L , giving us a new list. Given a list, square every number in the list, giving us a new list. For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions substract(L, k, x) substract(L, k, x) and square(L, k) square(L, k) , then, the formula \\sum_{i=0}^{k-1} (l_i - \\mu)^2 \\sum_{i=0}^{k-1} (l_i - \\mu)^2 can be computed by the following steps: set \\mu \\mu to mean(L, k) mean(L, k) set L' L' to substract(L, k, \\mu) substract(L, k, \\mu) set L'' L'' to square(L', k) square(L', k) set total total to sum(L'', k) sum(L'', k) . We can also write it in one line: set total total to sum(square(substract(L, k, mean(L, k)), k), k) sum(square(substract(L, k, mean(L, k)), k), k) Now, to compute the standard deviation, we need to divide total total by k k and find the square root. But, finding total total and dividing the result by k k is just mean mean . To compute square root, we again apply wishful thinking and assume that there is a function sqrt sqrt to do so. We can now compute the standard deviation with one line: sqrt(mean(square(substract(L, k, mean(L, k)), k), k)) sqrt(mean(square(substract(L, k, mean(L, k)), k), k)) Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems. We also see an example of reuse here -- mean mean is used twice with different inputs. Returning a list While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant. Let's worry about that later. Now that we have seen how to compute standard deviation by breaking it down the four subproblems, sqrt sqrt , mean mean , square square , and substract substract , we have to make sure that things we wish can be done can actually be done. The C library, and many programming languages, provide a pre-defined method to compute sqrt sqrt . We already know how to compute mean mean . Computing square square can be done as follows: The implementation for substract substract is similar.","title":"Problem: Finding Standard Deviation"},{"location":"03-func.html#another-solution-for-finding-maximum","text":"In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far. Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way. Let's suppose that we have a function max'(L, i, j) max'(L, i, j) , that finds the maximum integer among the elements l_i, l_{i+1}, ... l_j l_i, l_{i+1}, ... l_j . The function max(L, k) max(L, k) , which finds the maximum among all elements of L L , is therefore the same as max'(L, 0, k-1) max'(L, 0, k-1) . Do we know how to solve max'(L, i, j) max'(L, i, j) without checking the integers in L L one-by-one? Well, if i i equals to j j , i.e., there is only one element in the range of l_i, ..., l_j l_i, ..., l_j , then yes, the function should return the value of l_i l_i . But, what if there are multiple elements in the range? (i.e., i < j i < j )? By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- max'(L, i+1, j) max'(L, i+1, j) , so the maximum value for the range of l_i, ..., l_j l_i, ..., l_j is the larger of the two: either l_i l_i , or max'(L, i+1, j) max'(L, i+1, j) . We can express this algorithm as follows: Let's trace through the algorithm above, using our previous example: 4 1 -4 0 9 9 3 5 8 . Given this list, we compare the first element, 4 , with the maximum of the rest of the list 1 -4 0 9 9 3 5 8 . Since with wishful thinking, we know how to solve this already, we get 9 as maximum value of 1 -4 0 9 9 3 5 8 . Comparing 4 and 9 , 9 is larger. Thus, the maximum value for the whole list is 9 .","title":"Another Solution for Finding Maximum"},{"location":"03-func.html#example-finding-a-factorial","text":"Let us look at another example of a function before we move on to another topic. Suppose we want to write a function factorial(n) factorial(n) for an integer n n ( n \\ge 0 n \\ge 0 ) that computes n! n! . Recall that n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)! . As a special case, 0! 0! is defined to be 1 1 . The algorithm to do this can be expressed by the following diagram: Let's look at an example. Let's say we want to compute factorial(4) factorial(4) . We assume we know how to solve this for a smaller problem -- factorial(3) factorial(3) , which is 6. factorial(4) factorial(4) is thus 4 \\times \\times 6, i.e., 24.","title":"Example: Finding a Factorial"},{"location":"03-func.html#recursion-function-calling-itself","text":"max' max' and factorial factorial are examples of functions which calls itself to solve a simpler version of the problem. This is known as recursion . We will revisit this concept in much greater detail in the later part of CS1010.","title":"Recursion: Function Calling Itself"},{"location":"03-func.html#problem-set","text":"","title":"Problem Set"},{"location":"03-func.html#problem-31-getting-mad","text":"The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is. The absolute deviation is the absolute difference between an element in the list with the mean of values of the list. The mean absolute deviation is the mean of all the absolute difference. In other words, given L = \\{l_0, ... l_{k-1}\\} L = \\{l_0, ... l_{k-1}\\} , the MAD of L L is: \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k} \\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k} How do you find MAD by composing various functions we have seen? Do you need a new function?","title":"Problem 3.1 : Getting MAD"},{"location":"03-func.html#problem-32-ownself-calls-ownself","text":"(a) Give an algorithm for finding the sum of all the integers in the list L L with k k integers ( k > 0 k > 0 ) that is recursive. (b) The function pow(i, j) pow(i, j) computes i^j i^j . Give an algorithm to compute pow(i, j) pow(i, j) recursively.","title":"Problem 3.2 : Ownself calls ownself"},{"location":"04-type.html","text":"Unit 4: Types Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory. Each unit of either 1 or 0 is known as a bit . 8 bits form a byte . Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits. The bits stored in the memory has no meaning by itself. It has to be interpreted by the machine code. Does a sequence of 1s and 0s represent an integer? A pixel of an image? A sound sample in an audio clip? A month? As a programmer, we have to tag the variable with its type , so that the machine code knows how to interpret the sequence of bits. In addition, the type also tells the machine code, how many bits \"belong\" to this variable. The number of bits of a type is also known as the size of a type. The size of a type determines how many different values a variable of that type can hold. For instance, a type of one bit can only hold two possible values (e.g., 0 or 1 , true or false , black or white ). A type of two bits can hold four values, represented as 00 , 01 , 10 , 11 . In general, a type of k k bits can hold 2^k 2^k values. Integers To represent integers, a type of 8 bits can represent 256 different values. If the type only represents non-negative integers (called unsigned ), then it can hold any value between 0 to 255. If it represents both positive and negative integers (called signed ), it can hold any value between -128 to 127. Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs. With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. This might look big enough for you -- but we can't even fit the results from factorial(21) factorial(21) here! We have to go to 128 bits to represent larger integers. Characters To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters. The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape). The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., Emoticons , Braille , Mahjong Tiles ) to be represented. Real Numbers For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits. In CS1231, you will learn that there are uncountably many possible real numbers. But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers. Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer! Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well). Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers. The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos. We do not have a type of size, say, 41 bits. The reason for this has to do with how memory location is addressed. This will again be explained in CS2100. Type Declaration In C, which we will use in CS1010, we have to associate every variable with a type, and once a variable is declared with a type, the type cannot be changed 1 . When we write a function, we have to declare the types of each of the parameters and the return value as well. Take the function mean(L, k) mean(L, k) as an example. We have said that L L is a list 2 of integers. So each element in L L should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage). What about k k ? k k refers to the number of elements in L L , so it has to be an integer. As for the value returned by mean(L, k) mean(L, k) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number. So we should choose a type that represents a real number for the return value. Importance of Type Choosing a wrong type to represent a variable can lead to buggy code. Suppose we say that mean(L, k) mean(L, k) returns an integer, then when we call mean mean on the input 1 2 3 4 , we will get 2 as the answer, instead of 2.5 as it should. This behavior is known as static typing. Some programming languages, such as Javascript and Python, are dynamically typed. The type of a variable may change depending on the value the variable is assigned to. \u21a9 We have not talked about how to represent a list yet. I will do that in a later unit. \u21a9","title":"4. Types"},{"location":"04-type.html#unit-4-types","text":"Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory. Each unit of either 1 or 0 is known as a bit . 8 bits form a byte . Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits. The bits stored in the memory has no meaning by itself. It has to be interpreted by the machine code. Does a sequence of 1s and 0s represent an integer? A pixel of an image? A sound sample in an audio clip? A month? As a programmer, we have to tag the variable with its type , so that the machine code knows how to interpret the sequence of bits. In addition, the type also tells the machine code, how many bits \"belong\" to this variable. The number of bits of a type is also known as the size of a type. The size of a type determines how many different values a variable of that type can hold. For instance, a type of one bit can only hold two possible values (e.g., 0 or 1 , true or false , black or white ). A type of two bits can hold four values, represented as 00 , 01 , 10 , 11 . In general, a type of k k bits can hold 2^k 2^k values.","title":"Unit 4: Types"},{"location":"04-type.html#integers","text":"To represent integers, a type of 8 bits can represent 256 different values. If the type only represents non-negative integers (called unsigned ), then it can hold any value between 0 to 255. If it represents both positive and negative integers (called signed ), it can hold any value between -128 to 127. Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs. With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. This might look big enough for you -- but we can't even fit the results from factorial(21) factorial(21) here! We have to go to 128 bits to represent larger integers.","title":"Integers"},{"location":"04-type.html#characters","text":"To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters. The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape). The unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., Emoticons , Braille , Mahjong Tiles ) to be represented.","title":"Characters"},{"location":"04-type.html#real-numbers","text":"For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits. In CS1231, you will learn that there are uncountably many possible real numbers. But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers. Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer! Because of this, programs that manipulate real numbers leads to weird answers (such as 0.1 + 0.2 is not exactly the same as 0.3) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well). Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers. The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos. We do not have a type of size, say, 41 bits. The reason for this has to do with how memory location is addressed. This will again be explained in CS2100.","title":"Real Numbers"},{"location":"04-type.html#type-declaration","text":"In C, which we will use in CS1010, we have to associate every variable with a type, and once a variable is declared with a type, the type cannot be changed 1 . When we write a function, we have to declare the types of each of the parameters and the return value as well. Take the function mean(L, k) mean(L, k) as an example. We have said that L L is a list 2 of integers. So each element in L L should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage). What about k k ? k k refers to the number of elements in L L , so it has to be an integer. As for the value returned by mean(L, k) mean(L, k) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number. So we should choose a type that represents a real number for the return value. Importance of Type Choosing a wrong type to represent a variable can lead to buggy code. Suppose we say that mean(L, k) mean(L, k) returns an integer, then when we call mean mean on the input 1 2 3 4 , we will get 2 as the answer, instead of 2.5 as it should. This behavior is known as static typing. Some programming languages, such as Javascript and Python, are dynamically typed. The type of a variable may change depending on the value the variable is assigned to. \u21a9 We have not talked about how to represent a list yet. I will do that in a later unit. \u21a9","title":"Type Declaration"},{"location":"05-first-c.html","text":"Unit 5: First C Program In this unit, we will write and compile your first C program. You have already learned, conceptually, what is a variable, what is a type and what is a function. Let's see how we apply these concepts to C. To start, let's look at a simple snippet of C code: int square ( int x ) { return x * x ; } The code above defines a function named square . The word int appears before the name square . int is used to signify an integer type. Appearing before the name square tells the compiler that square is returning a value of type int . After the word square , we write the parameters to the function in parenthesis ( and ) . In between ( and ) is int x : x is the name of the parameter, int is the type of that parameter. To summarize, in Line 1, int square(int x) defines a function named square that takes in an integer parameter x and is returning a value which is also an integer. The next three lines are written in between curly brackets { and } . You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java. These curly brackets group a block of statements together. In this example, this block defines how the function square computes the square of x , and what it returns. This is sometimes called the body of a function . In this function body, there is only one statement return x*x; within the block. A statement is a unit in a programming language that expresses either a command to be executed or declares a new variable or function. The word return says that this function square should return the following value, computed as x*x ( x multiply by x ). This statement is terminated by a semicolon ; . You also see that the line that starts with return is indented. We use indentation extensively to indicate the body of a block. Since we can have nested blocks, indentation makes our code easier to read and understand. The words int and return that appear above are keywords defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function). We cannot repurpose keywords in C. For instance, we cannot introduce a variable called int . We are now ready to write our first C program. The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3. int square ( int x ) { return x * x ; } int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } Remember that a C program consists of a bunch of functions, calling each other. The most important function is called main , and it is the entry point to the program. It is where the operating system will begin to execute the program. Every program must define exactly one function called main . int main () { : } main returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not. In this case, we always return 0 (success) assuming that nothing goes wrong for simplicity. This is the second example where you see the keyword return in action. In modern C, the main always return 0 when it exits. So, we will skip this statement return 0; from now on. Variable Declaration In the example above, you also see the lines int hypotenuse_square ; This is declaration statement (terminated with a semicolon, again). Each statement declares a variable with its corresponding type ( int here). We gave each variable a name, here we call the variable hypotenuse_square . Remember that all variables must be declared with its corresponding type before used in C . In C, a function must be either defined or declared before used as well. In the example above, we define square before main . If we switch the order of the two, the compiler will complain. Unless we declare the function first. Declaring a function means that we simply state the return type, the name, and the parameters, without the body. Here is an example: int square ( int x ); // declaring the function square int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } int square ( int x ) // defining the function square { return x * x ; } Assignment Statement The next line of the code shows an example of an assignment statement. hypotenuse_square = square ( 3 ) + square ( 4 ); An assignment operator takes the form of: left_hand_side = right_hand_side ; The left_hand_side must be the name of a variable. We first evaluate the right_hand_side of the assignment statement, find its value, then put the value into the variable named on the left_hand_side . Here, on the right-hand side, we call the function square , which we defined earlier. We call square with arguments 3 and 4 respectively. We use the operator + to add the two results together. The right-hand side should give the value 25, which we then assign to the variable hypotenuse_square . Note that we use = equal sign for assignment, NOT for checking equality. The C notation for checking for equality is == (we will come back to this later). Recap Before we move on, let's recap some concepts: A C program consists of functions, invoking each other. Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets). Each function must be defined or declared before it is used. The function body consists of one or more statements. We have seen assignment statements (using the = operator) and return statements, using return as the keyword. Each variable must be declared before it is used. A declaration starts with its type followed by its name. Example 2 Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself. Recall that we said C provides a bunch of predefined functions, include sqrt , which computes the square root of a given number. Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number. To represent real numbers, we commonly use the type float (which is short for a floating point number -- named so due to how a real number is represented in bits). A float type can store 32 bits. To double the precision (64 bits), we can use the type double . A long double type can store either 80-bits or 128-bits, depending on the implementation. But which one does sqrt returns? To find out the exact specification of a pre-defined function, we can consult the manual (or man for short) pages for the function. If you type man sqrt on the command line (or place the cursor on sqrt in vim and type K in command mode), you will see that the sqrt method has the following specification: double sqrt ( double x ); The sqrt function returns a double precision real number. We can now modify the program above to the following: double sqrt ( double x ); // not recommended long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } Note that the first line declares the function sqrt , because we need to declare a function before it is used. Since sqrt is pre-defined elsewhere, we do not have to supply the function body here. Such practice of declaring a predefined function ourselves, however, is not recommended. Different platform, compilers, libraries, may provide a different specification for the same function. As such, it is better to use the declaration from the library that provides the predefined function itself. A library usually provides one or more header files , a set of files that contain function declarations, type definitions, and constant definitions. In the case of sqrt , its declaration is contained in a header file called math.h (which we found out through consulting the man pages). To include this file, you add the line #include <math.h> at the top of the program. #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } You might notice the same line appear in the man page for sqrt . Thus, the man pages tell us which header file to include if you want to use a certain function. File Extension The convention for file extension for a C program is .c and for a C header file is .h . Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file. Other Types in C An int variable is usually 32-bits long. If we only need 16 bits, we use the type short int , or just short . If we only need 8-bits, we use the type char (short for character). Note that in the above, I said an int is usually 32 bits. Remember (from Unit 1 that a C program gets compiled into machine code for a specific CPU architecture. The C standard only guarantees that an int is at least 16 bits. Although most C compilers compile int to 32 bits, there is no guarantee! If we need something more than an int , we can use long int , or just long . The C standard guarantees that a long is at least 32 bits. Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits. To get even longer, we can use the type long long int , or just long long , which is guaranteed to be at least 64 bits 1 . Signed vs. Unsigned We have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value. By default, all types in C refer to signed types. If you want a variable that holds only non-negative integers, you can add the keyword unsigned to the front of the type. Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed). For instance, since we know that square can only return a non-zero integer, we can actually declare it as: unsigned long square ( long x ) { return x * x ; } For most practical purposes in CS1010, a (signed) long suffices. We introduce the notion of signed vs. unsigned for your information so that you know what they are when you come across them in others source code. Mixing signed and unsigned can lead to subtle bugs in your code. As such, we will only use signed long for CS1010 . You may choose to use them appropriately in another context, especially for embedded system or low-level programming. Unsigned Real Numbers? There are no unsigned versions of float and double . To understand the reason, we have to go further into how floating points numbers are represented in bits. That is a topic for another module. stdint.h Since the number of bits for int , long , and long long could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options: Do not write a program that assumes a specific number of bits is used for a certain type, or Use the type defined in the header file stdint.h : int8_t , uint8_t , int16_t , uint16_t , int32_t , uint32_t , int64_t , uint64_t . The suffix _t is a convention to indicate that this is a customized type (more on this in later units). The prefix u indicates that the type is an unsigned type. The numbers 8 , 16 , 32 , and 64 indicate the number of bits for each type. Thus, uint32_t is guaranteed to be of size 32 bits, and can hold unsigned integer values from 0 0 to 2^{32}-1 2^{32}-1 . Problem Set 5 Problem 5.1 In the example above, sqrt is declared to take in a parameter of type double . But the argument that we pass in is the sum of two int , which is also an int . Would this result in an error? Problem 5.2 Consider the following alternative definition of square ??? square ( uint16_t x ) { return x * x ; } What should the return type of this square be, in order for the return type to be big enough to store all possible value for x*x ? Adding more long does not make the integer longer, i.e., there is no long long long int . \u21a9","title":"5. First C Program"},{"location":"05-first-c.html#unit-5-first-c-program","text":"In this unit, we will write and compile your first C program. You have already learned, conceptually, what is a variable, what is a type and what is a function. Let's see how we apply these concepts to C. To start, let's look at a simple snippet of C code: int square ( int x ) { return x * x ; } The code above defines a function named square . The word int appears before the name square . int is used to signify an integer type. Appearing before the name square tells the compiler that square is returning a value of type int . After the word square , we write the parameters to the function in parenthesis ( and ) . In between ( and ) is int x : x is the name of the parameter, int is the type of that parameter. To summarize, in Line 1, int square(int x) defines a function named square that takes in an integer parameter x and is returning a value which is also an integer. The next three lines are written in between curly brackets { and } . You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java. These curly brackets group a block of statements together. In this example, this block defines how the function square computes the square of x , and what it returns. This is sometimes called the body of a function . In this function body, there is only one statement return x*x; within the block. A statement is a unit in a programming language that expresses either a command to be executed or declares a new variable or function. The word return says that this function square should return the following value, computed as x*x ( x multiply by x ). This statement is terminated by a semicolon ; . You also see that the line that starts with return is indented. We use indentation extensively to indicate the body of a block. Since we can have nested blocks, indentation makes our code easier to read and understand. The words int and return that appear above are keywords defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function). We cannot repurpose keywords in C. For instance, we cannot introduce a variable called int . We are now ready to write our first C program. The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and height of 3. int square ( int x ) { return x * x ; } int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } Remember that a C program consists of a bunch of functions, calling each other. The most important function is called main , and it is the entry point to the program. It is where the operating system will begin to execute the program. Every program must define exactly one function called main . int main () { : } main returns an integer to the operating system, to signal to the operating system whether the program exits successfully or not. In this case, we always return 0 (success) assuming that nothing goes wrong for simplicity. This is the second example where you see the keyword return in action. In modern C, the main always return 0 when it exits. So, we will skip this statement return 0; from now on.","title":"Unit 5: First C Program"},{"location":"05-first-c.html#variable-declaration","text":"In the example above, you also see the lines int hypotenuse_square ; This is declaration statement (terminated with a semicolon, again). Each statement declares a variable with its corresponding type ( int here). We gave each variable a name, here we call the variable hypotenuse_square . Remember that all variables must be declared with its corresponding type before used in C . In C, a function must be either defined or declared before used as well. In the example above, we define square before main . If we switch the order of the two, the compiler will complain. Unless we declare the function first. Declaring a function means that we simply state the return type, the name, and the parameters, without the body. Here is an example: int square ( int x ); // declaring the function square int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } int square ( int x ) // defining the function square { return x * x ; }","title":"Variable Declaration"},{"location":"05-first-c.html#assignment-statement","text":"The next line of the code shows an example of an assignment statement. hypotenuse_square = square ( 3 ) + square ( 4 ); An assignment operator takes the form of: left_hand_side = right_hand_side ; The left_hand_side must be the name of a variable. We first evaluate the right_hand_side of the assignment statement, find its value, then put the value into the variable named on the left_hand_side . Here, on the right-hand side, we call the function square , which we defined earlier. We call square with arguments 3 and 4 respectively. We use the operator + to add the two results together. The right-hand side should give the value 25, which we then assign to the variable hypotenuse_square . Note that we use = equal sign for assignment, NOT for checking equality. The C notation for checking for equality is == (we will come back to this later).","title":"Assignment Statement"},{"location":"05-first-c.html#recap","text":"Before we move on, let's recap some concepts: A C program consists of functions, invoking each other. Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis) and its body (within a pair of curly brackets). Each function must be defined or declared before it is used. The function body consists of one or more statements. We have seen assignment statements (using the = operator) and return statements, using return as the keyword. Each variable must be declared before it is used. A declaration starts with its type followed by its name.","title":"Recap"},{"location":"05-first-c.html#example-2","text":"Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself. Recall that we said C provides a bunch of predefined functions, include sqrt , which computes the square root of a given number. Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number. To represent real numbers, we commonly use the type float (which is short for a floating point number -- named so due to how a real number is represented in bits). A float type can store 32 bits. To double the precision (64 bits), we can use the type double . A long double type can store either 80-bits or 128-bits, depending on the implementation. But which one does sqrt returns? To find out the exact specification of a pre-defined function, we can consult the manual (or man for short) pages for the function. If you type man sqrt on the command line (or place the cursor on sqrt in vim and type K in command mode), you will see that the sqrt method has the following specification: double sqrt ( double x ); The sqrt function returns a double precision real number. We can now modify the program above to the following: double sqrt ( double x ); // not recommended long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } Note that the first line declares the function sqrt , because we need to declare a function before it is used. Since sqrt is pre-defined elsewhere, we do not have to supply the function body here. Such practice of declaring a predefined function ourselves, however, is not recommended. Different platform, compilers, libraries, may provide a different specification for the same function. As such, it is better to use the declaration from the library that provides the predefined function itself. A library usually provides one or more header files , a set of files that contain function declarations, type definitions, and constant definitions. In the case of sqrt , its declaration is contained in a header file called math.h (which we found out through consulting the man pages). To include this file, you add the line #include <math.h> at the top of the program. #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } You might notice the same line appear in the man page for sqrt . Thus, the man pages tell us which header file to include if you want to use a certain function. File Extension The convention for file extension for a C program is .c and for a C header file is .h . Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.","title":"Example 2"},{"location":"05-first-c.html#other-types-in-c","text":"An int variable is usually 32-bits long. If we only need 16 bits, we use the type short int , or just short . If we only need 8-bits, we use the type char (short for character). Note that in the above, I said an int is usually 32 bits. Remember (from Unit 1 that a C program gets compiled into machine code for a specific CPU architecture. The C standard only guarantees that an int is at least 16 bits. Although most C compilers compile int to 32 bits, there is no guarantee! If we need something more than an int , we can use long int , or just long . The C standard guarantees that a long is at least 32 bits. Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits. To get even longer, we can use the type long long int , or just long long , which is guaranteed to be at least 64 bits 1 .","title":"Other Types in C"},{"location":"05-first-c.html#signed-vs-unsigned","text":"We have seen earlier that the same sequence of bits, if interpreted as signed or unsigned, would result in a different value. By default, all types in C refer to signed types. If you want a variable that holds only non-negative integers, you can add the keyword unsigned to the front of the type. Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed). For instance, since we know that square can only return a non-zero integer, we can actually declare it as: unsigned long square ( long x ) { return x * x ; } For most practical purposes in CS1010, a (signed) long suffices. We introduce the notion of signed vs. unsigned for your information so that you know what they are when you come across them in others source code. Mixing signed and unsigned can lead to subtle bugs in your code. As such, we will only use signed long for CS1010 . You may choose to use them appropriately in another context, especially for embedded system or low-level programming. Unsigned Real Numbers? There are no unsigned versions of float and double . To understand the reason, we have to go further into how floating points numbers are represented in bits. That is a topic for another module.","title":"Signed vs. Unsigned"},{"location":"05-first-c.html#stdinth","text":"Since the number of bits for int , long , and long long could differ, in order to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options: Do not write a program that assumes a specific number of bits is used for a certain type, or Use the type defined in the header file stdint.h : int8_t , uint8_t , int16_t , uint16_t , int32_t , uint32_t , int64_t , uint64_t . The suffix _t is a convention to indicate that this is a customized type (more on this in later units). The prefix u indicates that the type is an unsigned type. The numbers 8 , 16 , 32 , and 64 indicate the number of bits for each type. Thus, uint32_t is guaranteed to be of size 32 bits, and can hold unsigned integer values from 0 0 to 2^{32}-1 2^{32}-1 .","title":"stdint.h"},{"location":"05-first-c.html#problem-set-5","text":"","title":"Problem Set 5"},{"location":"05-first-c.html#problem-51","text":"In the example above, sqrt is declared to take in a parameter of type double . But the argument that we pass in is the sum of two int , which is also an int . Would this result in an error?","title":"Problem 5.1"},{"location":"05-first-c.html#problem-52","text":"Consider the following alternative definition of square ??? square ( uint16_t x ) { return x * x ; } What should the return type of this square be, in order for the return type to be big enough to store all possible value for x*x ? Adding more long does not make the integer longer, i.e., there is no long long long int . \u21a9","title":"Problem 5.2"},{"location":"06-cs1010-io.html","text":"Unit 6: The CS1010 I/O Library Our first C program that computes the hypotenuse doesn't do much -- it simply computes \\sqrt(3^2 + 4^2) \\sqrt(3^2 + 4^2) . The value to be computed is hard-coded, and the result computed is not displayed. To make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle. We cannot hardcode the length in the program. We should read these values from the users. Second, we need to output the result of the computation to the users. In other words, to make the program more general and useful, we need to add input and output, or I/O, functions. Standard Input and Standard Output Before we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to. In UNIX-flavored operating systems, an input is read from an abstract channel called the standard input , or stdin for short, and an output is sent to an abstract channel called the standard output , or stdout for short. The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to. It will depend on how the user runs our program. Thus, it allows the users of our program the flexibility to control where the data comes from or goes to. For instance, the standard input, by default, reads from the keyboard. But the user can choose to read from a file, using the redirection < operator from the command line or from the output of another process, using the pipe | operator from the command line . Similarly, the standard output, by default, writes to the terminal. But the user can choose to write to a file using the redirection > operator on the command line or to the input of another process, using the pipe | operator, again, on the command line when invoking the program. You will see how cool these are later. But for the purpose of C programming, it suffices to know for now that we only need to read from stdin and write to stdout in our code, and we let the users decide where they come from / go to. No printf and scanf (yet) In almost all articles and textbooks on C that I have seen, the scanf and printf functions are taught as the standard C library functions to perform the input and output respectively. The function scanf , however, is tricky to use correctly and securely. The function printf comes with many nuances, such as remembering the different conversion specifiers and modifiers. I would rather not teach you scanf and printf at this stage. As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write long values, double values, space-separated words, and lines of text. You can find the documentation for the CS1010 I/O Library here . We will see how to use the library to improve our hypotenuse computation program here. Using the CS1010 I/O Library Let's modify our earlier program to now read the base and height from stdin , compute the hypotenuse, and print the results out to stdout . #include <math.h> #include \"cs1010.h\" long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { double hypotenuse ; long base = cs1010_read_long (); long height = cs1010_read_long (); hypotenuse = hypotenuse_of ( base , height ); cs1010_println_double ( hypotenuse ); } The first change you see (on Line 2) is to include the file cs1010.h , which includes the declaration of functions provided by the library. On Lines 17 and 18, we introduce two new long variables named base and height , which we initialized with the returned value from cs1010_read_long() . The function cs1010_read_long reads a long value from stdin and returns the value. For now, we assume that the inputs are correctly passed to the program. Finally, on Line 20, we print the resulting hypotenuse to stdout using the library function cs1010_println_double . Note that there are two versions of functions to print a double value: cs1010_println_double and cs1010_print_double . The one with println prints a new line character so that the text that got printed after appears in the next line. Refer to CS1010 Compilation Guide on how to compile a program that uses the CS1010 I/O library. Note that the main function above can be written as a single statement without any state and assignment. The resulting code, however, is not necessarily easier to understand. int main () { cs1010_println_double ( hypotenuse_of ( cs1010_read_long (), cs1010_read_long ())); }","title":"6. CS1010 I/O Library"},{"location":"06-cs1010-io.html#unit-6-the-cs1010-io-library","text":"Our first C program that computes the hypotenuse doesn't do much -- it simply computes \\sqrt(3^2 + 4^2) \\sqrt(3^2 + 4^2) . The value to be computed is hard-coded, and the result computed is not displayed. To make this program more general and useful, first, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle. We cannot hardcode the length in the program. We should read these values from the users. Second, we need to output the result of the computation to the users. In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.","title":"Unit 6: The CS1010 I/O Library"},{"location":"06-cs1010-io.html#standard-input-and-standard-output","text":"Before we talk about how to read the input values and display the output values, we have to first talk about where an input comes from and where an output goes to. In UNIX-flavored operating systems, an input is read from an abstract channel called the standard input , or stdin for short, and an output is sent to an abstract channel called the standard output , or stdout for short. The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to. It will depend on how the user runs our program. Thus, it allows the users of our program the flexibility to control where the data comes from or goes to. For instance, the standard input, by default, reads from the keyboard. But the user can choose to read from a file, using the redirection < operator from the command line or from the output of another process, using the pipe | operator from the command line . Similarly, the standard output, by default, writes to the terminal. But the user can choose to write to a file using the redirection > operator on the command line or to the input of another process, using the pipe | operator, again, on the command line when invoking the program. You will see how cool these are later. But for the purpose of C programming, it suffices to know for now that we only need to read from stdin and write to stdout in our code, and we let the users decide where they come from / go to.","title":"Standard Input and Standard Output"},{"location":"06-cs1010-io.html#no-printf-and-scanf-yet","text":"In almost all articles and textbooks on C that I have seen, the scanf and printf functions are taught as the standard C library functions to perform the input and output respectively. The function scanf , however, is tricky to use correctly and securely. The function printf comes with many nuances, such as remembering the different conversion specifiers and modifiers. I would rather not teach you scanf and printf at this stage. As such, CS1010 is providing you a library to perform I/O -- the library provides a small set of essential functions to read and write long values, double values, space-separated words, and lines of text. You can find the documentation for the CS1010 I/O Library here . We will see how to use the library to improve our hypotenuse computation program here.","title":"No printf and scanf (yet)"},{"location":"06-cs1010-io.html#using-the-cs1010-io-library","text":"Let's modify our earlier program to now read the base and height from stdin , compute the hypotenuse, and print the results out to stdout . #include <math.h> #include \"cs1010.h\" long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { double hypotenuse ; long base = cs1010_read_long (); long height = cs1010_read_long (); hypotenuse = hypotenuse_of ( base , height ); cs1010_println_double ( hypotenuse ); } The first change you see (on Line 2) is to include the file cs1010.h , which includes the declaration of functions provided by the library. On Lines 17 and 18, we introduce two new long variables named base and height , which we initialized with the returned value from cs1010_read_long() . The function cs1010_read_long reads a long value from stdin and returns the value. For now, we assume that the inputs are correctly passed to the program. Finally, on Line 20, we print the resulting hypotenuse to stdout using the library function cs1010_println_double . Note that there are two versions of functions to print a double value: cs1010_println_double and cs1010_print_double . The one with println prints a new line character so that the text that got printed after appears in the next line. Refer to CS1010 Compilation Guide on how to compile a program that uses the CS1010 I/O library. Note that the main function above can be written as a single statement without any state and assignment. The resulting code, however, is not necessarily easier to understand. int main () { cs1010_println_double ( hypotenuse_of ( cs1010_read_long (), cs1010_read_long ())); }","title":"Using the CS1010 I/O Library"},{"location":"07-arithmetic-ops.html","text":"Unit 7: Arithmetic Operations You have seen the + operator in the previous units. You can use + to add two variables, a value and a variable, or two values: long a = 1 ; long b = 2 ; long c = 3 ; a = b + c ; // add two variables b = a + 4 ; // add a variable to a value c = 5 + 6 ; // add two values You can also use + on values returned by functions: hypotenuse = sqrt ( square ( base ) + square ( height )); You have also seen the multiplication operator * . It can be used in the same way as the + operator. Three other useful operators are: / - division (e.g., double half_x = x / 2; ) - - subtraction (e.g., long deducted = income - 100 ) % - modulo (e.g, long last_digit = number % 10 ); The + , - , * , and / operators work on both integer types ( char , short , int , long , long long ) and real numbers ( float , double ). The module operator % works only on integer types. Operator Precedence We can chain the operations together to form expressions such as: long b = 10 ; long c = 2 ; long a = b + 2 * c / 4 ; When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation. What is the value of a after the three lines above are executed? C actually has well-defined rules to the order of evaluation for the operators: * , / , and % take precedence over + and - , and the operators are evaluated from left to right. Thus, in the example above, a will be 11 instead of 6 after the execution. To change the order of execution, we can add parenthesis to the expression. For instance: long a = ( b + 2 ) * c / 4 ; // 6 long a = b + ( 2 * c / 4 ); // 11 The expression in the parenthesis will be evaluated first. To make your code easier to understand, you should add parenthesis even if the order of evaluation is from left to right to make the order of evaluation explicit. Compound Operators It is common to modify the value of a variable and store new value back to the same variable. For example, index = index + 1 ; // increment the variable index age = age * 2 ; // double the variable age C provides compound operators that simplify the expressions above. For example, index += 1 ; age *= 2 ; The syntax for a compound operator is op= , where op can be + , - , * , / , % , or other binary operators. The statement: a op= b; modifies a the same way as: a = a op b Common Mistakes Using Arithmetic Operations It is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type. A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics. Let's look at two common gotchas. Overflow Consider the following code: uint8_t c = 255 ; c += 1 ; What is the value of variable c after the operation above? Here, we are adding one to the value 255, so c must store the value 256, right? It turns out that after the execution above, c contains the value 0. The variable c is of the type uint8_t , which is the unsigned 8-bit integer. Being 8-bit, the variable can store values from 0 to 255. When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in c -- there is not enough bits! In this case, the value stored is \"wrap around\", and we get the value 0 instead. The variable c above is unsigned. It gets trickier if c is signed. In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard. Integer Division Now, let's consider the following code: double half = 3 / 2 ; What is the value of variable half after the operation above? It got to be 1.5, right? It turns out that, after executing the code above, the value of half is 1.0. To understand this, first, let's see what happen when we assign a floating point number to an integer type: int x = 1.5 ; C truncates the floating number and only stores the integer part of the value, 1 in this case, in x . Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types. If one of the operands is a floating point number, the result will be a floating point number 1 . Since 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1. We then store 1 into a double variable, causing the value of half to become 1.0 . Because of this limitation, the operation / is sometimes also known as integer division when both operands are integers. In order to get the result 1.5 as expected, we can write either: double half = 3 / 2.0 ; or double half = 3 / ( double ) 2 ; The second fix above explicitly convert the type, or cast the type of value 2 into a double . Avoid Increment / Decrement Operator If you read C code in other places, you will certainly come across the increment or decrement operator, ++ or -- . The operators add one and minus one from the operand respectively. So, the statement index += 1 ; can be further shortened into index++; and the statement index -= 1 ; can be further shorten into index--; Using these two operators only shorten your code by two characters per statement, but introduces several issues. As such, we ban the use of both increment and decrement operator in CS1010 . So, why aren't ++ and -- welcomed in CS1010? The ++ and -- operators not only modify the value of the operand, it also returns a value. We can write j = i++; to both increment i and assign the pre-incremented value of i to j . In C, we can also write j = ++i; , which again, increment i , and assign the post-incremented value of i to j . Things get tricky, when we write i = i++; , it is not clear how to interpret this. The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior. Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted. The actual rules used by C, called integer promotion and usual arithmetic conversion , are much more complex and are outside the scope of CS1010. You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at this . \u21a9","title":"7. Arithmetic Operations"},{"location":"07-arithmetic-ops.html#unit-7-arithmetic-operations","text":"You have seen the + operator in the previous units. You can use + to add two variables, a value and a variable, or two values: long a = 1 ; long b = 2 ; long c = 3 ; a = b + c ; // add two variables b = a + 4 ; // add a variable to a value c = 5 + 6 ; // add two values You can also use + on values returned by functions: hypotenuse = sqrt ( square ( base ) + square ( height )); You have also seen the multiplication operator * . It can be used in the same way as the + operator. Three other useful operators are: / - division (e.g., double half_x = x / 2; ) - - subtraction (e.g., long deducted = income - 100 ) % - modulo (e.g, long last_digit = number % 10 ); The + , - , * , and / operators work on both integer types ( char , short , int , long , long long ) and real numbers ( float , double ). The module operator % works only on integer types.","title":"Unit 7: Arithmetic Operations"},{"location":"07-arithmetic-ops.html#operator-precedence","text":"We can chain the operations together to form expressions such as: long b = 10 ; long c = 2 ; long a = b + 2 * c / 4 ; When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation. What is the value of a after the three lines above are executed? C actually has well-defined rules to the order of evaluation for the operators: * , / , and % take precedence over + and - , and the operators are evaluated from left to right. Thus, in the example above, a will be 11 instead of 6 after the execution. To change the order of execution, we can add parenthesis to the expression. For instance: long a = ( b + 2 ) * c / 4 ; // 6 long a = b + ( 2 * c / 4 ); // 11 The expression in the parenthesis will be evaluated first. To make your code easier to understand, you should add parenthesis even if the order of evaluation is from left to right to make the order of evaluation explicit.","title":"Operator Precedence"},{"location":"07-arithmetic-ops.html#compound-operators","text":"It is common to modify the value of a variable and store new value back to the same variable. For example, index = index + 1 ; // increment the variable index age = age * 2 ; // double the variable age C provides compound operators that simplify the expressions above. For example, index += 1 ; age *= 2 ; The syntax for a compound operator is op= , where op can be + , - , * , / , % , or other binary operators. The statement: a op= b; modifies a the same way as: a = a op b","title":"Compound Operators"},{"location":"07-arithmetic-ops.html#common-mistakes-using-arithmetic-operations","text":"It is important to remember that, when arithmetic operations in C is performed on a sequence of bits, where the value that it can represent is limited and is determined by its type. A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics. Let's look at two common gotchas.","title":"Common Mistakes Using Arithmetic Operations"},{"location":"07-arithmetic-ops.html#overflow","text":"Consider the following code: uint8_t c = 255 ; c += 1 ; What is the value of variable c after the operation above? Here, we are adding one to the value 255, so c must store the value 256, right? It turns out that after the execution above, c contains the value 0. The variable c is of the type uint8_t , which is the unsigned 8-bit integer. Being 8-bit, the variable can store values from 0 to 255. When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in c -- there is not enough bits! In this case, the value stored is \"wrap around\", and we get the value 0 instead. The variable c above is unsigned. It gets trickier if c is signed. In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.","title":"Overflow"},{"location":"07-arithmetic-ops.html#integer-division","text":"Now, let's consider the following code: double half = 3 / 2 ; What is the value of variable half after the operation above? It got to be 1.5, right? It turns out that, after executing the code above, the value of half is 1.0. To understand this, first, let's see what happen when we assign a floating point number to an integer type: int x = 1.5 ; C truncates the floating number and only stores the integer part of the value, 1 in this case, in x . Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types. If one of the operands is a floating point number, the result will be a floating point number 1 . Since 3 and 2 are both integers, the resulting value 1.5 are stored in an integer, which causes it to become 1. We then store 1 into a double variable, causing the value of half to become 1.0 . Because of this limitation, the operation / is sometimes also known as integer division when both operands are integers. In order to get the result 1.5 as expected, we can write either: double half = 3 / 2.0 ; or double half = 3 / ( double ) 2 ; The second fix above explicitly convert the type, or cast the type of value 2 into a double .","title":"Integer Division"},{"location":"07-arithmetic-ops.html#avoid-increment-decrement-operator","text":"If you read C code in other places, you will certainly come across the increment or decrement operator, ++ or -- . The operators add one and minus one from the operand respectively. So, the statement index += 1 ; can be further shortened into index++; and the statement index -= 1 ; can be further shorten into index--; Using these two operators only shorten your code by two characters per statement, but introduces several issues. As such, we ban the use of both increment and decrement operator in CS1010 . So, why aren't ++ and -- welcomed in CS1010? The ++ and -- operators not only modify the value of the operand, it also returns a value. We can write j = i++; to both increment i and assign the pre-incremented value of i to j . In C, we can also write j = ++i; , which again, increment i , and assign the post-incremented value of i to j . Things get tricky, when we write i = i++; , it is not clear how to interpret this. The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior. Wei Tsang thinks that introducing all these complexities just to save two characters is not warranted. The actual rules used by C, called integer promotion and usual arithmetic conversion , are much more complex and are outside the scope of CS1010. You should take a note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at this . \u21a9","title":"Avoid Increment / Decrement Operator"},{"location":"08-if-else.html","text":"Unit 8: Conditional Statement So far the C programs that we have written has a straightforward execution path . The execution flows from top to bottom in main , jumping to a function being called (or callee ), and back to the caller when the function returns. We have, however, seen a few examples so far where the execution path can branch off to either one of two paths, depends on a condition: In the algorithm to compute the max(L, k) max(L, k) , we check if l_i > m l_i > m , and update m m only if this is true. In the algorithm to compute the factorial(n) factorial(n) , we check if n n equals 0, and return 1 if it is true, otherwise, we return n \\times factorial(n-1) n \\times factorial(n-1) . We are not ready to write C code that processes a list yet, so let's use the factorial(n) factorial(n) function as an example. In C, the factorial(n) factorial(n) would look like this: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } In this example, you see a new C keyword if . This keyword is used at the beginning of a conditional block of code. The general syntax is: if ( < logical expression > ) { \"true block\" : statements to be executed if expression evaluates to true } The if keyword is followed by a logical expression in parenthesis. This is followed by a block of statements (in curly braces { and } ). If the logical expression is true, then the statements are executed, otherwise, they are skipped. For this reason, the group of statements is known as a true block . Comparison Operator The logical expression n == 0 is true if the variable n holds the value of 0 . == vs = Note that use of TWO = signs. This is often confused by newbie programmers with a single = sign, which is used for assignment. A common bug is to write if ( n = 0 ) { : } The == is known as a comparison operator . It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include > (greater than), < (less than), >= (greater or equal to), <= (less than or equal to), and != (not equal). In other words, the function factorial will exit and return 1 if the parameter n equals to 0 . The rest of the code (particularly, Line 5 6) will be skipped. What if n is not 0 ? The block that contains Line 3 return 1; will be skipped, and Line 5 6 return n * factorial(n - 1); will be executed instead, which is what we intended for the factorial function to do. Example: Max of two numbers Let's switch to another example: suppose we have three variables, x , y , and max , and we want to set max to the maximum of x and y . Consider the following code snippet: if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } Take a moment to understand the code above, and see if you can figure out what is wrong. When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur. In this example, we need to think about what are the possible relationships between x and y when we compare x an y . There are actually three possibilities! x > y : in this case, x is larger and we set max to x y > x : in this case, y is larger and we set max to y x == y : in this case, both are equally large, so the maximum of the two can be either x or y . In the code above, max is not set properly if x == y ! The following code adds the third case and arbitrarily chooses to set max to y if both x and y have the same value. if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } Else The code snippet above now correctly sets max to the maximum of x and y . The code, however, is not very satisfying, since we compare between x and y three times. Let's see how we can reduce the number of comparisons to one. We are going to do some refactoring of the code above. First, observe that the \"true block\" for x < y and x == y are the same, and we can combine it into a single comparison x <= y . if ( x > y ) { max = x ; } if ( x <= y ) { max = y ; } Second, observe that if x > y is false, then x <= y must be true. We say that x > y and x <= y are negation (or opposite) of each other. So, the check for x <= y is redundant -- checking x > y is enough to tell us if x <= y . We can re-write the code above as: if ( x > y ) { max = x ; } else { max = y ; } The word else as seen above is another C keyword -- it must be used in conjunction with if to indicate an alternate path of execution if the logical expression is false. if ( < logical expression > ) { \"true block\" : statements to be executed if expression evaluates to true } else { \"false block\" : statements to be executed if expression evaluates to false } Nested Else-If The example above considers two possible execution paths only. In some situations, we may need to consider more than two execution paths. Take the following problem for example. You are given the numerical score for an assignment, ranged between 0 and 10. Print out the letter grade of the assignment according to the table below: Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D Since the if - else statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the if - else statements hierarchically. We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row. Score Letter Grade 8 or higher A Less than 8 See Table 1 Table 1 (less than 8) Score Letter Grade 5 or higher B Less than 5 See Table 2 Table 2 (less than 5) Score Letter Grade 3 or higher C Less than 3 D The tables above can then be written into the following function: void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } There are three nested if - else in the function above. Note how I use indentation to clearly indicate the nesting of blocks. Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010. The code below compiles perfectly but is not as easy to read by a human as the above. void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } // Don't write code like this. There are also a couple of \"first\" in the sample code above: You see the keyword void for the first time. void is a special type that indicates nothing. The function print_score does not return anything, it accepts an input score and print something to screen. As such, we say that the return type of print_score is void . You see strings for the first time ( \"A\" , etc.). A string basically is a sequence of characters. We use double quotes \" to mark the beginning and the end of a string, and use the CS1010 I/O library function cs1010_println_string to print a string to the screen. You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested if - else , and the code gets complicated. To reduce the number of nesting, we can write else if directly, without nesting: void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } The above code is easier to read, but has exactly the same flow as the one with nested if - else earlier. Avoid Skipping the Curly Braces The C standard says that, if the block contains only one statement, we can skip the curly braces { and } . In the example above, we can write: void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"D\" ); } Despite being allowed by the C standard, this is considered a bad practice, and should be avoided. Imagine some time later, you go back to this code, and want to write something extra: void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"You can do better!\" ); cs1010_println_string ( \"D\" ); } What would be printed? The famous Apple goto fail bug wouldn't have happened in the there is a pair of curly braces added! Alternatively, if you have code like this: if ( score >= 8 ) if ( late_penalty != 0 ) cs1010_println_string ( \"late submission\" ); else cs1010_println_string ( \"you can do better!\" ); It might look like you can do better! will be printed if score is less than 8, but actually, you can do better! will be printed if the score is larger or equal to 8 and there is no late penalty, which is not what is intended. Conditional Operator The conditional operator consists of two special characters ? and : and is used in the format of: condition ? true expression : false expression; If the condition evaluates to true, then the true expression will be evaluated and returned, otherwise, the false expression will be evaluated and returned. The conditional operator allows us to replace if ( x > y ) { max = x ; } else { max = y ; } with a single line: max = (x > y) ? x : y; We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up. We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above. Comparing Real Numbers Recall that we said real numbers cannot be represented exactly in computers . Comparing real numbers, therefore, becomes a little bit trickier in programming. The if statement double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( sum == expected_value ) { : } would not be evaluated as true as expected! Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between sum and expected_value to be small enough. double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( fabs ( sum - expected_value ) < 0.000001 ) { : } Problem Sets Problem 8.1 (a) Do the following two functions behave the same way? Explain. long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } long factorial ( long n ) { if ( n == 0 ) { return 1 ; } else { return n * factorial ( n - 1 ); } } (b) How about: long factorial ( long n ) { long result ; if ( n == 0 ) { result = 1 ; } result = n * factorial ( n - 1 ); return result ; } and long factorial ( long n ) { long result ; if ( n == 0 ) { result = 1 ; } else { result = n * factorial ( n - 1 ); } return result ; } Problem 8.2 Draw the flowchart for the code snippet if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } and if ( x > y ) { max = x ; } else { max = y ; } Problem 8.3 Suppose we break down the table below in a slightly different way. Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D We rewrite the tables into three smaller tables, as: Score Letter Grade 5 or higher See Table 3 Less than 5 See Table 4 where Table 3 (5 or higher) is Score Letter Grade 8 or higher A Less than 8 B and Table 4 (less than 5) is Score Letter Grade 3 or higher C Less than 3 D Write the corresponding if - else statements to print out the letter grade based on the tables above. Appendix: Code From Lecture Here are the C files that Wei Tsang wrote during the lecture. #include \"cs1010.h\" long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } int main () { long n = cs1010_read_long (); long fac = factorial ( n ); cs1010_println_long ( fac ); } #include \"cs1010.h\" long max ( long x , long y ) { if ( x > y ) { return x ; } else { return y ; } // alternatively, using the conditional operator ? : // return (x > y) ? x : y; } int main () { long x = cs1010_read_long (); long y = cs1010_read_long (); long m = max ( x , y ); cs1010_println_long ( m ); } #include \"cs1010.h\" void print_score ( double x ) { if ( x >= 8 ) cs1010_println_string ( \"A\" ); else if ( x >= 5 ) cs1010_println_string ( \"B\" ); else if ( x >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"D\" ); } int main () { double score = cs1010_read_double (); print_score ( score ); }","title":"8. If Else"},{"location":"08-if-else.html#unit-8-conditional-statement","text":"So far the C programs that we have written has a straightforward execution path . The execution flows from top to bottom in main , jumping to a function being called (or callee ), and back to the caller when the function returns. We have, however, seen a few examples so far where the execution path can branch off to either one of two paths, depends on a condition: In the algorithm to compute the max(L, k) max(L, k) , we check if l_i > m l_i > m , and update m m only if this is true. In the algorithm to compute the factorial(n) factorial(n) , we check if n n equals 0, and return 1 if it is true, otherwise, we return n \\times factorial(n-1) n \\times factorial(n-1) . We are not ready to write C code that processes a list yet, so let's use the factorial(n) factorial(n) function as an example. In C, the factorial(n) factorial(n) would look like this: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } In this example, you see a new C keyword if . This keyword is used at the beginning of a conditional block of code. The general syntax is: if ( < logical expression > ) { \"true block\" : statements to be executed if expression evaluates to true } The if keyword is followed by a logical expression in parenthesis. This is followed by a block of statements (in curly braces { and } ). If the logical expression is true, then the statements are executed, otherwise, they are skipped. For this reason, the group of statements is known as a true block .","title":"Unit 8: Conditional Statement"},{"location":"08-if-else.html#comparison-operator","text":"The logical expression n == 0 is true if the variable n holds the value of 0 . == vs = Note that use of TWO = signs. This is often confused by newbie programmers with a single = sign, which is used for assignment. A common bug is to write if ( n = 0 ) { : } The == is known as a comparison operator . It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include > (greater than), < (less than), >= (greater or equal to), <= (less than or equal to), and != (not equal). In other words, the function factorial will exit and return 1 if the parameter n equals to 0 . The rest of the code (particularly, Line 5 6) will be skipped. What if n is not 0 ? The block that contains Line 3 return 1; will be skipped, and Line 5 6 return n * factorial(n - 1); will be executed instead, which is what we intended for the factorial function to do.","title":"Comparison Operator"},{"location":"08-if-else.html#example-max-of-two-numbers","text":"Let's switch to another example: suppose we have three variables, x , y , and max , and we want to set max to the maximum of x and y . Consider the following code snippet: if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } Take a moment to understand the code above, and see if you can figure out what is wrong. When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur. In this example, we need to think about what are the possible relationships between x and y when we compare x an y . There are actually three possibilities! x > y : in this case, x is larger and we set max to x y > x : in this case, y is larger and we set max to y x == y : in this case, both are equally large, so the maximum of the two can be either x or y . In the code above, max is not set properly if x == y ! The following code adds the third case and arbitrarily chooses to set max to y if both x and y have the same value. if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; }","title":"Example: Max of two numbers"},{"location":"08-if-else.html#else","text":"The code snippet above now correctly sets max to the maximum of x and y . The code, however, is not very satisfying, since we compare between x and y three times. Let's see how we can reduce the number of comparisons to one. We are going to do some refactoring of the code above. First, observe that the \"true block\" for x < y and x == y are the same, and we can combine it into a single comparison x <= y . if ( x > y ) { max = x ; } if ( x <= y ) { max = y ; } Second, observe that if x > y is false, then x <= y must be true. We say that x > y and x <= y are negation (or opposite) of each other. So, the check for x <= y is redundant -- checking x > y is enough to tell us if x <= y . We can re-write the code above as: if ( x > y ) { max = x ; } else { max = y ; } The word else as seen above is another C keyword -- it must be used in conjunction with if to indicate an alternate path of execution if the logical expression is false. if ( < logical expression > ) { \"true block\" : statements to be executed if expression evaluates to true } else { \"false block\" : statements to be executed if expression evaluates to false }","title":"Else"},{"location":"08-if-else.html#nested-else-if","text":"The example above considers two possible execution paths only. In some situations, we may need to consider more than two execution paths. Take the following problem for example. You are given the numerical score for an assignment, ranged between 0 and 10. Print out the letter grade of the assignment according to the table below: Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D Since the if - else statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the if - else statements hierarchically. We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row. Score Letter Grade 8 or higher A Less than 8 See Table 1 Table 1 (less than 8) Score Letter Grade 5 or higher B Less than 5 See Table 2 Table 2 (less than 5) Score Letter Grade 3 or higher C Less than 3 D The tables above can then be written into the following function: void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } There are three nested if - else in the function above. Note how I use indentation to clearly indicate the nesting of blocks. Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010. The code below compiles perfectly but is not as easy to read by a human as the above. void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } // Don't write code like this. There are also a couple of \"first\" in the sample code above: You see the keyword void for the first time. void is a special type that indicates nothing. The function print_score does not return anything, it accepts an input score and print something to screen. As such, we say that the return type of print_score is void . You see strings for the first time ( \"A\" , etc.). A string basically is a sequence of characters. We use double quotes \" to mark the beginning and the end of a string, and use the CS1010 I/O library function cs1010_println_string to print a string to the screen. You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested if - else , and the code gets complicated. To reduce the number of nesting, we can write else if directly, without nesting: void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } The above code is easier to read, but has exactly the same flow as the one with nested if - else earlier.","title":"Nested Else-If"},{"location":"08-if-else.html#avoid-skipping-the-curly-braces","text":"The C standard says that, if the block contains only one statement, we can skip the curly braces { and } . In the example above, we can write: void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"D\" ); } Despite being allowed by the C standard, this is considered a bad practice, and should be avoided. Imagine some time later, you go back to this code, and want to write something extra: void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"You can do better!\" ); cs1010_println_string ( \"D\" ); } What would be printed? The famous Apple goto fail bug wouldn't have happened in the there is a pair of curly braces added! Alternatively, if you have code like this: if ( score >= 8 ) if ( late_penalty != 0 ) cs1010_println_string ( \"late submission\" ); else cs1010_println_string ( \"you can do better!\" ); It might look like you can do better! will be printed if score is less than 8, but actually, you can do better! will be printed if the score is larger or equal to 8 and there is no late penalty, which is not what is intended.","title":"Avoid Skipping the Curly Braces"},{"location":"08-if-else.html#conditional-operator","text":"The conditional operator consists of two special characters ? and : and is used in the format of: condition ? true expression : false expression; If the condition evaluates to true, then the true expression will be evaluated and returned, otherwise, the false expression will be evaluated and returned. The conditional operator allows us to replace if ( x > y ) { max = x ; } else { max = y ; } with a single line: max = (x > y) ? x : y; We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up. We do not encourage you to nest the conditional operator in CS1010 and to limit its usage to simple cases above.","title":"Conditional Operator"},{"location":"08-if-else.html#comparing-real-numbers","text":"Recall that we said real numbers cannot be represented exactly in computers . Comparing real numbers, therefore, becomes a little bit trickier in programming. The if statement double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( sum == expected_value ) { : } would not be evaluated as true as expected! Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between sum and expected_value to be small enough. double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( fabs ( sum - expected_value ) < 0.000001 ) { : }","title":"Comparing Real Numbers"},{"location":"08-if-else.html#problem-sets","text":"","title":"Problem Sets"},{"location":"08-if-else.html#problem-81","text":"(a) Do the following two functions behave the same way? Explain. long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } long factorial ( long n ) { if ( n == 0 ) { return 1 ; } else { return n * factorial ( n - 1 ); } } (b) How about: long factorial ( long n ) { long result ; if ( n == 0 ) { result = 1 ; } result = n * factorial ( n - 1 ); return result ; } and long factorial ( long n ) { long result ; if ( n == 0 ) { result = 1 ; } else { result = n * factorial ( n - 1 ); } return result ; }","title":"Problem 8.1"},{"location":"08-if-else.html#problem-82","text":"Draw the flowchart for the code snippet if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } and if ( x > y ) { max = x ; } else { max = y ; }","title":"Problem 8.2"},{"location":"08-if-else.html#problem-83","text":"Suppose we break down the table below in a slightly different way. Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D We rewrite the tables into three smaller tables, as: Score Letter Grade 5 or higher See Table 3 Less than 5 See Table 4 where Table 3 (5 or higher) is Score Letter Grade 8 or higher A Less than 8 B and Table 4 (less than 5) is Score Letter Grade 3 or higher C Less than 3 D Write the corresponding if - else statements to print out the letter grade based on the tables above.","title":"Problem 8.3"},{"location":"08-if-else.html#appendix-code-from-lecture","text":"Here are the C files that Wei Tsang wrote during the lecture. #include \"cs1010.h\" long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } int main () { long n = cs1010_read_long (); long fac = factorial ( n ); cs1010_println_long ( fac ); } #include \"cs1010.h\" long max ( long x , long y ) { if ( x > y ) { return x ; } else { return y ; } // alternatively, using the conditional operator ? : // return (x > y) ? x : y; } int main () { long x = cs1010_read_long (); long y = cs1010_read_long (); long m = max ( x , y ); cs1010_println_long ( m ); } #include \"cs1010.h\" void print_score ( double x ) { if ( x >= 8 ) cs1010_println_string ( \"A\" ); else if ( x >= 5 ) cs1010_println_string ( \"B\" ); else if ( x >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"D\" ); } int main () { double score = cs1010_read_double (); print_score ( score ); }","title":"Appendix: Code From Lecture"},{"location":"09-logical-exp.html","text":"Unit 9: Logical Expression Representing a Boolean Value You have seen some basic logical expressions in Unit 8 . n == 0 , x > y , y > x , are all logical expressions. They evaluate to either true or false. We call a type that can contain either true or false as a Boolean data type, named after George Boole , a mathematician. The Boolean data type in C named bool . It can hold two values: true or false . All three of bool , true , and false are keywords introduced in modern C. To use them, you need to include the file stdbool.h at the top of your program. Use bool is considered a cleaner way of representing true and false in C. Classically, C defines the numeric value 0 to be false, and everything else to be true. So, you can write code like this: // x and y are long. long is_diff = x - y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } The above is harder to understand and should be avoided. A cleaner way is to write: bool is_diff = x != y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } Although not required by C, we will name a bool variable with a prefix is_ or has_ as a convention. The code above can also be written as: bool is_diff = x != y ; if ( is_diff == true ) { cs1010_println_string ( \"x and y store different values.\" ); } The comparison with true is redundant, however, and should be skipped. Logical Operators Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values. These allow us to write complex logical expressions. Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. We can write the function as follows using what we have known: bool is_gen_z ( long birth_year ) { if ( birth_year >= 1995 ) { if ( birth_year <= 2005 ) { return true ; } } return false ; } To be in Generation Z, both conditions birth_year >= 1995 and birth_year <= 2005 must be true. We can use the logical AND && operator to simplify the code above to: bool is_gen_z ( long birth_year ) { if (( birth_year >= 1995 ) && ( birth_year <= 2005 )) { return true ; } return false ; } or simply: bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } The AND operator, && , evaluates to true if and only if both operands are true. Common Error A common mistake by a new C programmer is to write 1995 <= birth_year <= 2005 as the logical expression. Unfortunately, in C, we cannot chain the comparison operators together. What if we want to write a function to determine if someone is NOT part of Generation Z? This means that they are born either before 1995 or after 2005. To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, || . bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives. So the example is_not_gen_z above is for illustration purposes only, we do not encourage you to write functions that check for the negatives. In any case, if we want to check if someone is not a Generation Z, we can use the ! NOT operator. if ( ! is_gen_z ( birth_year )) { : } This operator can be used as part of the boolean expression: bool is_not_gen_z ( long birth_year ) { return ! (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } Short Circuiting When evaluating the logical expressions that involve && and || , C uses \"short-circuiting\". This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation. The corresponding true and false value will be returned. Consider the following: bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } If the argument birth_year is 1970 , then, the expression (birth_year >= 1995) already evaluates to false , and the whole statement is false. We do not need to evaluate the second expression (birth_year <= 2005) . Similarly, for bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } When birth_year is 1970 , the expression (birth_year < 1995) is true , so we know that the whole statement is true . There is no need to check if (birth_year > 2005) . In both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no side effects in comparing birth_year to 2005 . But, let's suppose that we introduce two functions with side effects (of printing to screen): bool not_too_old ( long birth_year ) { if ( birth_year >= 1995 ) { cs1010_print_string ( \"not too old..\" ); return true ; } cs1010_print_string ( \"too old..\" ); return false ; } bool not_too_young ( long birth_year ) { if ( birth_year <= 2005 ) { cs1010_print_string ( \"not too young..\" ); return true ; } cs1010_print_string ( \"too young..\" ); return false ; } bool is_gen_z ( long birth_year ) { return not_too_old ( birth_year ) && not_too_young ( birth_year ); } When we call is_gen_z(1984) , you might expect too old..not too young.. to be printed, but due to short-circuiting, the code only prints too old.. . Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression. Take the following example: if ( number < 100000 && is_prime ( number )) { : } Checking whether a number is below 100,000 is easier than checking if a number is prime. So, we can skip checking for primality if the number is too big. Compare this to: if ( is_prime ( number ) && number < 100000 ) { : } Suppose number is a gigantic integer, then we would have spent lots of effort checking if number is a prime, only to find out that it is too big anyway! Problem Sets Problem 9.1 Given two bool variables, a and b , there are four possible combinations of true false values. What are the values of a && b , a || b , and !a for each of these combinations? Fill in the table below. a b a && b a || b !a true true true false false true false false Problem 9.2 Consider the function below, which aims to return the maximum value given three numbers. long max_of_three ( long a , long b , long c ) { long max = 0 ; if (( a > b ) && ( a > c )) { // a is larger than b and c max = a ; } if (( b > a ) && ( b > c )) { // b is larger than a and c max = b ; } if (( c > a ) && ( c > b )) { // c is larger than a and b max = c ; } return max ; } (a) What is wrong with the code above? (b) Give a sample test value of a , b , and c that would expose the bug. (C) Fix the code above to remove the bug. (d) Replace the three if statements in the code above with if - else statements. Draw the corresponding flowchart. Problem 9.3 Write a function that takes in a blood pressure measurement, and prints either low , ideal , pre-high , and high depending on the input values. The blood pressure is given as two long values, the systolic and the diastolic. The text to be printed depends on the range, depicted in the figure below. void print_blood_pressure ( long systolic , long diastolic ) { : } The figure does not say how to classify the data if the values fall exactly on the boundary of two regions. In this case, you can classify it to either region. Appendix: Code from Lecture #include \"cs1010.h\" #include <stdbool.h> bool is_gen_z ( long year ) { return (( year >= 1995 ) && ( year <= 2005 )); } bool is_not_gen_z ( long year ) { return (( year < 1995 ) || ( year > 2005 )); } int main () { long year = cs1010_read_long (); if ( is_gen_z ( year )) { cs1010_println_string ( \"Z!\" ); } else { cs1010_println_string ( \"Not Z!\" ); } }","title":"9. Logical Expression"},{"location":"09-logical-exp.html#unit-9-logical-expression","text":"","title":"Unit 9: Logical Expression"},{"location":"09-logical-exp.html#representing-a-boolean-value","text":"You have seen some basic logical expressions in Unit 8 . n == 0 , x > y , y > x , are all logical expressions. They evaluate to either true or false. We call a type that can contain either true or false as a Boolean data type, named after George Boole , a mathematician. The Boolean data type in C named bool . It can hold two values: true or false . All three of bool , true , and false are keywords introduced in modern C. To use them, you need to include the file stdbool.h at the top of your program. Use bool is considered a cleaner way of representing true and false in C. Classically, C defines the numeric value 0 to be false, and everything else to be true. So, you can write code like this: // x and y are long. long is_diff = x - y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } The above is harder to understand and should be avoided. A cleaner way is to write: bool is_diff = x != y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } Although not required by C, we will name a bool variable with a prefix is_ or has_ as a convention. The code above can also be written as: bool is_diff = x != y ; if ( is_diff == true ) { cs1010_println_string ( \"x and y store different values.\" ); } The comparison with true is redundant, however, and should be skipped.","title":"Representing a Boolean Value"},{"location":"09-logical-exp.html#logical-operators","text":"Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values. These allow us to write complex logical expressions. Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. We can write the function as follows using what we have known: bool is_gen_z ( long birth_year ) { if ( birth_year >= 1995 ) { if ( birth_year <= 2005 ) { return true ; } } return false ; } To be in Generation Z, both conditions birth_year >= 1995 and birth_year <= 2005 must be true. We can use the logical AND && operator to simplify the code above to: bool is_gen_z ( long birth_year ) { if (( birth_year >= 1995 ) && ( birth_year <= 2005 )) { return true ; } return false ; } or simply: bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } The AND operator, && , evaluates to true if and only if both operands are true. Common Error A common mistake by a new C programmer is to write 1995 <= birth_year <= 2005 as the logical expression. Unfortunately, in C, we cannot chain the comparison operators together. What if we want to write a function to determine if someone is NOT part of Generation Z? This means that they are born either before 1995 or after 2005. To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, || . bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives. So the example is_not_gen_z above is for illustration purposes only, we do not encourage you to write functions that check for the negatives. In any case, if we want to check if someone is not a Generation Z, we can use the ! NOT operator. if ( ! is_gen_z ( birth_year )) { : } This operator can be used as part of the boolean expression: bool is_not_gen_z ( long birth_year ) { return ! (( birth_year >= 1995 ) && ( birth_year <= 2005 )); }","title":"Logical Operators"},{"location":"09-logical-exp.html#short-circuiting","text":"When evaluating the logical expressions that involve && and || , C uses \"short-circuiting\". This means that, if we already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation. The corresponding true and false value will be returned. Consider the following: bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } If the argument birth_year is 1970 , then, the expression (birth_year >= 1995) already evaluates to false , and the whole statement is false. We do not need to evaluate the second expression (birth_year <= 2005) . Similarly, for bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } When birth_year is 1970 , the expression (birth_year < 1995) is true , so we know that the whole statement is true . There is no need to check if (birth_year > 2005) . In both examples above, the savings due to short-circuiting is not much -- since we are basically comparing two numbers, and there is no side effects in comparing birth_year to 2005 . But, let's suppose that we introduce two functions with side effects (of printing to screen): bool not_too_old ( long birth_year ) { if ( birth_year >= 1995 ) { cs1010_print_string ( \"not too old..\" ); return true ; } cs1010_print_string ( \"too old..\" ); return false ; } bool not_too_young ( long birth_year ) { if ( birth_year <= 2005 ) { cs1010_print_string ( \"not too young..\" ); return true ; } cs1010_print_string ( \"too young..\" ); return false ; } bool is_gen_z ( long birth_year ) { return not_too_old ( birth_year ) && not_too_young ( birth_year ); } When we call is_gen_z(1984) , you might expect too old..not too young.. to be printed, but due to short-circuiting, the code only prints too old.. . Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression. Take the following example: if ( number < 100000 && is_prime ( number )) { : } Checking whether a number is below 100,000 is easier than checking if a number is prime. So, we can skip checking for primality if the number is too big. Compare this to: if ( is_prime ( number ) && number < 100000 ) { : } Suppose number is a gigantic integer, then we would have spent lots of effort checking if number is a prime, only to find out that it is too big anyway!","title":"Short Circuiting"},{"location":"09-logical-exp.html#problem-sets","text":"","title":"Problem Sets"},{"location":"09-logical-exp.html#problem-91","text":"Given two bool variables, a and b , there are four possible combinations of true false values. What are the values of a && b , a || b , and !a for each of these combinations? Fill in the table below. a b a && b a || b !a true true true false false true false false","title":"Problem 9.1"},{"location":"09-logical-exp.html#problem-92","text":"Consider the function below, which aims to return the maximum value given three numbers. long max_of_three ( long a , long b , long c ) { long max = 0 ; if (( a > b ) && ( a > c )) { // a is larger than b and c max = a ; } if (( b > a ) && ( b > c )) { // b is larger than a and c max = b ; } if (( c > a ) && ( c > b )) { // c is larger than a and b max = c ; } return max ; } (a) What is wrong with the code above? (b) Give a sample test value of a , b , and c that would expose the bug. (C) Fix the code above to remove the bug. (d) Replace the three if statements in the code above with if - else statements. Draw the corresponding flowchart.","title":"Problem 9.2"},{"location":"09-logical-exp.html#problem-93","text":"Write a function that takes in a blood pressure measurement, and prints either low , ideal , pre-high , and high depending on the input values. The blood pressure is given as two long values, the systolic and the diastolic. The text to be printed depends on the range, depicted in the figure below. void print_blood_pressure ( long systolic , long diastolic ) { : } The figure does not say how to classify the data if the values fall exactly on the boundary of two regions. In this case, you can classify it to either region.","title":"Problem 9.3"},{"location":"09-logical-exp.html#appendix-code-from-lecture","text":"#include \"cs1010.h\" #include <stdbool.h> bool is_gen_z ( long year ) { return (( year >= 1995 ) && ( year <= 2005 )); } bool is_not_gen_z ( long year ) { return (( year < 1995 ) || ( year > 2005 )); } int main () { long year = cs1010_read_long (); if ( is_gen_z ( year )) { cs1010_println_string ( \"Z!\" ); } else { cs1010_println_string ( \"Not Z!\" ); } }","title":"Appendix: Code from Lecture"},{"location":"10-assert.html","text":"Unit 10: Assertion An assertion is a logical expression that must always be true for the program to be correct. We can write assertions either as part of the comment for the code, or use the assert() macro in C. Let's look at what is assertion first. We will introduce the use of assert() later. To get started, let's first look at the most trivial assertion: long x = 1 ; // { x == 1 } The line above initialize the variable x to be 1 . The next line, a comment, uses the curly braces { and } with a logical expression in between, to indicate that x must be equals to 1 after the assignment. We use the curly braces as a notation in CS1010, following C. A. R. Hoare 's notation, but this is not part of any C standard. The assertion above is kind of trivial and not very meaningful. Let's revisit this snippet: if ( x > y ) { max = x ; } else { max = y ; } Let's consider the true block and the false block. Inside the true block, since x > y , we can assert that, well, x > y , and inside the false block, we have the negation, so x <= y . if ( x > y ) { // { x > y } max = x ; } else { // { x <= y } max = y ; } Let's now consider what happens after initializing max to either x or y . if ( x > y ) { // { x > y } max = x ; // { max == x && max > y } } else { // { x <= y } max = y ; // { max >= x && max == y } } The assertion on Line 4 consists of two parts: max == x which is the result of the assignment (the trivial assertion), but since inside this block, x > y , we must have max > y to be true as well. Similarly, we can argue the assertion in Line 8 to be true. What can we assert after we exit from the if - else block? We have either max == x && max > y or max >= x && max == y . This is exactly the property we are looking for in max when we set it to the maximum of x and y ! Let's look at another example: if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } Let's focus on the case of printing C . We should print C if score is less than 5 but is 3 or higher. Let's check if this is correct by finding out what we can assert wrt score just before printing C . We first add the assert condition to all the true blocks and the false block by negating the if condition. if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { // { score >= 5 } cs1010_println_string ( \"B\" ); } else { // { score < 5 } if ( score >= 3 ) { // { score < 5 && score >= 3 } cs1010_println_string ( \"C\" ); } else { // { score < 5 && score < 3 } cs1010_println_string ( \"D\" ); } } } We can see that, we are printing C when score < 5 && score >= 3 , which is what we want. Note that the last assert score < 5 && score < 3 can be simplified to score < 3 . De Morgan's Law To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression. Suppose we have two logical expressions e1 and e2 . !(e1 && e2) is the same as (!e1) || (!e2) !(e1 || e2) is the same as (!e1) && (!e2) We have actually seen it in action. Recall the expression for Generation Z: (birth_year >= 1995) && (birth_year <= 2005) . To check for NOT Generation Z, we can write it as !((birth_year >= 1995) && (birth_year <= 2005)) , which according to De Morgan's law, is the same as !(birth_year >= 1995) || !(birth_year <= 2005) , which is just (birth_year < 1995) || (birth_year > 2005) , exactly as we have written before! Problem Set 10 Problem 10.1 Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression. Assume all variable names mentioned are boolean variables. (a) (x > 1) && (y != 10) (b) !eating && drinking (C) (has_cs2030 || has_cs2113) && has_cs2040c Problem 10.2 In the code below, replace ??? with the appropriate assertion. What will be printed? long score = 4 ; if ( something ) { score = 10 ; } else { score = 0 ; } // { ??? } if ( score == 4 ) { score = 1 ; } else { score += 10 ; } // { ??? } if ( score >= 10 ) { cs1010_println_string ( \"ok\" ); } else { cs1010_println_string ( \"failed\" ); }","title":"10. Assertion"},{"location":"10-assert.html#unit-10-assertion","text":"An assertion is a logical expression that must always be true for the program to be correct. We can write assertions either as part of the comment for the code, or use the assert() macro in C. Let's look at what is assertion first. We will introduce the use of assert() later. To get started, let's first look at the most trivial assertion: long x = 1 ; // { x == 1 } The line above initialize the variable x to be 1 . The next line, a comment, uses the curly braces { and } with a logical expression in between, to indicate that x must be equals to 1 after the assignment. We use the curly braces as a notation in CS1010, following C. A. R. Hoare 's notation, but this is not part of any C standard. The assertion above is kind of trivial and not very meaningful. Let's revisit this snippet: if ( x > y ) { max = x ; } else { max = y ; } Let's consider the true block and the false block. Inside the true block, since x > y , we can assert that, well, x > y , and inside the false block, we have the negation, so x <= y . if ( x > y ) { // { x > y } max = x ; } else { // { x <= y } max = y ; } Let's now consider what happens after initializing max to either x or y . if ( x > y ) { // { x > y } max = x ; // { max == x && max > y } } else { // { x <= y } max = y ; // { max >= x && max == y } } The assertion on Line 4 consists of two parts: max == x which is the result of the assignment (the trivial assertion), but since inside this block, x > y , we must have max > y to be true as well. Similarly, we can argue the assertion in Line 8 to be true. What can we assert after we exit from the if - else block? We have either max == x && max > y or max >= x && max == y . This is exactly the property we are looking for in max when we set it to the maximum of x and y ! Let's look at another example: if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } Let's focus on the case of printing C . We should print C if score is less than 5 but is 3 or higher. Let's check if this is correct by finding out what we can assert wrt score just before printing C . We first add the assert condition to all the true blocks and the false block by negating the if condition. if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { // { score >= 5 } cs1010_println_string ( \"B\" ); } else { // { score < 5 } if ( score >= 3 ) { // { score < 5 && score >= 3 } cs1010_println_string ( \"C\" ); } else { // { score < 5 && score < 3 } cs1010_println_string ( \"D\" ); } } } We can see that, we are printing C when score < 5 && score >= 3 , which is what we want. Note that the last assert score < 5 && score < 3 can be simplified to score < 3 .","title":"Unit 10: Assertion"},{"location":"10-assert.html#de-morgans-law","text":"To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression. Suppose we have two logical expressions e1 and e2 . !(e1 && e2) is the same as (!e1) || (!e2) !(e1 || e2) is the same as (!e1) && (!e2) We have actually seen it in action. Recall the expression for Generation Z: (birth_year >= 1995) && (birth_year <= 2005) . To check for NOT Generation Z, we can write it as !((birth_year >= 1995) && (birth_year <= 2005)) , which according to De Morgan's law, is the same as !(birth_year >= 1995) || !(birth_year <= 2005) , which is just (birth_year < 1995) || (birth_year > 2005) , exactly as we have written before!","title":"De Morgan's Law"},{"location":"10-assert.html#problem-set-10","text":"","title":"Problem Set 10"},{"location":"10-assert.html#problem-101","text":"Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression. Assume all variable names mentioned are boolean variables. (a) (x > 1) && (y != 10) (b) !eating && drinking (C) (has_cs2030 || has_cs2113) && has_cs2040c","title":"Problem 10.1"},{"location":"10-assert.html#problem-102","text":"In the code below, replace ??? with the appropriate assertion. What will be printed? long score = 4 ; if ( something ) { score = 10 ; } else { score = 0 ; } // { ??? } if ( score == 4 ) { score = 1 ; } else { score += 10 ; } // { ??? } if ( score >= 10 ) { cs1010_println_string ( \"ok\" ); } else { cs1010_println_string ( \"failed\" ); }","title":"Problem 10.2"},{"location":"11-loop.html","text":"Unit 11: Loops In Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the if - else statements, using a logical expression to decide which path to take. Sometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met. You have seen this construct in the max max and sum sum example, where we repeatedly go through the numbers in the list until i == k i == k . Writing Loops To write a loop, we need to think about the following four questions: what do we want to do repeatedly? what do we need to set up before repeating the above? what changes from one repetition to another? how to decide if we should stop repeating (or conversely, to continue repeating?) There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to Unit 12 . Let's revisit the example of max . Here is the answer to the questions: What do we want to do repeatedly? We want to compare the element l_i l_i to m m , and update m m to l_i l_i if l_i > m l_i > m . What do we need to set up before repeating the above? We need to have some initial value of m m and i i . We set it up as m = l_0 m = l_0 and i = 1 i = 1 . What would be different each time we repeat the above? Every time we repeat, i i will be different. To be more precise, i i is one more than before. How to decide if we should continue repeating the above? We stop when there is no more element to compare, i.e., i i equals k k . In other words, we continue if i < k i < k . Let's consider another example. We have seen how to compute factorial recursively. Let's try to compute factorial using a loop. Recall that n! = n \\times n-1 \\times n-2 .. 2 \\times 1 n! = n \\times n-1 \\times n-2 .. 2 \\times 1 . Given n n , how do we find n! n! using a loop? The idea to solve this with a loop is to start with the value n n , and repeatedly multiply another value i i , starting with i = n - 1 i = n - 1 , then i = n - 2 i = n - 2 , etc, until i = 2 i = 2 . We do not need to multiple with i = 1 i = 1 since it does not change the value. Like any other problem, we need to consider what are the variables we need to maintain. In this case, we should maintain the partial product of the factorial and a variable i i that corresponds to value to multiple into the partial product. What do we want to do repeatedly? Multiply i i into the partial product. What do we need to set up before repeating the above? We set up the partial product to be n n and i i to be n - 1 n - 1 . What changes from one repetition to another? i i would decrease by one every time we repeat the above. How to decide if we should stop repeating (or conversely, to continue repeating?) We can stop when we have multiplied i = 2 i = 2 to the partial product. We can express the algorithm above using the following flowchart: A for loop C provides three ways to write a loop. Let's start with a simple one first, a for loop. The for loop in C has the following syntax: for ( < initialize > ; < condition > ; < update > ) { < body > } There are four components, corresponding to the four questions above: The initialize statement set up the loop (i.e., \"What do we need to set up before repeating the above?\"). The condition statement indicates when we should stop repeating. If it evaluates to true , it will cause the loop to continue, otherwise, the loop stops. The update statement is executed after every loop. (i.e., \"What changes from one repetition to another?\") The body statement is the action that we want to do repeatedly. For the initialize and update statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand. C also allows us to have empty statements for initialize , condition and/or update . As such, in CS1010, we will stick to performing one initialization and one update only. For example, in the setup phase for factorial, we should initialize the partial product to n n and i i to n - 1 n - 1 , that's two assignments. We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize i i in the initialize statement of the for loop, and leave the initialization of product to a separate assignment before the for loop. Here is the example for computing the factorial: long factorial ( long n ) { long product = n ; for ( long i = n - 1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; } The code above is almost correct. We only need to handle the special case when n is 0. The complete code for the function is thus: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; for ( long i = n - 1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; } while Loop The second way to write a loop in C is to use a while loop. The while loop looks like this: while ( < condition > ) { < body > } The statements in <body> will be executed if <condition> is true. Note that the syntax of the while loop above does not contain the <initialize> and the <update> component. When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows: < initialize > while ( < condition > ) { < body > < update > } The corresponding flowchart for while is: Compare the flowchart for while to the flowchart for for earlier. You will see that they are exactly the same! Here is the while version of the factorial function: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i >= 2 ) { product *= i ; i -= 1 ; } return product ; } In the while loop, however, we can be more flexible in terms of what we want to do inside the loop. Technically, there is no difference between update and body since they are just a bunch of C statements. We can interleave <update> and <body> or execute <update> first before <body> , depending on the algorithm. With for loop, there is no such flexibility as <update> has to be executed after <body> . A do-while loop The third way we can write a loop in C is to use a do-while loop. The do-while loop is very similar to while , except that the body of the loop is guaranteed to be executed at least once. < initialize > do { < body > < update > } while ( < condition > ); Similar to the while loop, the <body> component and <update> component in the loop does not have to be in order. There is a semicolor ; after a do-while loop. Let's look at an example where using do-while is more natural than while . Example: Guess a Number Let's write a program that plays a game with the user. The program generates a random integer number between 1 and 100. The user will guess what that number is. If the user guesses correctly, the program congratulates the user. Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again. This process repeats until the guess is correct. Note that, here, the user needs to guess at least once, so it is more natural to use a do - while loop than a while or a for . Answering The Four Questions What do we want to do repeatedly? We want to read the guess from the user and respond back to the user. What do we need to set up before repeating the above? We need to generate a random integer between 1 and 100. What changes from one repetition to another? The guess may be different. How to decide if we should continue repeating the above? We stop when the guess is correct. Designing the Flowchart Here is the flowchart of the steps described above. The C code The entire corresponding program is shown below: #include <stdlib.h> #include <sys/times.h> #include \"cs1010.h\" int main () { // Initialize the random number generator srandom ( times ( 0 )); // Generate a random number between 1 and 100 long answer = ( random () % 100 ) + 1 ; long guess ; do { // Read guess and feedback to user guess = cs1010_read_long (); if ( guess > answer ) { cs1010_println_string ( \"too high\" ); } else if ( guess < answer ) { cs1010_println_string ( \"too low\" ); } } while ( guess != answer ); // { guess == answer } cs1010_println_string ( \"you got it. congrats!\" ); } I will not go into details of what srandom(times(0)) means. You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure). The function random() generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100. We then add 1 to it to a number between 1 and 100, inclusive. Problem Set Problem 11.1 Here is another version of the factorial function: long factorial ( long n ) { long i = n - 1 ; long product ; for ( product = n ; i >= 2 ; product *= i ) { i -= 1 ; } return product ; } Does this code runs correctly? If it is incorrect, explain what is wrong and suggest a fix. (Hint: translate this to the corresponding flowchart and trace through the flowchart). Problem 11.2 (a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered. (b) Rewrite the \"Guess A Number\" program with a while loop. (C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds. (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.) (d) What is the optimal strategy to play the game? Problem 11.3 Trace the following algorithms: long mystery ( long n , long k ) { long something = n ; long count = - 1 ; while ( something >= 1 ) { something /= k ; count += 1 ; } return count ; } (a) What is the return value when n is 8 and k is 2? n is 81 and k is 3? n is 100 and k is 5? Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later). (b) What is the mathematical expression that our mystery function here is trying to compute based on the examples above? (C) Give a pair of inputs that would cause the function to return the wrong answer. (d) Give a pair of inputs that would cause the function to loop forever.","title":"11. Loops"},{"location":"11-loop.html#unit-11-loops","text":"In Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the if - else statements, using a logical expression to decide which path to take. Sometimes, we want to execute one of the branches repeatedly (or interatively), over-and-over again, until a certain logical condition is met. You have seen this construct in the max max and sum sum example, where we repeatedly go through the numbers in the list until i == k i == k .","title":"Unit 11: Loops"},{"location":"11-loop.html#writing-loops","text":"To write a loop, we need to think about the following four questions: what do we want to do repeatedly? what do we need to set up before repeating the above? what changes from one repetition to another? how to decide if we should stop repeating (or conversely, to continue repeating?) There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to Unit 12 . Let's revisit the example of max . Here is the answer to the questions: What do we want to do repeatedly? We want to compare the element l_i l_i to m m , and update m m to l_i l_i if l_i > m l_i > m . What do we need to set up before repeating the above? We need to have some initial value of m m and i i . We set it up as m = l_0 m = l_0 and i = 1 i = 1 . What would be different each time we repeat the above? Every time we repeat, i i will be different. To be more precise, i i is one more than before. How to decide if we should continue repeating the above? We stop when there is no more element to compare, i.e., i i equals k k . In other words, we continue if i < k i < k . Let's consider another example. We have seen how to compute factorial recursively. Let's try to compute factorial using a loop. Recall that n! = n \\times n-1 \\times n-2 .. 2 \\times 1 n! = n \\times n-1 \\times n-2 .. 2 \\times 1 . Given n n , how do we find n! n! using a loop? The idea to solve this with a loop is to start with the value n n , and repeatedly multiply another value i i , starting with i = n - 1 i = n - 1 , then i = n - 2 i = n - 2 , etc, until i = 2 i = 2 . We do not need to multiple with i = 1 i = 1 since it does not change the value. Like any other problem, we need to consider what are the variables we need to maintain. In this case, we should maintain the partial product of the factorial and a variable i i that corresponds to value to multiple into the partial product. What do we want to do repeatedly? Multiply i i into the partial product. What do we need to set up before repeating the above? We set up the partial product to be n n and i i to be n - 1 n - 1 . What changes from one repetition to another? i i would decrease by one every time we repeat the above. How to decide if we should stop repeating (or conversely, to continue repeating?) We can stop when we have multiplied i = 2 i = 2 to the partial product. We can express the algorithm above using the following flowchart:","title":"Writing Loops"},{"location":"11-loop.html#a-for-loop","text":"C provides three ways to write a loop. Let's start with a simple one first, a for loop. The for loop in C has the following syntax: for ( < initialize > ; < condition > ; < update > ) { < body > } There are four components, corresponding to the four questions above: The initialize statement set up the loop (i.e., \"What do we need to set up before repeating the above?\"). The condition statement indicates when we should stop repeating. If it evaluates to true , it will cause the loop to continue, otherwise, the loop stops. The update statement is executed after every loop. (i.e., \"What changes from one repetition to another?\") The body statement is the action that we want to do repeatedly. For the initialize and update statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand. C also allows us to have empty statements for initialize , condition and/or update . As such, in CS1010, we will stick to performing one initialization and one update only. For example, in the setup phase for factorial, we should initialize the partial product to n n and i i to n - 1 n - 1 , that's two assignments. We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize i i in the initialize statement of the for loop, and leave the initialization of product to a separate assignment before the for loop. Here is the example for computing the factorial: long factorial ( long n ) { long product = n ; for ( long i = n - 1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; } The code above is almost correct. We only need to handle the special case when n is 0. The complete code for the function is thus: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; for ( long i = n - 1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; }","title":"A for loop"},{"location":"11-loop.html#while-loop","text":"The second way to write a loop in C is to use a while loop. The while loop looks like this: while ( < condition > ) { < body > } The statements in <body> will be executed if <condition> is true. Note that the syntax of the while loop above does not contain the <initialize> and the <update> component. When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows: < initialize > while ( < condition > ) { < body > < update > } The corresponding flowchart for while is: Compare the flowchart for while to the flowchart for for earlier. You will see that they are exactly the same! Here is the while version of the factorial function: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i >= 2 ) { product *= i ; i -= 1 ; } return product ; } In the while loop, however, we can be more flexible in terms of what we want to do inside the loop. Technically, there is no difference between update and body since they are just a bunch of C statements. We can interleave <update> and <body> or execute <update> first before <body> , depending on the algorithm. With for loop, there is no such flexibility as <update> has to be executed after <body> .","title":"while Loop"},{"location":"11-loop.html#a-do-while-loop","text":"The third way we can write a loop in C is to use a do-while loop. The do-while loop is very similar to while , except that the body of the loop is guaranteed to be executed at least once. < initialize > do { < body > < update > } while ( < condition > ); Similar to the while loop, the <body> component and <update> component in the loop does not have to be in order. There is a semicolor ; after a do-while loop. Let's look at an example where using do-while is more natural than while .","title":"A do-while loop"},{"location":"11-loop.html#example-guess-a-number","text":"Let's write a program that plays a game with the user. The program generates a random integer number between 1 and 100. The user will guess what that number is. If the user guesses correctly, the program congratulates the user. Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again. This process repeats until the guess is correct. Note that, here, the user needs to guess at least once, so it is more natural to use a do - while loop than a while or a for .","title":"Example: Guess a Number"},{"location":"11-loop.html#answering-the-four-questions","text":"What do we want to do repeatedly? We want to read the guess from the user and respond back to the user. What do we need to set up before repeating the above? We need to generate a random integer between 1 and 100. What changes from one repetition to another? The guess may be different. How to decide if we should continue repeating the above? We stop when the guess is correct.","title":"Answering The Four Questions"},{"location":"11-loop.html#designing-the-flowchart","text":"Here is the flowchart of the steps described above.","title":"Designing the Flowchart"},{"location":"11-loop.html#the-c-code","text":"The entire corresponding program is shown below: #include <stdlib.h> #include <sys/times.h> #include \"cs1010.h\" int main () { // Initialize the random number generator srandom ( times ( 0 )); // Generate a random number between 1 and 100 long answer = ( random () % 100 ) + 1 ; long guess ; do { // Read guess and feedback to user guess = cs1010_read_long (); if ( guess > answer ) { cs1010_println_string ( \"too high\" ); } else if ( guess < answer ) { cs1010_println_string ( \"too low\" ); } } while ( guess != answer ); // { guess == answer } cs1010_println_string ( \"you got it. congrats!\" ); } I will not go into details of what srandom(times(0)) means. You can look it up on your own if you are interested (InfoSec students may want to do this as generating good random number is key to keeping systems secure). The function random() generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100. We then add 1 to it to a number between 1 and 100, inclusive.","title":"The C code"},{"location":"11-loop.html#problem-set","text":"","title":"Problem Set"},{"location":"11-loop.html#problem-111","text":"Here is another version of the factorial function: long factorial ( long n ) { long i = n - 1 ; long product ; for ( product = n ; i >= 2 ; product *= i ) { i -= 1 ; } return product ; } Does this code runs correctly? If it is incorrect, explain what is wrong and suggest a fix. (Hint: translate this to the corresponding flowchart and trace through the flowchart).","title":"Problem 11.1"},{"location":"11-loop.html#problem-112","text":"(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered. (b) Rewrite the \"Guess A Number\" program with a while loop. (C) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds. (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.) (d) What is the optimal strategy to play the game?","title":"Problem 11.2"},{"location":"11-loop.html#problem-113","text":"Trace the following algorithms: long mystery ( long n , long k ) { long something = n ; long count = - 1 ; while ( something >= 1 ) { something /= k ; count += 1 ; } return count ; } (a) What is the return value when n is 8 and k is 2? n is 81 and k is 3? n is 100 and k is 5? Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later). (b) What is the mathematical expression that our mystery function here is trying to compute based on the examples above? (C) Give a pair of inputs that would cause the function to return the wrong answer. (d) Give a pair of inputs that would cause the function to loop forever.","title":"Problem 11.3"},{"location":"12-invariant.html","text":"Unit 12: Reasoning About Loops Using Assertions We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional if - else statements. We can apply the same techniques to loops. Take the simple program below: long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // line A x -= 1 ; // line B if ( x % 5 == 0 ) { // line C y += 1 ; } } // line D return y ; } Before we continue, study this program and try to analyze what the function is counting and returning. To do this more systematically, we can use assertions. Let's ask ourselves: what can be said about the variables x and y at Lines A, B, C? Let starts with x first. Line A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times), x > 0 and x <= n (since we initialize the x to n ). At Line B, we decrease x by 1, so x >= 0 && x < n must be true. At Line C, x % 5 == 0 (i.e., x is multiple of 5) must also be true (since it is in the true block of the if block). At Line D, we already exit from the loop, and the only way to exit here is that x > 0 is false. So we know that x <= 0 . Let's annotate the code with the assertions: long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // { x > 0 && x <= n } x -= 1 ; // { (x >= 0) && (x < n) } if ( x % 5 == 0 ) { // { (x >= 0) && (x < n) && x is multiple of 5 } y += 1 ; } } // { x <= 0 } return y ; } What can be said about y ? It should be clear now that we increment y for every value between 0 and n-1 (inclusive) that is a multiple of 5, based on the condition on Line C. That is, it is counting the number of multiple of 5s between 0 and n-1. Loop Invariant In the last unit, we say that there are actually five questions that we have to think about when designing loops. The fifth question is: what is the loop invariant ? A loop invariant is an assertion that is true before the loop, during the loop, and after the loop. Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop. Let's see an example of a loop invariant. Consider the example of calculating a factorial using a loop as before. To make the invariant simpler, let's tweak the loop slightly and start looping from i equals 1 up to n . long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // Line A while ( i < n ) { i += 1 ; product *= i ; // Line B } // Line C return product ; } The loop invariant for each line A, B, and C are the same: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // A: { product == i! } while ( i < n ) { i += 1 ; product *= i ; // B: { product == i! } } // C: { product == i! } return product ; } In Line A, the assertion is obvious. Let's look at Line B. Since, at the beginning of the loop (before Line 10) we have product == i! , after Line 10, we have product == (i-1)! (since we have incremented i ). After Line 11, we have product == i * (i - 1)! == i! again. The assertion remains true once we exit the loop. The key here is that after we exit the loop, we can also assert that i == n , and so combining product == i! && i == n we have product == n! , which is what we want. Problem Set 12 Problem 12.1 long i = 10 ; long j = 0 ; while ( i != 0 ) { i -= 1 ; j += 1 ; } (a) Trace through the program. What is the value of j when the loop exits? (b) Do you recognize any pattern on the relationship of i and j ? (C) What is the loop invariant?","title":"12. Reasoning About Loops"},{"location":"12-invariant.html#unit-12-reasoning-about-loops","text":"","title":"Unit 12: Reasoning About Loops"},{"location":"12-invariant.html#using-assertions","text":"We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional if - else statements. We can apply the same techniques to loops. Take the simple program below: long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // line A x -= 1 ; // line B if ( x % 5 == 0 ) { // line C y += 1 ; } } // line D return y ; } Before we continue, study this program and try to analyze what the function is counting and returning. To do this more systematically, we can use assertions. Let's ask ourselves: what can be said about the variables x and y at Lines A, B, C? Let starts with x first. Line A is the first line after entering the loop, so we can reason that to enter the loop (the first time or subsequent times), x > 0 and x <= n (since we initialize the x to n ). At Line B, we decrease x by 1, so x >= 0 && x < n must be true. At Line C, x % 5 == 0 (i.e., x is multiple of 5) must also be true (since it is in the true block of the if block). At Line D, we already exit from the loop, and the only way to exit here is that x > 0 is false. So we know that x <= 0 . Let's annotate the code with the assertions: long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // { x > 0 && x <= n } x -= 1 ; // { (x >= 0) && (x < n) } if ( x % 5 == 0 ) { // { (x >= 0) && (x < n) && x is multiple of 5 } y += 1 ; } } // { x <= 0 } return y ; } What can be said about y ? It should be clear now that we increment y for every value between 0 and n-1 (inclusive) that is a multiple of 5, based on the condition on Line C. That is, it is counting the number of multiple of 5s between 0 and n-1.","title":"Using Assertions"},{"location":"12-invariant.html#loop-invariant","text":"In the last unit, we say that there are actually five questions that we have to think about when designing loops. The fifth question is: what is the loop invariant ? A loop invariant is an assertion that is true before the loop, during the loop, and after the loop. Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop. Let's see an example of a loop invariant. Consider the example of calculating a factorial using a loop as before. To make the invariant simpler, let's tweak the loop slightly and start looping from i equals 1 up to n . long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // Line A while ( i < n ) { i += 1 ; product *= i ; // Line B } // Line C return product ; } The loop invariant for each line A, B, and C are the same: long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // A: { product == i! } while ( i < n ) { i += 1 ; product *= i ; // B: { product == i! } } // C: { product == i! } return product ; } In Line A, the assertion is obvious. Let's look at Line B. Since, at the beginning of the loop (before Line 10) we have product == i! , after Line 10, we have product == (i-1)! (since we have incremented i ). After Line 11, we have product == i * (i - 1)! == i! again. The assertion remains true once we exit the loop. The key here is that after we exit the loop, we can also assert that i == n , and so combining product == i! && i == n we have product == n! , which is what we want.","title":"Loop Invariant"},{"location":"12-invariant.html#problem-set-12","text":"","title":"Problem Set 12"},{"location":"12-invariant.html#problem-121","text":"long i = 10 ; long j = 0 ; while ( i != 0 ) { i -= 1 ; j += 1 ; } (a) Trace through the program. What is the value of j when the loop exits? (b) Do you recognize any pattern on the relationship of i and j ? (C) What is the loop invariant?","title":"Problem 12.1"},{"location":"13-call-stack.html","text":"Unit 13: Call Stack In this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function. Stack Frame Modern OS typically divide the memory into several regions. The region that we are concerned with for now is called the call stack . Every function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function. The memory allocated to each function call is called a stack frame . When a function returns, the stack frame is deallocated and freed up for other uses. Let's start with the following simple program as an example. int main () { long x = 1 ; long y ; } When the OS runs the program above, it invokes, or calls, the function main . A new stack frame is created for main() . There are two variables x and y declared in main . Recall from Unit 2 that a variable is a location in the memory which holds a value. Thus, the stack frame of main will include these two variables. We initialize x to 1 in the code above, so the value 1 will be placed in the memory location of x . The variable y remains uninitialized, so it will contain whatever value that happens to be in the memory at that time. Now, let's consider the program 1 : long add ( long a , long b ) { long sum ; sum = a + b ; return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } Now, the program invokes the function add with two parameters, using x and 10 as arguments. What the OS does when add is called, is that it allocates another stack frame for add . We can visualize the stack frame for add as being placed on top of the stack frame of main . The stack frame for add includes two variables corresponding to the parameters a , b , and the variable sum declared in the function add . When the stack frame for add is created, sum is uninitialized, but a is initialized to whatever the value of x is when the function is invoked (1 in this example), and b is initialized to 10, since that is the argument passed into add . After the stack frame for add is set up, the code is executed. The memory location for sum is then initialized to the sum of a and b (11 in this example), and the return statement is executed. When a function returns, the stack frame for sum is removed. The variables sum , a , b crumble into dust and no longer exist in the memory. The value of the variable being returned ( sum in this case) is then copied back to the stack frame of the main (the callee caller). In this example, this value is copied into the memory location of y . What would happen if we change the value of a within add ? long add ( long a , long b ) { sum = a + b ; a = 42 ; // change a return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } In this example, we change the value of a in the call stack of add to 42. This has no effect on any variable in main , since the changes apply only within the stack frame of add . A common bug by beginners is to try to write a function this way: void add ( long sum , long a , long b ) { sum = a + b ; } int main () { long x = 1 ; long sum ; add ( sum , x , 10 ); } Here, there are actually two versions of sum , one in the stack frame of main , the other in the stack frame of add . When we change sum in add , we are changing a local copy which will eventually get deleted. The assignment to sum in Line 2 has no effect on the variable sum on Line 8 of main . This explanation explains why a function is a black box, we can only pass in parameters and get a value in return. Nothing else gets in and out. There are no \"side effects\" -- whatever happen in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output). Such a function is sometimes called a \"pure function\". Automatic Variable Because of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables automatic variables . There are two other types of variables, global variable , which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and static variable , which could be useful in rare occasion but we shouldn't concern ourselves with this type of variable in CS1010 for the moment. Stack Size The OS typically reserves a limited amount of memory for each program for the stack. You can find out, on your system, what is the maximum allocated stack size with the command ulimit -s On our CS1010 PE hosts, the limit is 8 MB. Problem Set 13 Problem 13.1 Trace through what gets stored in the call stack when we run the following programs: #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } Problem 13.2 Trace through what gets stored in the call stack when we run the following programs: #include \"cs1010.h\" long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return factorial ( n - 1 ) * n ; } int main () { factorial ( 3 ); } Problem 13.3 What will be printed by the program below? Trace through what gets stored in the call stack when we run the following programs: #include \"cs1010.h\" void incr ( long x ) { x += 1 ; } int main () { long x = 10 ; incr ( x ); incr ( x ); cs1010_print_long ( x ); } The variable sum is not necessary and the function can be better written as a one-liner return a + b; . But I introduce the additional variable sum here to make the example more meaningful in explaining about stack frame. \u21a9","title":"13. Call Stack"},{"location":"13-call-stack.html#unit-13-call-stack","text":"In this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function.","title":"Unit 13: Call Stack"},{"location":"13-call-stack.html#stack-frame","text":"Modern OS typically divide the memory into several regions. The region that we are concerned with for now is called the call stack . Every function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function. The memory allocated to each function call is called a stack frame . When a function returns, the stack frame is deallocated and freed up for other uses. Let's start with the following simple program as an example. int main () { long x = 1 ; long y ; } When the OS runs the program above, it invokes, or calls, the function main . A new stack frame is created for main() . There are two variables x and y declared in main . Recall from Unit 2 that a variable is a location in the memory which holds a value. Thus, the stack frame of main will include these two variables. We initialize x to 1 in the code above, so the value 1 will be placed in the memory location of x . The variable y remains uninitialized, so it will contain whatever value that happens to be in the memory at that time. Now, let's consider the program 1 : long add ( long a , long b ) { long sum ; sum = a + b ; return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } Now, the program invokes the function add with two parameters, using x and 10 as arguments. What the OS does when add is called, is that it allocates another stack frame for add . We can visualize the stack frame for add as being placed on top of the stack frame of main . The stack frame for add includes two variables corresponding to the parameters a , b , and the variable sum declared in the function add . When the stack frame for add is created, sum is uninitialized, but a is initialized to whatever the value of x is when the function is invoked (1 in this example), and b is initialized to 10, since that is the argument passed into add . After the stack frame for add is set up, the code is executed. The memory location for sum is then initialized to the sum of a and b (11 in this example), and the return statement is executed. When a function returns, the stack frame for sum is removed. The variables sum , a , b crumble into dust and no longer exist in the memory. The value of the variable being returned ( sum in this case) is then copied back to the stack frame of the main (the callee caller). In this example, this value is copied into the memory location of y . What would happen if we change the value of a within add ? long add ( long a , long b ) { sum = a + b ; a = 42 ; // change a return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } In this example, we change the value of a in the call stack of add to 42. This has no effect on any variable in main , since the changes apply only within the stack frame of add . A common bug by beginners is to try to write a function this way: void add ( long sum , long a , long b ) { sum = a + b ; } int main () { long x = 1 ; long sum ; add ( sum , x , 10 ); } Here, there are actually two versions of sum , one in the stack frame of main , the other in the stack frame of add . When we change sum in add , we are changing a local copy which will eventually get deleted. The assignment to sum in Line 2 has no effect on the variable sum on Line 8 of main . This explanation explains why a function is a black box, we can only pass in parameters and get a value in return. Nothing else gets in and out. There are no \"side effects\" -- whatever happen in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output). Such a function is sometimes called a \"pure function\".","title":"Stack Frame"},{"location":"13-call-stack.html#automatic-variable","text":"Because of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables automatic variables . There are two other types of variables, global variable , which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and static variable , which could be useful in rare occasion but we shouldn't concern ourselves with this type of variable in CS1010 for the moment.","title":"Automatic Variable"},{"location":"13-call-stack.html#stack-size","text":"The OS typically reserves a limited amount of memory for each program for the stack. You can find out, on your system, what is the maximum allocated stack size with the command ulimit -s On our CS1010 PE hosts, the limit is 8 MB.","title":"Stack Size"},{"location":"13-call-stack.html#problem-set-13","text":"","title":"Problem Set 13"},{"location":"13-call-stack.html#problem-131","text":"Trace through what gets stored in the call stack when we run the following programs: #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); }","title":"Problem 13.1"},{"location":"13-call-stack.html#problem-132","text":"Trace through what gets stored in the call stack when we run the following programs: #include \"cs1010.h\" long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return factorial ( n - 1 ) * n ; } int main () { factorial ( 3 ); }","title":"Problem 13.2"},{"location":"13-call-stack.html#problem-133","text":"What will be printed by the program below? Trace through what gets stored in the call stack when we run the following programs: #include \"cs1010.h\" void incr ( long x ) { x += 1 ; } int main () { long x = 10 ; incr ( x ); incr ( x ); cs1010_print_long ( x ); } The variable sum is not necessary and the function can be better written as a one-liner return a + b; . But I introduce the additional variable sum here to make the example more meaningful in explaining about stack frame. \u21a9","title":"Problem 13.3"},{"location":"14-pointers.html","text":"Unit 14: Memory Addresses or Pointers Every memory location has an address. Unlike many higher level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses. This empowers programmers to do wonderful things that cannot be done in other languages. But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug. The Address-of Operator C has an operator called \"address-of\", denoted by & . This operator, returns, well, the address of a variable. We can type cast the address of a variable into long and print it out to examine its value. Consider this: #include \"cs1010.h\" void add ( long sum , long a , long b ) { sum = a + b ; cs1010_println_long (( long ) & sum ); } int main () { long x = 1 ; long sum ; add ( sum , x , 10 ); cs1010_println_long (( long ) & sum ); } Running the program above prints something like this: 140723025685528 140723025685552 Your results will most likely be different, since the OS allocates different regions of the memory to this program every time it is run. The Deference Operator The dereference operator is the reversed of address-of, and is denoted by * . I call it \"location-of-address\". We use this operator in two places: to declare an \"address\" variable, and to reference the location of an address. We can declare a variable that is an address type. We need to tell C the type of the variable this address is referencing. For instance, double * addr ; declares a variable addr that is an address to a variable of type double . The way to read this is that *addr , or location-of-address addr is of type double , so addr is an address of a location containing a double . Common Bug It is possible to write as double * addr ; too, but this is not recommended. Suppose you want to declare two addresses, you might write, double * from_addr , to_addr ; thinking that both from_addr and to_addr are of type double* . But, actually, C treats to_addr as a double , not an address of a double ! In any case, if you follow CS1010 style, you shouldn't be declaring two variables in one line. Another name for a variable of type address is pointer . We can visualize a pointer as pointing to some location in the memory. Changing the Value via Pointer Suppose we declare a pointer to a double variable (or, for short, a double pointer): double * addr ; We can use *addr just like a normal double variable: * addr = 1.0 ; The line above means that, we take the address stored in addr, go to the location at that address, and store the value 1.0 in the location. This is where things can get dangerous. You could be changing the value in a memory location that you do not mean to. If you are lucky, your program crashes with a segmentation fault error 1 . We say that your program has segfault. If you are unlucky, your program runs normally but produces incorrect output occasionally. So, always make sure that your pointer is pointing to the right location before dereferencing and writing to the location. In the code above, if we write: double * addr ; * addr = 1.0 ; back-to-back, the program will almost certainly segfault, because the pointer variable addr is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time. We should point addr to a value location first, like this: double c ; double * addr ; addr = & c ; * addr = 1.0 ; Of course, the above could be simply written as: double c = 1.0 ; I am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers. Basic Rules About Using Pointers When we use pointers, it must point to the variable of the same type as that declared by the pointer. For instance, double pi = 3.1415926 ; long radius = 5 ; double * addr ; addr = & pi ; // ok addr = & radius ; // not ok Line 4 above would lead to a compilation error since we try to point a double pointer to a long . We cannot change the address of a variable. For instance long x = 1 ; long y = 2 ; & x = & y ; We try to set the address of x to be the address of y . This is not allowed since allocation of variables in the memory is determined by the OS, a process we have no control over. We can perform arithmetic operations on pointers, but not in the way you expect. Suppose we have a pointer: long x ; long * ptr ; x = 1 ; ptr = & x ; ptr += 1 ; Suppose that x is stored in memory address 1000, after Line 4, ptr would have the value of 1000. After the line ptr += 1 , using normal arithmetic operation, we would think that ptr will have the value of 1001. However, the semantic for arithmetic operation is different for pointers. The + operation for ptr causes the ptr variable to move forward by the size of the variable pointed to by the pointer. In this example, ptr points to long , assuming that long is 8 bytes, after ptr += 1 , ptr will have the value of 1008. We can only do addition and subtraction for pointers. Pointer of Pointer (of Pointer..) A pointer variable is also stored in the memory, so it itself has an address too. long x ; long * ptr ; ptr = & x ; For instance, in the above, ptr would have a memory location allocated on the stack too, and so it itself has an address, and we can have a variable ptrptr referring to the address of ptr . What would the type of this variable be? Since ptr is an address of long , ptrptr is an address of an address of long , and can be written as: long x ; long * ptr ; long ** ptrptr ; ptr = & x ; ptrptr = & ptr ; This deference can go on since ptrptr is also a variable and have been allocated in some memory location on the stack. We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing is possible. The NULL Pointer NULL is a special value that is used to indicate that a pointer is pointing to nothing. In C, NULL is actually 0 (i.e., pointing to memory location 0). We use NULL to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition. Billion Dollar Mistakes Sir Tony Hoare (the same one whom we met when we talked about Assertion ) also invented the null pointer. He called it his billion-dollar mistake. Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\" As you start to use pointers in CS1010, you will see why it is a pain. Problem Set 14 Problem 14.1 Sketch the content of the memory while tracing through the following code. What would be printed? long * ptr1 ; long * ptr2 ; long x ; long y ; ptr1 = & x ; ptr2 = & y ; * ptr1 = 123 ; * ptr2 = - 1 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); // ptr1 = ptr1; // <-- typo in the first version of this question \ud83d\ude05 ptr1 = ptr2 ; * ptr1 = 1946 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); y = 10 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); Problem 14.2 What is wrong with both programs below? double * addr_of ( double x ) { return & x ; } int main () { double c = 0.0 ; double * ptr ; ptr = addr_of ( c ); * ptr = 10 ; } double * triple_of ( double x ) { double triple = 3 * x ; return & triple ; } int main () { double * ptr ; ptr = triple_of ( 10 ); cs1010_println_double ( * ptr ); } I leave it to the later OS classes CG2271 / CS2106 to explain the term \"segmentation\" and \"fault\". Interested students can always google and read on Wikipedia . \u21a9","title":"14. Pointers"},{"location":"14-pointers.html#unit-14-memory-addresses-or-pointers","text":"Every memory location has an address. Unlike many higher level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses. This empowers programmers to do wonderful things that cannot be done in other languages. But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug.","title":"Unit 14: Memory Addresses or Pointers"},{"location":"14-pointers.html#the-address-of-operator","text":"C has an operator called \"address-of\", denoted by & . This operator, returns, well, the address of a variable. We can type cast the address of a variable into long and print it out to examine its value. Consider this: #include \"cs1010.h\" void add ( long sum , long a , long b ) { sum = a + b ; cs1010_println_long (( long ) & sum ); } int main () { long x = 1 ; long sum ; add ( sum , x , 10 ); cs1010_println_long (( long ) & sum ); } Running the program above prints something like this: 140723025685528 140723025685552 Your results will most likely be different, since the OS allocates different regions of the memory to this program every time it is run.","title":"The Address-of Operator"},{"location":"14-pointers.html#the-deference-operator","text":"The dereference operator is the reversed of address-of, and is denoted by * . I call it \"location-of-address\". We use this operator in two places: to declare an \"address\" variable, and to reference the location of an address. We can declare a variable that is an address type. We need to tell C the type of the variable this address is referencing. For instance, double * addr ; declares a variable addr that is an address to a variable of type double . The way to read this is that *addr , or location-of-address addr is of type double , so addr is an address of a location containing a double . Common Bug It is possible to write as double * addr ; too, but this is not recommended. Suppose you want to declare two addresses, you might write, double * from_addr , to_addr ; thinking that both from_addr and to_addr are of type double* . But, actually, C treats to_addr as a double , not an address of a double ! In any case, if you follow CS1010 style, you shouldn't be declaring two variables in one line. Another name for a variable of type address is pointer . We can visualize a pointer as pointing to some location in the memory.","title":"The Deference Operator"},{"location":"14-pointers.html#changing-the-value-via-pointer","text":"Suppose we declare a pointer to a double variable (or, for short, a double pointer): double * addr ; We can use *addr just like a normal double variable: * addr = 1.0 ; The line above means that, we take the address stored in addr, go to the location at that address, and store the value 1.0 in the location. This is where things can get dangerous. You could be changing the value in a memory location that you do not mean to. If you are lucky, your program crashes with a segmentation fault error 1 . We say that your program has segfault. If you are unlucky, your program runs normally but produces incorrect output occasionally. So, always make sure that your pointer is pointing to the right location before dereferencing and writing to the location. In the code above, if we write: double * addr ; * addr = 1.0 ; back-to-back, the program will almost certainly segfault, because the pointer variable addr is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time. We should point addr to a value location first, like this: double c ; double * addr ; addr = & c ; * addr = 1.0 ; Of course, the above could be simply written as: double c = 1.0 ; I am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers.","title":"Changing the Value via Pointer"},{"location":"14-pointers.html#basic-rules-about-using-pointers","text":"When we use pointers, it must point to the variable of the same type as that declared by the pointer. For instance, double pi = 3.1415926 ; long radius = 5 ; double * addr ; addr = & pi ; // ok addr = & radius ; // not ok Line 4 above would lead to a compilation error since we try to point a double pointer to a long . We cannot change the address of a variable. For instance long x = 1 ; long y = 2 ; & x = & y ; We try to set the address of x to be the address of y . This is not allowed since allocation of variables in the memory is determined by the OS, a process we have no control over. We can perform arithmetic operations on pointers, but not in the way you expect. Suppose we have a pointer: long x ; long * ptr ; x = 1 ; ptr = & x ; ptr += 1 ; Suppose that x is stored in memory address 1000, after Line 4, ptr would have the value of 1000. After the line ptr += 1 , using normal arithmetic operation, we would think that ptr will have the value of 1001. However, the semantic for arithmetic operation is different for pointers. The + operation for ptr causes the ptr variable to move forward by the size of the variable pointed to by the pointer. In this example, ptr points to long , assuming that long is 8 bytes, after ptr += 1 , ptr will have the value of 1008. We can only do addition and subtraction for pointers.","title":"Basic Rules About Using Pointers"},{"location":"14-pointers.html#pointer-of-pointer-of-pointer","text":"A pointer variable is also stored in the memory, so it itself has an address too. long x ; long * ptr ; ptr = & x ; For instance, in the above, ptr would have a memory location allocated on the stack too, and so it itself has an address, and we can have a variable ptrptr referring to the address of ptr . What would the type of this variable be? Since ptr is an address of long , ptrptr is an address of an address of long , and can be written as: long x ; long * ptr ; long ** ptrptr ; ptr = & x ; ptrptr = & ptr ; This deference can go on since ptrptr is also a variable and have been allocated in some memory location on the stack. We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing is possible.","title":"Pointer of Pointer (of Pointer..)"},{"location":"14-pointers.html#the-null-pointer","text":"NULL is a special value that is used to indicate that a pointer is pointing to nothing. In C, NULL is actually 0 (i.e., pointing to memory location 0). We use NULL to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition. Billion Dollar Mistakes Sir Tony Hoare (the same one whom we met when we talked about Assertion ) also invented the null pointer. He called it his billion-dollar mistake. Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\" As you start to use pointers in CS1010, you will see why it is a pain.","title":"The NULL Pointer"},{"location":"14-pointers.html#problem-set-14","text":"","title":"Problem Set 14"},{"location":"14-pointers.html#problem-141","text":"Sketch the content of the memory while tracing through the following code. What would be printed? long * ptr1 ; long * ptr2 ; long x ; long y ; ptr1 = & x ; ptr2 = & y ; * ptr1 = 123 ; * ptr2 = - 1 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); // ptr1 = ptr1; // <-- typo in the first version of this question \ud83d\ude05 ptr1 = ptr2 ; * ptr1 = 1946 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); y = 10 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 );","title":"Problem 14.1"},{"location":"14-pointers.html#problem-142","text":"What is wrong with both programs below? double * addr_of ( double x ) { return & x ; } int main () { double c = 0.0 ; double * ptr ; ptr = addr_of ( c ); * ptr = 10 ; } double * triple_of ( double x ) { double triple = 3 * x ; return & triple ; } int main () { double * ptr ; ptr = triple_of ( 10 ); cs1010_println_double ( * ptr ); } I leave it to the later OS classes CG2271 / CS2106 to explain the term \"segmentation\" and \"fault\". Interested students can always google and read on Wikipedia . \u21a9","title":"Problem 14.2"},{"location":"15-array.html","text":"Unit 15: Array We now look at the first of the two compound data types in C -- arrays. A variable can be declared to be of an array, in which case it can hold one or more values. An array variable can only store values of the same type T T . We say that the array variable is an array of T T . For instance, we can declare a variable marks to be an array of long , in which case, marks can hold one or more long values. Array Declaration The declaration syntax for an array in C takes the following form: long marks [ 10 ]; We use the square bracket [ and ] to indicate that the variable marks is an array. The number 10 indicates that marks holds 10 long values. Once declared, the variables in the array are uninitialized and will contain whatever value happened to be in the memory at that time. Accessing the Array Elements We can access the array elements using the index of the element, starting from 0. For instance, to initialize the marks for the first three students to 1, 2, 4, respectively, we can write: long marks [ 10 ]; marks [ 0 ] = 1 ; marks [ 1 ] = 2 ; marks [ 2 ] = 4 ; Array Initialization Initializing a large array using the method above could be tedious. Alternatively, we can initialize an array using a list of values when we declare the array. long marks [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; If we do not specify a value during initialization, it will be set to 0 by default. long marks [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , }; // marks[8] and marks[9] are both initialized to 0 Note that, after the declaration, we can no longer using this technique to reinitialized or initialize the array. long marks [ 10 ]; marks = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; // error Example 1: Array As Lookup Table One way the array is useful is that it can be used as a lookup table. Consider the following function days() , which, given a month, return the number of days from the 1 st of January until the 1 st of the month. So days(1) returns 0, days(2) returns 31 (since January has 31 days), days(3) returns 31 + 28 = 59 (assuming non-leap year), etc. long days ( long month ) { long days_since = 0 ; if ( month == 2 ) { days_since = 31 ; } else if ( month == 3 ) { days_since = 31 + 28 ; } else if ( month == 4 ) { days_since = 31 + 28 + 31 ; } else if ( month == 5 ) { days_since = 31 + 28 + 31 + 30 ; } else if ( month == 6 ) { days_since = 31 + 28 + 31 + 30 + 31 ; } else if ( month == 7 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 ; } else if ( month == 8 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 ; } else if ( month == 9 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 ; } else if ( month == 10 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 ; } else if ( month == 11 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 ; } else if ( month == 12 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 ; } return days_since ; } The code is ugly and bug-prone. Consider an alternative solution using an array. long days_in_month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; The array above is initialized with the number of days in a month. days_in_month[0] stores the number of days in January, days_in_month[1] stores the number of days in February, etc. The code above can then be written as: long days ( long month ) { long days_in_month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; long days_since = 0 ; for ( long i = 0 ; i < month - 1 ; i += 1 ) { days_since += days_in_month [ i ]; } return days_since ; } Example 2: Array As List We can now revisit the flowchart for max max and write the corresponding code. The code would look like this: long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } Please see the Appendix for the complete code Note that, in the type of the array passed into the function above, we only need to use [] without specifying the length. It is also almost always necessary to pass in the number of elements in the array together with the array so that we know how many elements are there to process. To understand why, we have to understand something called array decay . Array and Pointers The relationship between array and pointer can be confusing to beginners. Some might even think that arrays are pointers due to the way they are passed around and used. But arrays are not pointers . The relationship between the two, boils down to a very simple rule, as follows. In C, the name of the variable of an array is treated differently from a non-array variable. If we declare an array type name [ num_of_elems ]; then any reference to name is a synonym to &name[0] whenever we need the value of the array. In other words, name is the pointer to the first element in the array. This is known as the \"array decay\" operation. There are several implications of this. First, it is not possible to compare two arrays or assign one array to another. long a [ 2 ] = { 0 , 1 }; long b [ 2 ] = { 0 , 1 }; if ( a == b ) { // always false : } b = a ; // not possible Line 4 above is equivalent to comparing &a[0] to &b[0] , due to array decay, and therefore is always false (since the array elements do not have the same memory address). Line 8 above is equivalent to assigning &a[0] to &b[0] , as we seen in (Unit 14)[14-pointers.md], we cannot change the memory address of a variable since this is determined by the OS. Second, the expression name[i] is actually the same as *(name + i) . Although we should always write name[i] as it is easier to understand, internally, this translates to accessing the value stored at the i-th location after the first element of the array. (Revisit Unit 14 if you are unfamiliar with pointer arithmetic). Third, when we pass an array into a function, we are only passing in the address of the first element. Consider the example below: long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } int main () { long a [ 10 ] = { 1 , 2 , 3 , 4 , 1 , 9 , 10 , 44 , - 1 , - 5 }; cs1010_println_long ( max ( a , 10 )); } On Line 14, we pass a into the function max . Due to array decay, we are not passing in the whole array, but only the &a[0] . Inside max , we no longer have access to the whole array, but only the address of the first element. Luckily, due to pointer arithmetic and equivalence of list[i] to *(list + i) , we can still access the elements of the array. Due to this, the size of list in the function parameter does not matter, and we need to pass in the size of the array length to max so that inside max we know the size of the array that we are dealing with. Array decay also means that, when passing in an array as an argument to a function, we can very well write it as: long max ( long * list , long length ) { : } For readability, however, we should convey to the reader of the code that list is an array and not just a pointer to long , thus we should still use the [] notation. Another implication of array decay when passing an array into a function, is that it is possible to write programs that behave incorrectly, without any compiler error or warning. Consider the following: int main () { long a = 0 ; printf ( \"%ld \\n \" , max ( & a , 10 )); } The compiler clang would happily compile this and generate an executable. When executed, it would print a gibberish to the standard output. Other Facts About Arrays Variable Length Array We can also declare an array where the number of elements depends on the value of a variable. long num_of_students = 10 ; long marks [ num_of_students ]; Such arrays, where the number of elements (or length) depends on the value of a variable, are sometimes called variable-length array . This is a misnomer since once the array is created, the length is fixed. Changing the value of the variable num_of_students above will not change the length of marks . Skipping Elements During Initialization If we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use element designators , putting the index of the element we want to initialize to non-zero in square brackets [ and ] . long vector [ 100 ] = { 1 , [ 5 ] = 2 , 3 , [ 99 ] = - 1 }; An earlier version of this note has a typo, initializing [100] = -1 instead. This statement initializes vector[0] to 1, vector[5] to 2, vector[6] to 3, and vector[99] to -1. The rest of the elements will be 0. Skipping the Size in Declaration If you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length. long marks [] = { 1 , 3 , 2 , 8 , 5 ,} This makes it easy to add or remove items from the array, without having to remember to keep the array length consistent. Determining the Number of Elements in the Array C provides a sizeof operator, which returns the number of bytes allocated to a type. We can use sizeof long for instance, to determine the number of bytes allocated to long on a platform. We can also use sizeof on a variable instead of the type. This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration). We can calculate the number of elements in marks with long num_of_elem = sizeof marks / sizeof marks [ 0 ]; Note that array decay does not apply for only two operators: the sizeof operator, and the address-of & operator. So the expression above works as intended. Dynamically Allocated Array It is often not possible to determine the length of the array beforehand. So, it is useful to be able to allocate an array with a length that is determined during runtime (not hard-coding the length of the array in the program). For instance, if I want to keep a marks array for a module, it is unclear how big I should set the array to. How big is big enough? While I can use a variable-length array for this purpose, it is not ideal -- if the system does not have enough memory to store the array, the program would simply crash with a segfault and there is no way to recover from this. For this reason, it is useful to request memory from the OS which we will manage ourselves in our program. Unlike memory space on the call stack which is managed entirely by the OS, there is another region of memory called the heap , which we can use. We can request for memory from heap using the method calloc() and return the memory back to the heap when we are done with free() . We will visit these in more details later, but this shallow understanding is enough for now. CS1010 I/O Library To wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either long values or double values. These functions, cs1010_read_long_array or cs1010_read_double_array takes in a parameter, which is the number of elements to read, and it returns a pointer to the array allocated within the function. For instance, to read in an array of 100 integers, we can write: long * marks ; marks = cs1010_read_long_array ( 100 ); for ( long i = 0 ; i < 100 ; i += 1 ) { cs1010_println_long ( marks [ i ]); } This should be straightforward enough. There are, however, two cases to consider. What if the OS failed to allocate the memory for our array? In this case, marks would be NULL and access marks[i] would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done. To let go of this memory, we call the function free . The complete code looks like this: long * marks ; marks = cs1010_read_long_array ( 100 ); if ( marks == NULL ) { // signal error and return } for ( long i = 0 ; i < 100 ; i += 1 ) { cs1010_println_long ( marks [ i ]); } // do other things to marks : free ( marks ); Problem Set 15 Problem 15.1 Write the function average that takes an array of k k integers and k k and returns the average of the k k values in the array. Problem 15.2 Explain why the following would lead to senseless output: int main () { long a = 0 ; printf ( \"%ld \\n \" , max ( & a , 10 )); } How about the following? Would the output be correct? int main () { long a = 0 ; printf ( \"%ld \\n \" , max ( & a , 1 )); // change 10 to 1 } Problem 15.3 Explain how the following code iterates through every element in the list, when called with an array of length length as the first argument. long max ( long * list , long length ) { long max_so_far ; long * curr ; max_so_far = * list ; curr = list + 1 ; for ( long i = 1 ; i != length ; i += 1 ) { if ( * curr > max_so_far ) { max_so_far = * curr ; } curr += 1 ; } return max_so_far ; } Appendix: Complete Code Example #include \"cs1010.h\" long days_till_beginning_of ( long month ) { long days_in_month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; long num_of_days = 0 ; for ( long i = 0 ; i < month - 1 ; i += 1 ) { num_of_days += days_in_month [ i ]; } return num_of_days ; } int main () { long month = cs1010_read_long (); long day = cs1010_read_long (); cs1010_println_long ( day + days_till_beginning_of ( month )); } long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } int main () { long a [ 10 ] = { 1 , 2 , 3 , 4 , 1 , 9 , 10 , 44 , - 1 , - 5 }; cs1010_println_long ( max ( a , 10 )); }","title":"15. Arrays"},{"location":"15-array.html#unit-15-array","text":"We now look at the first of the two compound data types in C -- arrays. A variable can be declared to be of an array, in which case it can hold one or more values. An array variable can only store values of the same type T T . We say that the array variable is an array of T T . For instance, we can declare a variable marks to be an array of long , in which case, marks can hold one or more long values.","title":"Unit 15: Array"},{"location":"15-array.html#array-declaration","text":"The declaration syntax for an array in C takes the following form: long marks [ 10 ]; We use the square bracket [ and ] to indicate that the variable marks is an array. The number 10 indicates that marks holds 10 long values. Once declared, the variables in the array are uninitialized and will contain whatever value happened to be in the memory at that time.","title":"Array Declaration"},{"location":"15-array.html#accessing-the-array-elements","text":"We can access the array elements using the index of the element, starting from 0. For instance, to initialize the marks for the first three students to 1, 2, 4, respectively, we can write: long marks [ 10 ]; marks [ 0 ] = 1 ; marks [ 1 ] = 2 ; marks [ 2 ] = 4 ;","title":"Accessing the Array Elements"},{"location":"15-array.html#array-initialization","text":"Initializing a large array using the method above could be tedious. Alternatively, we can initialize an array using a list of values when we declare the array. long marks [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; If we do not specify a value during initialization, it will be set to 0 by default. long marks [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , }; // marks[8] and marks[9] are both initialized to 0 Note that, after the declaration, we can no longer using this technique to reinitialized or initialize the array. long marks [ 10 ]; marks = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; // error","title":"Array Initialization"},{"location":"15-array.html#example-1-array-as-lookup-table","text":"One way the array is useful is that it can be used as a lookup table. Consider the following function days() , which, given a month, return the number of days from the 1 st of January until the 1 st of the month. So days(1) returns 0, days(2) returns 31 (since January has 31 days), days(3) returns 31 + 28 = 59 (assuming non-leap year), etc. long days ( long month ) { long days_since = 0 ; if ( month == 2 ) { days_since = 31 ; } else if ( month == 3 ) { days_since = 31 + 28 ; } else if ( month == 4 ) { days_since = 31 + 28 + 31 ; } else if ( month == 5 ) { days_since = 31 + 28 + 31 + 30 ; } else if ( month == 6 ) { days_since = 31 + 28 + 31 + 30 + 31 ; } else if ( month == 7 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 ; } else if ( month == 8 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 ; } else if ( month == 9 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 ; } else if ( month == 10 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 ; } else if ( month == 11 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 ; } else if ( month == 12 ) { days_since = 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 ; } return days_since ; } The code is ugly and bug-prone. Consider an alternative solution using an array. long days_in_month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; The array above is initialized with the number of days in a month. days_in_month[0] stores the number of days in January, days_in_month[1] stores the number of days in February, etc. The code above can then be written as: long days ( long month ) { long days_in_month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; long days_since = 0 ; for ( long i = 0 ; i < month - 1 ; i += 1 ) { days_since += days_in_month [ i ]; } return days_since ; }","title":"Example 1: Array As Lookup Table"},{"location":"15-array.html#example-2-array-as-list","text":"We can now revisit the flowchart for max max and write the corresponding code. The code would look like this: long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } Please see the Appendix for the complete code Note that, in the type of the array passed into the function above, we only need to use [] without specifying the length. It is also almost always necessary to pass in the number of elements in the array together with the array so that we know how many elements are there to process. To understand why, we have to understand something called array decay .","title":"Example 2: Array As List"},{"location":"15-array.html#array-and-pointers","text":"The relationship between array and pointer can be confusing to beginners. Some might even think that arrays are pointers due to the way they are passed around and used. But arrays are not pointers . The relationship between the two, boils down to a very simple rule, as follows. In C, the name of the variable of an array is treated differently from a non-array variable. If we declare an array type name [ num_of_elems ]; then any reference to name is a synonym to &name[0] whenever we need the value of the array. In other words, name is the pointer to the first element in the array. This is known as the \"array decay\" operation. There are several implications of this. First, it is not possible to compare two arrays or assign one array to another. long a [ 2 ] = { 0 , 1 }; long b [ 2 ] = { 0 , 1 }; if ( a == b ) { // always false : } b = a ; // not possible Line 4 above is equivalent to comparing &a[0] to &b[0] , due to array decay, and therefore is always false (since the array elements do not have the same memory address). Line 8 above is equivalent to assigning &a[0] to &b[0] , as we seen in (Unit 14)[14-pointers.md], we cannot change the memory address of a variable since this is determined by the OS. Second, the expression name[i] is actually the same as *(name + i) . Although we should always write name[i] as it is easier to understand, internally, this translates to accessing the value stored at the i-th location after the first element of the array. (Revisit Unit 14 if you are unfamiliar with pointer arithmetic). Third, when we pass an array into a function, we are only passing in the address of the first element. Consider the example below: long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } int main () { long a [ 10 ] = { 1 , 2 , 3 , 4 , 1 , 9 , 10 , 44 , - 1 , - 5 }; cs1010_println_long ( max ( a , 10 )); } On Line 14, we pass a into the function max . Due to array decay, we are not passing in the whole array, but only the &a[0] . Inside max , we no longer have access to the whole array, but only the address of the first element. Luckily, due to pointer arithmetic and equivalence of list[i] to *(list + i) , we can still access the elements of the array. Due to this, the size of list in the function parameter does not matter, and we need to pass in the size of the array length to max so that inside max we know the size of the array that we are dealing with. Array decay also means that, when passing in an array as an argument to a function, we can very well write it as: long max ( long * list , long length ) { : } For readability, however, we should convey to the reader of the code that list is an array and not just a pointer to long , thus we should still use the [] notation. Another implication of array decay when passing an array into a function, is that it is possible to write programs that behave incorrectly, without any compiler error or warning. Consider the following: int main () { long a = 0 ; printf ( \"%ld \\n \" , max ( & a , 10 )); } The compiler clang would happily compile this and generate an executable. When executed, it would print a gibberish to the standard output.","title":"Array and Pointers"},{"location":"15-array.html#other-facts-about-arrays","text":"","title":"Other Facts About Arrays"},{"location":"15-array.html#variable-length-array","text":"We can also declare an array where the number of elements depends on the value of a variable. long num_of_students = 10 ; long marks [ num_of_students ]; Such arrays, where the number of elements (or length) depends on the value of a variable, are sometimes called variable-length array . This is a misnomer since once the array is created, the length is fixed. Changing the value of the variable num_of_students above will not change the length of marks .","title":"Variable Length Array"},{"location":"15-array.html#skipping-elements-during-initialization","text":"If we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use element designators , putting the index of the element we want to initialize to non-zero in square brackets [ and ] . long vector [ 100 ] = { 1 , [ 5 ] = 2 , 3 , [ 99 ] = - 1 }; An earlier version of this note has a typo, initializing [100] = -1 instead. This statement initializes vector[0] to 1, vector[5] to 2, vector[6] to 3, and vector[99] to -1. The rest of the elements will be 0.","title":"Skipping Elements During Initialization"},{"location":"15-array.html#skipping-the-size-in-declaration","text":"If you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length. long marks [] = { 1 , 3 , 2 , 8 , 5 ,} This makes it easy to add or remove items from the array, without having to remember to keep the array length consistent.","title":"Skipping the Size in Declaration"},{"location":"15-array.html#determining-the-number-of-elements-in-the-array","text":"C provides a sizeof operator, which returns the number of bytes allocated to a type. We can use sizeof long for instance, to determine the number of bytes allocated to long on a platform. We can also use sizeof on a variable instead of the type. This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration). We can calculate the number of elements in marks with long num_of_elem = sizeof marks / sizeof marks [ 0 ]; Note that array decay does not apply for only two operators: the sizeof operator, and the address-of & operator. So the expression above works as intended.","title":"Determining the Number of Elements in the Array"},{"location":"15-array.html#dynamically-allocated-array","text":"It is often not possible to determine the length of the array beforehand. So, it is useful to be able to allocate an array with a length that is determined during runtime (not hard-coding the length of the array in the program). For instance, if I want to keep a marks array for a module, it is unclear how big I should set the array to. How big is big enough? While I can use a variable-length array for this purpose, it is not ideal -- if the system does not have enough memory to store the array, the program would simply crash with a segfault and there is no way to recover from this. For this reason, it is useful to request memory from the OS which we will manage ourselves in our program. Unlike memory space on the call stack which is managed entirely by the OS, there is another region of memory called the heap , which we can use. We can request for memory from heap using the method calloc() and return the memory back to the heap when we are done with free() . We will visit these in more details later, but this shallow understanding is enough for now.","title":"Dynamically Allocated Array"},{"location":"15-array.html#cs1010-io-library","text":"To wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either long values or double values. These functions, cs1010_read_long_array or cs1010_read_double_array takes in a parameter, which is the number of elements to read, and it returns a pointer to the array allocated within the function. For instance, to read in an array of 100 integers, we can write: long * marks ; marks = cs1010_read_long_array ( 100 ); for ( long i = 0 ; i < 100 ; i += 1 ) { cs1010_println_long ( marks [ i ]); } This should be straightforward enough. There are, however, two cases to consider. What if the OS failed to allocate the memory for our array? In this case, marks would be NULL and access marks[i] would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done. To let go of this memory, we call the function free . The complete code looks like this: long * marks ; marks = cs1010_read_long_array ( 100 ); if ( marks == NULL ) { // signal error and return } for ( long i = 0 ; i < 100 ; i += 1 ) { cs1010_println_long ( marks [ i ]); } // do other things to marks : free ( marks );","title":"CS1010 I/O Library"},{"location":"15-array.html#problem-set-15","text":"","title":"Problem Set 15"},{"location":"15-array.html#problem-151","text":"Write the function average that takes an array of k k integers and k k and returns the average of the k k values in the array.","title":"Problem 15.1"},{"location":"15-array.html#problem-152","text":"Explain why the following would lead to senseless output: int main () { long a = 0 ; printf ( \"%ld \\n \" , max ( & a , 10 )); } How about the following? Would the output be correct? int main () { long a = 0 ; printf ( \"%ld \\n \" , max ( & a , 1 )); // change 10 to 1 }","title":"Problem 15.2"},{"location":"15-array.html#problem-153","text":"Explain how the following code iterates through every element in the list, when called with an array of length length as the first argument. long max ( long * list , long length ) { long max_so_far ; long * curr ; max_so_far = * list ; curr = list + 1 ; for ( long i = 1 ; i != length ; i += 1 ) { if ( * curr > max_so_far ) { max_so_far = * curr ; } curr += 1 ; } return max_so_far ; }","title":"Problem 15.3"},{"location":"15-array.html#appendix-complete-code-example","text":"#include \"cs1010.h\" long days_till_beginning_of ( long month ) { long days_in_month [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; long num_of_days = 0 ; for ( long i = 0 ; i < month - 1 ; i += 1 ) { num_of_days += days_in_month [ i ]; } return num_of_days ; } int main () { long month = cs1010_read_long (); long day = cs1010_read_long (); cs1010_println_long ( day + days_till_beginning_of ( month )); } long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } int main () { long a [ 10 ] = { 1 , 2 , 3 , 4 , 1 , 9 , 10 , 44 , - 1 , - 5 }; cs1010_println_long ( max ( a , 10 )); }","title":"Appendix: Complete Code Example"},{"location":"16-string.html","text":"Unit 16: Strings We have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\". In C, a string is nothing more than just an array of char values (Recall from Unit 5 that sizeof char is 1). Just a char Array The only thing special about a string is that it always end with a 0 value (note: not character '0' which has a value of 48, but the value 0). Since the character with value 0 is called the null character, written as '\\0', we refer that strings in C as null-terminated strings. In C, we distinguish between a string and a char by the quotes used. String uses double quotes \" , while a char uses single quote ' . So we can do the following and they are equivalent: char hello1 [ 7 ] = { 'h' , 'e' , 'l' , 'l' , 'o' , '!' , 0 }; char hello2 [ 7 ] = \"hello!\" ; Of course, nobody actually initializes a string in the first way above. We can also skip the size of the array, as mentioned above, or, more commonly, use a char * type for a variable storing a constant string. char hello3 [] = \"hello!\" ; char * hello4 = \"hello!\" ; Special Characters The null character is written as '\\0'. The use of the backslash \\ creates an escape sequence that can be used to denote characters that would otherwise not visible on screen. For instance, besides '\\0', we will likely encounter '\\n' (the newline character) '\\t' (the tab character) and '\\a' (the beep character) regularly. Furthermore, since we already use \\ to indicate the escape sequence, ' to indicate a character, and \" to indicate a string, in order to use these characters, we need to \"escape\" them -- we use '\\' for the backslash character, '\\'', the single quote character, and the '\\\"' double quote character. String Literals A string literal refers to a string written between two \" characters, such as \"Hello world!\" . Such a string are still internally stored as an array of char values. The location these arrays are stored depend on the platform, but usually they are stored in a read only region of the memory called the text region. These strings are not meant to be modified. Hence, trying something like this: char * str1 = \"Hello!\" ; str1 [ 5 ] = '.' ; is not allowed and would crash your program. The following, however, is OK: char str2 [ 7 ] = \"Hello!\" ; str2 [ 5 ] = '.' ; The differences between the two is that, str1 points to a read-only region in the memory, while str2 contains a copy of the string on the stack. Empty String We commonly use the empty string \"\" to indicate a special condition or to initialize a string variable, where appropriate. The empty string is basically an array where the 0-th element is '\\0'. CS1010 I/O Library The CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character). They are cs1010_read_word() and cs1010_read_line() respectively. We can also read multiple words and multiple lines with cs1010_read_word_array() and cs1010_read_line_array() . The results are stored in an array of strings. Problem Set 16 Problem 16.1 Write the following functions (without calling the standard C functions declared in <string.h> such as strlen , strcmp , strstr ): a) long string_length(char *str) return the length (i.e., the number of characters) of the string str . b) bool string_equal(char *str1, char *str2) return true if the two strings str1 and str2 contains exactly the same content, false otherwise. (Note: str1 == str2 does not compare if two strings have the same content. (Why?)) c) char *string_in_string(char *needle, char *haystack) return a pointer to the first character of the first occurance of needle in haystack , if found. If needle does not occur anywhere in haystack , return NULL. If needle is an empty string, haystack is returned.","title":"16. Strings"},{"location":"16-string.html#unit-16-strings","text":"We have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\". In C, a string is nothing more than just an array of char values (Recall from Unit 5 that sizeof char is 1).","title":"Unit 16: Strings"},{"location":"16-string.html#just-a-char-array","text":"The only thing special about a string is that it always end with a 0 value (note: not character '0' which has a value of 48, but the value 0). Since the character with value 0 is called the null character, written as '\\0', we refer that strings in C as null-terminated strings. In C, we distinguish between a string and a char by the quotes used. String uses double quotes \" , while a char uses single quote ' . So we can do the following and they are equivalent: char hello1 [ 7 ] = { 'h' , 'e' , 'l' , 'l' , 'o' , '!' , 0 }; char hello2 [ 7 ] = \"hello!\" ; Of course, nobody actually initializes a string in the first way above. We can also skip the size of the array, as mentioned above, or, more commonly, use a char * type for a variable storing a constant string. char hello3 [] = \"hello!\" ; char * hello4 = \"hello!\" ;","title":"Just a char Array"},{"location":"16-string.html#special-characters","text":"The null character is written as '\\0'. The use of the backslash \\ creates an escape sequence that can be used to denote characters that would otherwise not visible on screen. For instance, besides '\\0', we will likely encounter '\\n' (the newline character) '\\t' (the tab character) and '\\a' (the beep character) regularly. Furthermore, since we already use \\ to indicate the escape sequence, ' to indicate a character, and \" to indicate a string, in order to use these characters, we need to \"escape\" them -- we use '\\' for the backslash character, '\\'', the single quote character, and the '\\\"' double quote character.","title":"Special Characters"},{"location":"16-string.html#czjqqkd0string-literalsczjqqkd1","text":"A string literal refers to a string written between two \" characters, such as \"Hello world!\" . Such a string are still internally stored as an array of char values. The location these arrays are stored depend on the platform, but usually they are stored in a read only region of the memory called the text region. These strings are not meant to be modified. Hence, trying something like this: char * str1 = \"Hello!\" ; str1 [ 5 ] = '.' ; is not allowed and would crash your program. The following, however, is OK: char str2 [ 7 ] = \"Hello!\" ; str2 [ 5 ] = '.' ; The differences between the two is that, str1 points to a read-only region in the memory, while str2 contains a copy of the string on the stack.","title":"\u0002czjqqkd:0\u0003String Literals\u0002czjqqkd:1\u0003"},{"location":"16-string.html#empty-string","text":"We commonly use the empty string \"\" to indicate a special condition or to initialize a string variable, where appropriate. The empty string is basically an array where the 0-th element is '\\0'.","title":"Empty String"},{"location":"16-string.html#cs1010-io-library","text":"The CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character). They are cs1010_read_word() and cs1010_read_line() respectively. We can also read multiple words and multiple lines with cs1010_read_word_array() and cs1010_read_line_array() . The results are stored in an array of strings.","title":"CS1010 I/O Library"},{"location":"16-string.html#problem-set-16","text":"","title":"Problem Set 16"},{"location":"16-string.html#problem-161","text":"Write the following functions (without calling the standard C functions declared in <string.h> such as strlen , strcmp , strstr ): a) long string_length(char *str) return the length (i.e., the number of characters) of the string str . b) bool string_equal(char *str1, char *str2) return true if the two strings str1 and str2 contains exactly the same content, false otherwise. (Note: str1 == str2 does not compare if two strings have the same content. (Why?)) c) char *string_in_string(char *needle, char *haystack) return a pointer to the first character of the first occurance of needle in haystack , if found. If needle does not occur anywhere in haystack , return NULL. If needle is an empty string, haystack is returned.","title":"Problem 16.1"},{"location":"17-call-by-reference.html","text":"Unit 17: Call by Value & Call by Reference So far, in CS1010, we have considered a very \"clean\" notion of functions -- each function is a black box, it takes in zero or more parameters, and it returns zero or one value. We also said that within this black box, whatever happens inside the function stays inside, and the function has no effect on the variables outside. Such \"effect-free\" programming leads to code that is easy to reason about and understandable. For instance, suppose we have a code like this: long x = 1 ; foo ( x ); // { x == 1 } We can assert that, after calling foo , the value of x is still 1. Such functions are called pure functions . There is a class of programming languages, called functional programming languages, that is built entirely based on such pure functions. As much as possible, we should write functions that are pure as it is less bug-prone, is easier to understand, and easier to prove that the code is correct. All the functions that we have written before are invoked using a mechanism called call by value . This is because the value of the variable is copied onto the call stack. Functions with Side Effects In Unit 15 , we have seen a mechanism that breaks this rule. When we pass an array into a function, due to array decay, we are actually passing in the pointer to the first element of the array. So, what gets copied onto the call stack is the pointer, not the array. Now, with this pointer, we can modify the elements in the array directly.o For example, the code below reset all elements in the array to 0. void set_to_zeros ( long length , long a [ length ]) { for ( long i = 0 ; i < length ; i += 1 ) { a [ i ] = 0 ; } } Whatever happens in the function no longer stays in the function. When you see code like this: long a [ 10 ]; a [ 0 ] = 1 ; foo ( a ); // { a[0] == ?? } We can no longer be certain that the value of a[0] after calling foo remains 1, since foo , or functions that it calls, could have modified a[0] . We have to trace through the code of foo and all the function it calls to understand and reason about that changes to a[0] . The keyword const Since a function taking in an array parameter can potentially modify the content of the array, as a courtesy, it is useful to add the C keyword const in the declaration of the array parameter: void foo(long length, const long a[]) { : } to signal to the readers of the code that this function only reads from the array and does not modify it. This simplifies the reasoning about the behavior of the code. Call by Reference The call-by-value mechanism has its limitation. Sometimes, it is useful for a function to return more than one results. You have seen an example before in your Assignment 2 , where, for the collatz problem, you are supposed to find both the largest stopping time and the value with the largest stopping time. C functions, however, can only return at most one value. One way to get around this limitation is to use call-by-reference, the other is to use struct . We will leave the discussion of struct for another day, so let's see how call by reference works in this unit. Calling by reference works by passing the (value of a) pointer to a variable into a function, instead of the (value of) variable. Here is an example from the collatz problem. Example: Collatz void find_max_steps ( long n , long * max_n , long * max_num_steps ) { * max_num_steps = 0 ; * max_n = 1 ; for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= * max_num_steps ) { * max_n = i ; * max_num_steps = num_of_steps ; } } } The method find_max takes in two pointers. Inside the function, we use the deference operator * to modify the variable pointed to by the pointers (Lines 2, 3, 7 and 8). To use this function, we have: int main () { long n = cs1010_read_long (); long max_num_steps = 0 ; long max_n = 1 ; find_max_steps ( n , & max_n , & max_num_steps ); cs1010_println_long ( max_n ); cs1010_println_long ( max_num_steps ); } In Line 4 above, we pass in the address of max_n and max_num_steps into find_max_steps . find_max_steps updates both variables for us. Example: Swapping Two Variables Another example for call-by-reference is a function that swaps two variables. Here is one that swaps two long variables. void swap ( long * a , long * b ) { long temp = * a ; * a = * b ; * b = temp ; } To see swap in action, consider: long a = 10 ; long b = - 4 ; swap ( & a , & b ); After calling swap , the value for a becomes -4, b becomes 10. Documenting Call-by-Reference Parameters A parameter passed as a pointer could be used in three different ways: The parameter could be a read-only input, and the main purpose of passing in the value is so that the function has access to the value of the pointer. The parameter could be used as a vessel for the function to pass a value to the caller, similar to the parameters max_n and max_num_steps in the function find_max_steps above. In this case, the value contained in the variable pointed to by the pointer does not matter. The parameter could be used as both input and output. The value contained in the parameter is read inside the function, and the value is updated from inside the function. For example, the parameters passed to swap above. In CS1010, we will be using Doxygen format to document our functions. There are three types of parameters, corresponding to the three situations above: @param[in] is used to document a read-only parameter (note that this applies to all read-only parameters, not just pointers). @param[out] is used to document an output-only parameter, and @param[in,out] is used to document a parameter that is both input and output. Problem Set Problem 17.1 Complete the function find_min_max that takes in a length and an array containing long values of size length , and update the parameter min and max with the minimum and the maximum value from this array, respectively. Show how to call this function from main . void find_min_max ( long length , long array [ length ], long * min , long * max ) { : } int main () { long list [ 10 ] = { 1 , 2 , 3 , 4 , - 4 , 5 , 6 , - 8 , 3 , 1 }; : } Problem 17.2 Consider the program below: void foo ( double * ptr , double trouble ) { ptr = & trouble ; * ptr = 10.0 ; } int main () { double * ptr ; double x = - 3.0 ; double y = 7.0 ; ptr = & y ; foo ( ptr , x ); cs1010_println_double ( x ); cs1010_println_double ( y ); } What would be printed? Appendix: Complete Code #include \"cs1010.h\" void set_to_0s ( long len , long a [ len ]) { for ( long i = 0 ; i < len ; i += 1 ) { a [ i ] = 0 ; } } int main () { long a [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int len = 5 ; set_to_0s ( len , a ); for ( long i = 0 ; i < len ; i += 1 ) { cs1010_println_long ( a [ i ]); } } include \"cs1010.h\" void max ( const long list [], long length , long * max_value , long * max_pos ) { * max_value = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > * max_value ) { * max_value = list [ i ]; * max_pos = i ; } } } int main () { long list [ 6 ] = { 15 , 8 , 4 , 16 , 42 , 23 }; long max_value ; long max_pos ; max ( list , 6 , & max_value , & max_pos ); cs1010_println_long ( max_value ); cs1010_println_long ( max_pos ); }","title":"17. Call by Reference"},{"location":"17-call-by-reference.html#unit-17-call-by-value-call-by-reference","text":"So far, in CS1010, we have considered a very \"clean\" notion of functions -- each function is a black box, it takes in zero or more parameters, and it returns zero or one value. We also said that within this black box, whatever happens inside the function stays inside, and the function has no effect on the variables outside. Such \"effect-free\" programming leads to code that is easy to reason about and understandable. For instance, suppose we have a code like this: long x = 1 ; foo ( x ); // { x == 1 } We can assert that, after calling foo , the value of x is still 1. Such functions are called pure functions . There is a class of programming languages, called functional programming languages, that is built entirely based on such pure functions. As much as possible, we should write functions that are pure as it is less bug-prone, is easier to understand, and easier to prove that the code is correct. All the functions that we have written before are invoked using a mechanism called call by value . This is because the value of the variable is copied onto the call stack.","title":"Unit 17: Call by Value &amp; Call by Reference"},{"location":"17-call-by-reference.html#functions-with-side-effects","text":"In Unit 15 , we have seen a mechanism that breaks this rule. When we pass an array into a function, due to array decay, we are actually passing in the pointer to the first element of the array. So, what gets copied onto the call stack is the pointer, not the array. Now, with this pointer, we can modify the elements in the array directly.o For example, the code below reset all elements in the array to 0. void set_to_zeros ( long length , long a [ length ]) { for ( long i = 0 ; i < length ; i += 1 ) { a [ i ] = 0 ; } } Whatever happens in the function no longer stays in the function. When you see code like this: long a [ 10 ]; a [ 0 ] = 1 ; foo ( a ); // { a[0] == ?? } We can no longer be certain that the value of a[0] after calling foo remains 1, since foo , or functions that it calls, could have modified a[0] . We have to trace through the code of foo and all the function it calls to understand and reason about that changes to a[0] . The keyword const Since a function taking in an array parameter can potentially modify the content of the array, as a courtesy, it is useful to add the C keyword const in the declaration of the array parameter: void foo(long length, const long a[]) { : } to signal to the readers of the code that this function only reads from the array and does not modify it. This simplifies the reasoning about the behavior of the code.","title":"Functions with Side Effects"},{"location":"17-call-by-reference.html#call-by-reference","text":"The call-by-value mechanism has its limitation. Sometimes, it is useful for a function to return more than one results. You have seen an example before in your Assignment 2 , where, for the collatz problem, you are supposed to find both the largest stopping time and the value with the largest stopping time. C functions, however, can only return at most one value. One way to get around this limitation is to use call-by-reference, the other is to use struct . We will leave the discussion of struct for another day, so let's see how call by reference works in this unit. Calling by reference works by passing the (value of a) pointer to a variable into a function, instead of the (value of) variable. Here is an example from the collatz problem.","title":"Call by Reference"},{"location":"17-call-by-reference.html#example-collatz","text":"void find_max_steps ( long n , long * max_n , long * max_num_steps ) { * max_num_steps = 0 ; * max_n = 1 ; for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= * max_num_steps ) { * max_n = i ; * max_num_steps = num_of_steps ; } } } The method find_max takes in two pointers. Inside the function, we use the deference operator * to modify the variable pointed to by the pointers (Lines 2, 3, 7 and 8). To use this function, we have: int main () { long n = cs1010_read_long (); long max_num_steps = 0 ; long max_n = 1 ; find_max_steps ( n , & max_n , & max_num_steps ); cs1010_println_long ( max_n ); cs1010_println_long ( max_num_steps ); } In Line 4 above, we pass in the address of max_n and max_num_steps into find_max_steps . find_max_steps updates both variables for us.","title":"Example: Collatz"},{"location":"17-call-by-reference.html#example-swapping-two-variables","text":"Another example for call-by-reference is a function that swaps two variables. Here is one that swaps two long variables. void swap ( long * a , long * b ) { long temp = * a ; * a = * b ; * b = temp ; } To see swap in action, consider: long a = 10 ; long b = - 4 ; swap ( & a , & b ); After calling swap , the value for a becomes -4, b becomes 10.","title":"Example: Swapping Two Variables"},{"location":"17-call-by-reference.html#documenting-call-by-reference-parameters","text":"A parameter passed as a pointer could be used in three different ways: The parameter could be a read-only input, and the main purpose of passing in the value is so that the function has access to the value of the pointer. The parameter could be used as a vessel for the function to pass a value to the caller, similar to the parameters max_n and max_num_steps in the function find_max_steps above. In this case, the value contained in the variable pointed to by the pointer does not matter. The parameter could be used as both input and output. The value contained in the parameter is read inside the function, and the value is updated from inside the function. For example, the parameters passed to swap above. In CS1010, we will be using Doxygen format to document our functions. There are three types of parameters, corresponding to the three situations above: @param[in] is used to document a read-only parameter (note that this applies to all read-only parameters, not just pointers). @param[out] is used to document an output-only parameter, and @param[in,out] is used to document a parameter that is both input and output.","title":"Documenting Call-by-Reference Parameters"},{"location":"17-call-by-reference.html#problem-set","text":"","title":"Problem Set"},{"location":"17-call-by-reference.html#problem-171","text":"Complete the function find_min_max that takes in a length and an array containing long values of size length , and update the parameter min and max with the minimum and the maximum value from this array, respectively. Show how to call this function from main . void find_min_max ( long length , long array [ length ], long * min , long * max ) { : } int main () { long list [ 10 ] = { 1 , 2 , 3 , 4 , - 4 , 5 , 6 , - 8 , 3 , 1 }; : }","title":"Problem 17.1"},{"location":"17-call-by-reference.html#problem-172","text":"Consider the program below: void foo ( double * ptr , double trouble ) { ptr = & trouble ; * ptr = 10.0 ; } int main () { double * ptr ; double x = - 3.0 ; double y = 7.0 ; ptr = & y ; foo ( ptr , x ); cs1010_println_double ( x ); cs1010_println_double ( y ); } What would be printed?","title":"Problem 17.2"},{"location":"17-call-by-reference.html#appendix-complete-code","text":"#include \"cs1010.h\" void set_to_0s ( long len , long a [ len ]) { for ( long i = 0 ; i < len ; i += 1 ) { a [ i ] = 0 ; } } int main () { long a [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int len = 5 ; set_to_0s ( len , a ); for ( long i = 0 ; i < len ; i += 1 ) { cs1010_println_long ( a [ i ]); } } include \"cs1010.h\" void max ( const long list [], long length , long * max_value , long * max_pos ) { * max_value = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > * max_value ) { * max_value = list [ i ]; * max_pos = i ; } } } int main () { long list [ 6 ] = { 15 , 8 , 4 , 16 , 42 , 23 }; long max_value ; long max_pos ; max ( list , 6 , & max_value , & max_pos ); cs1010_println_long ( max_value ); cs1010_println_long ( max_pos ); }","title":"Appendix: Complete Code"},{"location":"18-heap.html","text":"Unit 18: Heap We have already seen what a call stack is and how call stack works in Unit 13 . There is another important area of memory used by our programs, called the heap . Recall that a variable allocated on the stack has two properties: Its lifetime is the same as the lifetime of the function the variable is declared in. The memory allocation and deallocation are automatic. For stack, the memory is allocated automatically when the function is called and deallocated automatically as soon as the function exits. For this reason, such a variable is sometimes called automatic variable, or auto variable for short. Variables on Heap The memory allocation on the heap can be done automatically or manually. For variables allocated on the heap, its lifetime is either the same as the lifetime of the whole programme. Example of such a variable is a global variable -- a variable that is declared outside of any function and can be read or write anywhere in the program. We have banned the use of global variables in CS1010. Using global variable makes your code hard to understand or reason about: x = 1 ; foo (); // { x == ?? } Suppose x is a global variable, we cannot assert anything about the property of x after calling foo , since x can be modified by foo or any function it calls, even though we never pass x into foo . This is worse than passing an array as we have seen in Unit 17 ! Manual Memory Allocation / Deallocation Allocating memory on the heap, however, is useful if we want to allocate an array dynamically, i.e., not knowing what is the size of the array when we write the program. Often, we need an array whose size depends on the input from the user, such as reading a string or reading a sequence of numbers. We cannot use fixed length array unless we know for sure that the input size is limited, and we cannot use variable length array, since we may get a segfault if the array size is too big for the stack. The only viable solution is to allocate the array on the heap. The C standard library provides a few functions related to memory allocation on the heap. The header file for these functions is stdlib.h . We are interested in malloc and calloc . malloc (memory allocation) is declared as: void * malloc ( size_t size ); It takes in a parameter, size , which is the number of bytes of memory to be allocated and returns a pointer to the memory allocated if successful, or NULL otherwise. This is a general function so the type of pointer returned is void * rather than a pointer to a specific type. The type of size is size_t , which is a type defined in stdlib.h to represent the number of bytes in memory. The function calloc (clear allocation) is declared as: void * calloc ( size_t count , size_t size ); calloc allocates memory for count items, each of size number of bytes, in a contiguous region in the memory and initialize all bits in this memory region to 0. Except for the fact that calloc initializes the bits to 0, calloc(count, size) is the same as malloc(count * size) . We have seen in Unit 5 that the number of bytes needed to represent a type depends on the platform. Suppose we want to allocate enough memory for, say, 10 long values, how do we know how many bytes are needed? A long can be 4 bytes on some platforms, 8 bytes on others. For this purpose, C provides a sizeof operator, that returns the number of bytes needed for a type or a variable. So, to allocate memory for 10 long values, we say: long * array = malloc ( 10 * sizeof ( long )); The CS1010 I/O library, internally, allocates memory on the heap so that we can read in words, lines, or arrays of arbitrary length. The following shows the example of how cs1010_read_long_array is implemented with calloc . long * cs1010_read_long_array ( int how_many ) { long * buffer = calloc ( how_many , sizeof ( long )); if ( buffer == NULL ) { return NULL ; } for ( int i = 0 ; i < how_many ; i += 1 ) { buffer [ i ] = cs1010_read_long (); } return buffer ; } Memory Deallocation Even though the memory available on the heap is larger than the stack, it is not unlimited, and therefore we should still use the memory judiciously. In particular, after we are done using the memory allocated to us, we should call the method free , passing in the pointer the memory region allocated, to have the memory region deallocated, returned back to the OS to be reused by others. A common bug is for a programmer to access a memory that has been freed. This would cause strange behaviors, possible crashes in random places since we will be accessing memory that is being used by others. It is a good practice to set the pointer to NULL after free -ing the memory region so that we do not accidentally use it. free(buffer); buffer = NULL; Another common bug is for programmers to request memory via malloc or related functions, but forgot to free it back to the OS. As a result, as the program runs, it starts to hog the memory and the system will become slower and slower. This bug is known as memory leak . Another possible bug is for programmers to change the pointer to the region of memory allocated. For instance, long *buffer = calloc(how_many, sizeof(long)); long x; buffer = &x; After we execute the code such as the above, the pointer buffer will point to something new, and there is no longer a pointer pointing to allocate memory. The memory allocated becomes unreachable, and therefore we can no longer free it! In CS1010, from now on, you are to make sure that memory that is allocated via malloc and related functions are free after it is used, including those allocated in CS1010 I/O library. The API documentation tells you what are the values returned by the library that should be deallocated by the caller via free . Problem Set Problem Set 18.1 Draw the call stack and the heap, showing what happened when we run the following code: void foo ( long * y , long * z ) { y [ 0 ] = - 7 ; y [ 1 ] = - 8 ; z [ 0 ] = 4 ; z [ 1 ] = 5 ; } int main () { long y [ 2 ] = { 1 , 2 }; long * z = calloc ( 2 , sizeof ( long )); z [ 0 ] = y [ 0 ]; z [ 1 ] = y [ 1 ]; foo ( y , z ); } Problem Set 18.2 Read the man page for the function realloc and explain what does it do. Can you come up with a situation where it could be useful?","title":"18. Heap"},{"location":"18-heap.html#unit-18-heap","text":"We have already seen what a call stack is and how call stack works in Unit 13 . There is another important area of memory used by our programs, called the heap . Recall that a variable allocated on the stack has two properties: Its lifetime is the same as the lifetime of the function the variable is declared in. The memory allocation and deallocation are automatic. For stack, the memory is allocated automatically when the function is called and deallocated automatically as soon as the function exits. For this reason, such a variable is sometimes called automatic variable, or auto variable for short.","title":"Unit 18: Heap"},{"location":"18-heap.html#variables-on-heap","text":"The memory allocation on the heap can be done automatically or manually. For variables allocated on the heap, its lifetime is either the same as the lifetime of the whole programme. Example of such a variable is a global variable -- a variable that is declared outside of any function and can be read or write anywhere in the program. We have banned the use of global variables in CS1010. Using global variable makes your code hard to understand or reason about: x = 1 ; foo (); // { x == ?? } Suppose x is a global variable, we cannot assert anything about the property of x after calling foo , since x can be modified by foo or any function it calls, even though we never pass x into foo . This is worse than passing an array as we have seen in Unit 17 !","title":"Variables on Heap"},{"location":"18-heap.html#manual-memory-allocation-deallocation","text":"Allocating memory on the heap, however, is useful if we want to allocate an array dynamically, i.e., not knowing what is the size of the array when we write the program. Often, we need an array whose size depends on the input from the user, such as reading a string or reading a sequence of numbers. We cannot use fixed length array unless we know for sure that the input size is limited, and we cannot use variable length array, since we may get a segfault if the array size is too big for the stack. The only viable solution is to allocate the array on the heap. The C standard library provides a few functions related to memory allocation on the heap. The header file for these functions is stdlib.h . We are interested in malloc and calloc . malloc (memory allocation) is declared as: void * malloc ( size_t size ); It takes in a parameter, size , which is the number of bytes of memory to be allocated and returns a pointer to the memory allocated if successful, or NULL otherwise. This is a general function so the type of pointer returned is void * rather than a pointer to a specific type. The type of size is size_t , which is a type defined in stdlib.h to represent the number of bytes in memory. The function calloc (clear allocation) is declared as: void * calloc ( size_t count , size_t size ); calloc allocates memory for count items, each of size number of bytes, in a contiguous region in the memory and initialize all bits in this memory region to 0. Except for the fact that calloc initializes the bits to 0, calloc(count, size) is the same as malloc(count * size) . We have seen in Unit 5 that the number of bytes needed to represent a type depends on the platform. Suppose we want to allocate enough memory for, say, 10 long values, how do we know how many bytes are needed? A long can be 4 bytes on some platforms, 8 bytes on others. For this purpose, C provides a sizeof operator, that returns the number of bytes needed for a type or a variable. So, to allocate memory for 10 long values, we say: long * array = malloc ( 10 * sizeof ( long )); The CS1010 I/O library, internally, allocates memory on the heap so that we can read in words, lines, or arrays of arbitrary length. The following shows the example of how cs1010_read_long_array is implemented with calloc . long * cs1010_read_long_array ( int how_many ) { long * buffer = calloc ( how_many , sizeof ( long )); if ( buffer == NULL ) { return NULL ; } for ( int i = 0 ; i < how_many ; i += 1 ) { buffer [ i ] = cs1010_read_long (); } return buffer ; }","title":"Manual Memory Allocation / Deallocation"},{"location":"18-heap.html#memory-deallocation","text":"Even though the memory available on the heap is larger than the stack, it is not unlimited, and therefore we should still use the memory judiciously. In particular, after we are done using the memory allocated to us, we should call the method free , passing in the pointer the memory region allocated, to have the memory region deallocated, returned back to the OS to be reused by others. A common bug is for a programmer to access a memory that has been freed. This would cause strange behaviors, possible crashes in random places since we will be accessing memory that is being used by others. It is a good practice to set the pointer to NULL after free -ing the memory region so that we do not accidentally use it. free(buffer); buffer = NULL; Another common bug is for programmers to request memory via malloc or related functions, but forgot to free it back to the OS. As a result, as the program runs, it starts to hog the memory and the system will become slower and slower. This bug is known as memory leak . Another possible bug is for programmers to change the pointer to the region of memory allocated. For instance, long *buffer = calloc(how_many, sizeof(long)); long x; buffer = &x; After we execute the code such as the above, the pointer buffer will point to something new, and there is no longer a pointer pointing to allocate memory. The memory allocated becomes unreachable, and therefore we can no longer free it! In CS1010, from now on, you are to make sure that memory that is allocated via malloc and related functions are free after it is used, including those allocated in CS1010 I/O library. The API documentation tells you what are the values returned by the library that should be deallocated by the caller via free .","title":"Memory Deallocation"},{"location":"18-heap.html#problem-set","text":"","title":"Problem Set"},{"location":"18-heap.html#problem-set-181","text":"Draw the call stack and the heap, showing what happened when we run the following code: void foo ( long * y , long * z ) { y [ 0 ] = - 7 ; y [ 1 ] = - 8 ; z [ 0 ] = 4 ; z [ 1 ] = 5 ; } int main () { long y [ 2 ] = { 1 , 2 }; long * z = calloc ( 2 , sizeof ( long )); z [ 0 ] = y [ 0 ]; z [ 1 ] = y [ 1 ]; foo ( y , z ); }","title":"Problem Set 18.1"},{"location":"18-heap.html#problem-set-182","text":"Read the man page for the function realloc and explain what does it do. Can you come up with a situation where it could be useful?","title":"Problem Set 18.2"},{"location":"19-md-array.html","text":"Unit 19: Multi-Dimensional Arrays At the beginning of this unit, we say that an array can hold one or more values of some type T T . In fact, T T can also be an array. So, we can have an array of array of long , for instance. long matrix[10][20]; Here, we have an array of 10 elements, and each element is an array of 20 long values. When we access the elements in the array, we can use the notation matrix[i][j] (which is actually (matrix[i])[j] ). Such an array is called a two-dimensional array, or 2D array. We can have a 3D array, 4D array, and so on. We have seen three types of arrays. On the stack, we have fixed length array and variable length array. On the heap, we have dynamically allocated arrays. A 2D array can mix different types of array. Since we discourage the use of variable length array, we will focus on fixed-length arrays and dynamically allocated arrays only. Fixed Length 2D Array The example matrix above is a fixed length array. In the memory, a continuous space of 200 long values have been allocated, and we can visualize this is having 10 rows of long array, each array contains 20 columns of long values. With array decay, when we use the first level index of the array, matrix[i] , this is equivalent to &matrix[i][0] (the address of the first element in matrix[i]), and it has the type long * . Thus, if we want to pass individulal row of a 2D array into a function, we have two options for parameters declaration: void bar(long num_of_cols, long* matrix_row) { .. } void bar(long num_of_cols, long matrix_row[]) { .. } This is similar to a 1D array since matrix[i] is a 1D array. We can then invoke the function bar like: bar ( 20 , matrix [ i ]); Things get a bit tricky when we want to pass a 2D array into a function. By array decay, when we use the array name matrix , it is equivalent to &matrix[0] , which is the address of the first element in matrix , which is actually the address of an array of 20 long . We can declara the parameter for a function using either one of the following: void qux(long num_of_rows, long num_of_cols, long (* matrix_row)[20]) { .. } void qux(long num_of_rows, long num_of_cols, long matrix_row[][20]) { .. } and call it as: qux ( 10 , 20 , matrix ); Note the parenthesis in the declaration of long (* matrix_row)[20] . This declaration is different from long* matrix_row[20] (which is actually long *(matrix_row[20]) Let's decipher this: long *(matrix_row[20]) actually means matrix_row is an array of 20 pointers to long values. long (* matrix_row)[20] actually means matrix_row is a pointer to an array of 20 long values. It is also important to note that, we cannot omit the number 20 in the [] since it is part of the type information. A pointer to an array of 20 long values is treated as a different type than a pointer to an array of 19 long values in C. Fixed Size Array of Dynamically Allocated Array Suppose that we know only one of the dimension of the array in advanced, but not the other dimension. We can allocate a fixed length array for the known dimension, and allocate the other dimension dynamically using calloc . We can declare an array like this: double * buckets [ 10 ]; long num_of_cols = cs1010_read_long (); for ( long i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( double )); } Here, bucket is a 1D array of 10 pointers to long . So, we can easily pass bucket to a function just like any other 1D array: void baz(long num_of_rows, long num_of_cols, long **bucket) void baz(long num_of_rows, long num_of_cols, long *bucket[]) Access such individual elements in such type of array is no different from accessing a fixed length 2D array: we use bucket[i][j] . Remember to free the allocated memory after we are done: for ( long i = 0 ; i < 10 ; i += 1 ) { free ( buckets [ i ]); } Dynamically Size 2D Array Suppose that we do not know both dimensions in advanced, then we can allocate both dimensions of the array dynamically on the heap. double ** canvas ; long num_of_rows = cs1010_read_long (); long num_of_cols = cs1010_read_long (); canvas = calloc ( num_of_rows , sizeof ( double * )); for ( long i = 0 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = calloc ( num_of_cols , sizeof ( double )); } Passing such array into a function is no different from a 2D array where only one dimension is dynamically allocated above. Remember to free the allocated memory for both dimension after we are done: for ( long i = 0 ; long i < num_of_rows ; i += 1 ) { free ( canvas [ i ]); } free ( canvas ); Note that during deallocation of memory, we need to do it in the reverse order of memory allocation. If we call free(canvas) first, we are no longer guaranteed to be able to access canvas[i] with the correct pointers inside, so calling free(canvas[i]) after free(canvas) might lead to an error. Jagged Array One advantage of using a dynamically allocated array is that it allows a jagged 2D array, where each row has a different size. The example below allocate memory for a 2D array that is shaped like a half-square: the first row has one element, second row two elements, third row three, and so on. double * half_square [ 10 ]; for ( long i = 0 ; i < 10 ; i += 1 ) { half_square [ i ] = calloc ( i + 1 , sizeof ( double )); } Initializing a Multidimensional Array Just like a 1D-array, we can initialize a multi-dimensional array with initializers during declaration: long matrix [ 3 ][ 3 ] = { { 1 , 0 , - 1 }, { - 1 , 1 , 0 }, { 0 , - 1 , 1 } }; Note that we use nested { and } here. There are other variations to the syntax above, which you may read up on your own if you are interested as we do not need to write complex initializers for multi-dimensional arrays that often. Problem Set Problem 19.1 Write two functions described below. Show how you would declare the parameters to each function and how you would call each function. a) Write a function add that performs 3x3 matrix addition. The function should operate on 3x3 matrices of long , takes in three parameters, the first two are the operands for addition and the third is the result. b) Write a function multiply that performs 3x3 matrix multiplication. The function should operate on 3x3 matrices of long , takes in three parameters, the first two are the operands for multiplication and the third is the result. Problem 19.2 We need to represent the distance in km between every major cities in the world. Let's label every city with a number, ranging from 0 .. n-1 n-1 , where n n is the number of cities. The distance between city i i and j j is the same as the distance between city j j and i i . The distance can be represented with long . Explain how you would represent this information using jagged two-dimensional array in C efficiently. We have information of a few thousand cities to store. Explain how you would write a function long dist(long **d, long i, long j) to retrieve the distance between any two city i i and j j . Appendix: Complete Code from Lecture include \"cs1010.h\" void print_row ( long ncols , long row []) { for ( long j = 0 ; j < ncols ; j += 1 ) { cs1010_print_long ( row [ j ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void matrix_print ( long nrows , long ncols , long ( * matrix )[ 20 ]) { for ( long i = 0 ; i < nrows ; i += 1 ) { print_row ( ncols , matrix [ i ]); } } int main () { long matrix [ 3 ][ 20 ] = { { 1 , 0 , 0 }, { 0 , 1 , 0 }, { 0 , 0 , 1 } }; matrix_print ( 3 , 3 , matrix ); } #include \"cs1010.h\" void print_row ( long ncols , long row []) { for ( long j = 0 ; j < ncols ; j += 1 ) { cs1010_print_long ( row [ j ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void print ( long nrows , long ncols , long * matrix [ 10 ]) { for ( long i = 0 ; i < nrows ; i += 1 ) { print_row ( ncols , matrix [ i ]); } } int main () { long * buckets [ 10 ]; long num_of_cols = cs1010_read_long (); for ( long i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( long )); } print ( 10 , num_of_cols , buckets ); for ( long i = 0 ; i < 10 ; i += 1 ) { free ( buckets [ i ]); } } #include \"cs1010.h\" void print_row ( long ncols , long row []) { for ( long j = 0 ; j < ncols ; j += 1 ) { cs1010_print_long ( row [ j ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void print ( long nrows , long ncols , long * matrix [ 10 ]) { for ( long i = 0 ; i < nrows ; i += 1 ) { print_row ( ncols , matrix [ i ]); } } int main () { long ** canvas ; long num_of_rows = cs1010_read_long (); long num_of_cols = cs1010_read_long (); canvas = calloc ( num_of_rows , sizeof ( long * )); for ( long i = 0 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = calloc ( i + 1 , sizeof ( long )); } // print(num_of_rows, num_of_cols, canvas); for ( long i = 0 ; i < num_of_rows ; i += 1 ) { free ( canvas [ i ]); } free ( canvas ); }","title":"19. Multidimensional Array"},{"location":"19-md-array.html#unit-19-multi-dimensional-arrays","text":"At the beginning of this unit, we say that an array can hold one or more values of some type T T . In fact, T T can also be an array. So, we can have an array of array of long , for instance. long matrix[10][20]; Here, we have an array of 10 elements, and each element is an array of 20 long values. When we access the elements in the array, we can use the notation matrix[i][j] (which is actually (matrix[i])[j] ). Such an array is called a two-dimensional array, or 2D array. We can have a 3D array, 4D array, and so on. We have seen three types of arrays. On the stack, we have fixed length array and variable length array. On the heap, we have dynamically allocated arrays. A 2D array can mix different types of array. Since we discourage the use of variable length array, we will focus on fixed-length arrays and dynamically allocated arrays only.","title":"Unit 19: Multi-Dimensional Arrays"},{"location":"19-md-array.html#fixed-length-2d-array","text":"The example matrix above is a fixed length array. In the memory, a continuous space of 200 long values have been allocated, and we can visualize this is having 10 rows of long array, each array contains 20 columns of long values. With array decay, when we use the first level index of the array, matrix[i] , this is equivalent to &matrix[i][0] (the address of the first element in matrix[i]), and it has the type long * . Thus, if we want to pass individulal row of a 2D array into a function, we have two options for parameters declaration: void bar(long num_of_cols, long* matrix_row) { .. } void bar(long num_of_cols, long matrix_row[]) { .. } This is similar to a 1D array since matrix[i] is a 1D array. We can then invoke the function bar like: bar ( 20 , matrix [ i ]); Things get a bit tricky when we want to pass a 2D array into a function. By array decay, when we use the array name matrix , it is equivalent to &matrix[0] , which is the address of the first element in matrix , which is actually the address of an array of 20 long . We can declara the parameter for a function using either one of the following: void qux(long num_of_rows, long num_of_cols, long (* matrix_row)[20]) { .. } void qux(long num_of_rows, long num_of_cols, long matrix_row[][20]) { .. } and call it as: qux ( 10 , 20 , matrix ); Note the parenthesis in the declaration of long (* matrix_row)[20] . This declaration is different from long* matrix_row[20] (which is actually long *(matrix_row[20]) Let's decipher this: long *(matrix_row[20]) actually means matrix_row is an array of 20 pointers to long values. long (* matrix_row)[20] actually means matrix_row is a pointer to an array of 20 long values. It is also important to note that, we cannot omit the number 20 in the [] since it is part of the type information. A pointer to an array of 20 long values is treated as a different type than a pointer to an array of 19 long values in C.","title":"Fixed Length 2D Array"},{"location":"19-md-array.html#fixed-size-array-of-dynamically-allocated-array","text":"Suppose that we know only one of the dimension of the array in advanced, but not the other dimension. We can allocate a fixed length array for the known dimension, and allocate the other dimension dynamically using calloc . We can declare an array like this: double * buckets [ 10 ]; long num_of_cols = cs1010_read_long (); for ( long i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( double )); } Here, bucket is a 1D array of 10 pointers to long . So, we can easily pass bucket to a function just like any other 1D array: void baz(long num_of_rows, long num_of_cols, long **bucket) void baz(long num_of_rows, long num_of_cols, long *bucket[]) Access such individual elements in such type of array is no different from accessing a fixed length 2D array: we use bucket[i][j] . Remember to free the allocated memory after we are done: for ( long i = 0 ; i < 10 ; i += 1 ) { free ( buckets [ i ]); }","title":"Fixed Size Array of Dynamically Allocated Array"},{"location":"19-md-array.html#dynamically-size-2d-array","text":"Suppose that we do not know both dimensions in advanced, then we can allocate both dimensions of the array dynamically on the heap. double ** canvas ; long num_of_rows = cs1010_read_long (); long num_of_cols = cs1010_read_long (); canvas = calloc ( num_of_rows , sizeof ( double * )); for ( long i = 0 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = calloc ( num_of_cols , sizeof ( double )); } Passing such array into a function is no different from a 2D array where only one dimension is dynamically allocated above. Remember to free the allocated memory for both dimension after we are done: for ( long i = 0 ; long i < num_of_rows ; i += 1 ) { free ( canvas [ i ]); } free ( canvas ); Note that during deallocation of memory, we need to do it in the reverse order of memory allocation. If we call free(canvas) first, we are no longer guaranteed to be able to access canvas[i] with the correct pointers inside, so calling free(canvas[i]) after free(canvas) might lead to an error.","title":"Dynamically Size 2D Array"},{"location":"19-md-array.html#jagged-array","text":"One advantage of using a dynamically allocated array is that it allows a jagged 2D array, where each row has a different size. The example below allocate memory for a 2D array that is shaped like a half-square: the first row has one element, second row two elements, third row three, and so on. double * half_square [ 10 ]; for ( long i = 0 ; i < 10 ; i += 1 ) { half_square [ i ] = calloc ( i + 1 , sizeof ( double )); }","title":"Jagged Array"},{"location":"19-md-array.html#initializing-a-multidimensional-array","text":"Just like a 1D-array, we can initialize a multi-dimensional array with initializers during declaration: long matrix [ 3 ][ 3 ] = { { 1 , 0 , - 1 }, { - 1 , 1 , 0 }, { 0 , - 1 , 1 } }; Note that we use nested { and } here. There are other variations to the syntax above, which you may read up on your own if you are interested as we do not need to write complex initializers for multi-dimensional arrays that often.","title":"Initializing a Multidimensional Array"},{"location":"19-md-array.html#problem-set","text":"","title":"Problem Set"},{"location":"19-md-array.html#problem-191","text":"Write two functions described below. Show how you would declare the parameters to each function and how you would call each function. a) Write a function add that performs 3x3 matrix addition. The function should operate on 3x3 matrices of long , takes in three parameters, the first two are the operands for addition and the third is the result. b) Write a function multiply that performs 3x3 matrix multiplication. The function should operate on 3x3 matrices of long , takes in three parameters, the first two are the operands for multiplication and the third is the result.","title":"Problem 19.1"},{"location":"19-md-array.html#problem-192","text":"We need to represent the distance in km between every major cities in the world. Let's label every city with a number, ranging from 0 .. n-1 n-1 , where n n is the number of cities. The distance between city i i and j j is the same as the distance between city j j and i i . The distance can be represented with long . Explain how you would represent this information using jagged two-dimensional array in C efficiently. We have information of a few thousand cities to store. Explain how you would write a function long dist(long **d, long i, long j) to retrieve the distance between any two city i i and j j .","title":"Problem 19.2"},{"location":"19-md-array.html#appendix-complete-code-from-lecture","text":"include \"cs1010.h\" void print_row ( long ncols , long row []) { for ( long j = 0 ; j < ncols ; j += 1 ) { cs1010_print_long ( row [ j ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void matrix_print ( long nrows , long ncols , long ( * matrix )[ 20 ]) { for ( long i = 0 ; i < nrows ; i += 1 ) { print_row ( ncols , matrix [ i ]); } } int main () { long matrix [ 3 ][ 20 ] = { { 1 , 0 , 0 }, { 0 , 1 , 0 }, { 0 , 0 , 1 } }; matrix_print ( 3 , 3 , matrix ); } #include \"cs1010.h\" void print_row ( long ncols , long row []) { for ( long j = 0 ; j < ncols ; j += 1 ) { cs1010_print_long ( row [ j ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void print ( long nrows , long ncols , long * matrix [ 10 ]) { for ( long i = 0 ; i < nrows ; i += 1 ) { print_row ( ncols , matrix [ i ]); } } int main () { long * buckets [ 10 ]; long num_of_cols = cs1010_read_long (); for ( long i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( long )); } print ( 10 , num_of_cols , buckets ); for ( long i = 0 ; i < 10 ; i += 1 ) { free ( buckets [ i ]); } } #include \"cs1010.h\" void print_row ( long ncols , long row []) { for ( long j = 0 ; j < ncols ; j += 1 ) { cs1010_print_long ( row [ j ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void print ( long nrows , long ncols , long * matrix [ 10 ]) { for ( long i = 0 ; i < nrows ; i += 1 ) { print_row ( ncols , matrix [ i ]); } } int main () { long ** canvas ; long num_of_rows = cs1010_read_long (); long num_of_cols = cs1010_read_long (); canvas = calloc ( num_of_rows , sizeof ( long * )); for ( long i = 0 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = calloc ( i + 1 , sizeof ( long )); } // print(num_of_rows, num_of_cols, canvas); for ( long i = 0 ; i < num_of_rows ; i += 1 ) { free ( canvas [ i ]); } free ( canvas ); }","title":"Appendix: Complete Code from Lecture"},{"location":"20-macro.html","text":"Unit 20: C Preprocessor: Constants and Macros In this unit, we are going to delve deeper into the C compilation process, focusing on a step called preprocessing . This step is usually the first step in the compilation process. Preprocessing is, in essence, a text processing and substitution process, and so it is not C specific. This process is used by C to implement, among other things: (i) file inclusion, (ii) macro, and (iii) conditional compilation. A C preprocessor processes all the lines in the input file that starts with a preprocessor directive . A directive starts with the letter # . You have seen two of such directives, #include to include a file, and #define to define a constant. #include The #include directive has the format #include <filename> or #include \"filename\" When the C preprocessor sees this directive, it reads the file specified by the given filename, and inserts the text, line-by-line, from this file, into the current file, in the location where the line #include occurs. Any C preprocessor directive in the included file is recursively processed. #define Constant We have seen how we can use #define to define constant values in our code in our exercises and assignments. We should avoid hardcoding constant values (also called magic numbers ) in our code so that our code can be easily changed when the requirement of our program has changed. Take this code, for instance, from Taxi: double metered_fare ( long distance ) { double fare = 3.40 ; distance -= 1000 ; if ( distance <= 0 ) { return fare ; } if ( distance <= 9200 ) { fare += 0.22 * ( distance / 400 ); if ( distance % 400 > 0 ) { fare += 0.22 ; } } else { fare += 0.22 * ( 9200 / 400 ); } distance -= 9200 ; if ( distance <= 0 ) { return fare ; } fare += 0.22 * ( distance / 350 ); if ( distance % 350 > 0 ) { fare += 0.22 ; } return fare ; } In my answer posted, I have used many hardcoded values. Suppose one day, the taxi fare changes (and that day will come). Perhaps the base fare is more, perhaps the distance threshold is shorter. We will have to change the code above to calculate the new fare. By littering the code above with hardcoded values, the code is difficult and error-prone to change. Suppose we rewrite the code as: #define BASE_FARE 3.40 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.22 #define TIER_ONE_DISTANCE 400 #define TIER_ONE_LIMIT 9200 #define TIER_TWO_FARE 0.22 #define TIER_TWO_DISTANCE 350 double metered_fare ( long distance ) { double fare = BASE_FARE ; distance -= BASE_DISTANCE ; if ( distance <= 0 ) { return fare ; } if ( distance <= TIER_ONE_LIMIT ) { fare += TIER_ONE_FARE * ( distance / TIER_ONE_DISTANCE ); if ( distance % TIER_ONE_DISTANCE > 0 ) { fare += TIER_ONE_FARE ; } } else { fare += TIER_ONE_FARE * ( TIER_ONE_LIMIT / TIER_ONE_DISTANCE ); } distance -= TIER_ONE_LIMIT ; if ( distance <= 0 ) { return fare ; } fare += TIER_TWO_FARE * ( distance / TIER_TWO_DISTANCE ); if ( distance % TIER_TWO_DISTANCE > 0 ) { fare += TIER_TWO_FARE ; } return fare ; } We have factored out all the hardcoded values into constants we defined. It does make the code a bit harder to read, but now, it is super easy to change. Suppose, one day, the base taxi fare is decreased to $3.20, and then $0.20 per 500m subsequently up to 10km, and $0.15 per 600m thereafter, we only need to change: #define BASE_FARE 3.20 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.20 #define TIER_ONE_DISTANCE 500 #define TIER_ONE_LIMIT 10000 #define TIER_TWO_FARE 0.15 #define TIER_TWO_DISTANCE 600 The logic of the code remains the same. The #define directive should be followed an identifier and a token . The token may contain space but must be terminated by a newline. In the example above, BASE_FARE is the identifier, and 3.20 is the token. When the C preprocessor sees the #define directive, it replaces all instances of the identifier in the file with the token. This is merely a text substitution operation. Example: Consider the example below. Suppose we have three files: /** * @file: a.c */ #include \"b.h\" int main () { foo ( PI ); } /** * @file: b.h */ #include \"c.h\" #define PI 3.1415926 /** * @file: c.h */ void foo ( double x ); Let's see what happen when we run C pre-processor on the file a.c . We can ask clang to stop the compilation process after the pre-processing phase, using the flag -E . clang -E a.c The command will produce the output after C pre-processing: # 1 \"a.c\" # 1 \"<built-in>\" 1 # 1 \"<built-in>\" 3 # 360 \"<built-in>\" 3 # 1 \"<command line>\" 1 # 1 \"<built-in>\" 2 # 1 \"a.c\" 2 # 1 \"./b.h\" 1 # 1 \"./c.h\" 1 void foo ( double x ); # 6 \"./b.h\" 2 # 5 \"a.c\" 2 int main () { foo ( 3.1415926 ); } The lines start with # are metadata meant for the compiler. If we ignore those, we can see that the file a.c has been expanded into void foo ( double x ); int main () { foo ( 3.1415926 ); } Line 1 above is included from file c.h , which in turn is included from file b.h . The C pre-processor also substitutes the text PI with the text 3.1415926 , as the identifier PI is defined in b.h . #define Macro The #define directive can be used for a more flexible and powerful text substitution feature called macro . A macro is a block of code that is given an identifying name and is substituted and expanded during pre-processing. For instance, we can write the following: #define SQUARE(x) x*x This macro is named SQUARE , just like a function we defined in Lecture 3 and it takes in a parameter x as well. But that's where the similarity ends. There are a few important differences between macros and functions in C: Macros are not called. They are only substituted during preprocessing phase which performs text processing on the source code. Macros have no information about types. It has no return type and the parameters have no type. Take the example below. The file: #define SQUARE(x) x*x #define PI 3.1415926 int main () { double radius = 4.0 ; cs1010_print_double ( PI * SQUARE ( radius )); } Get expanded into: int main () { double radius = 4.0 ; cs1010_print_double ( 3.1415926 * radius * radius ); } Let's look at another example. We have seen how to write a function that swaps two the value of variables. The one we wrote swaps two double . If we want to swap two long , or two char * , etc, we will need to write a new function for each one. Let's write a generic macro that does swapping for any type. #define SWAP(T, x, y) {\\ T temp;\\ temp = x;\\ x = y;\\ y = temp;\\ } int main (){ long x = 3.0 ; long y = - 1.0 ; SWAP ( long , x , y ); } The macro SWAP takes in three parameters, the first is the type T, the second and the third are the variables to be swapped. This macro definition spans multiple lines. Since C preprocessor ends the definition of a macro with the end of the line, we add a backslash character to \"escape\" the newline, telling the preprocessor not to treat the newline as the end of the macro definition. The code above gets expanded to: int main (){ long x = 3.0 ; long y = - 1.0 ; { long temp ; temp = x ; x = y ; y = temp ;}; } Pitfalls and Best Practices It is easy to forget that macro is doing simple text substitution without an understanding of C syntax. When we write macros, we should always guard against improper usage of macros. Let's consider this: #define SQUARE(x) x*x SQUARE ( radius + 2 ) When the preprocessor substitutes the macro SQUARE , it replaces all instances of the text x with the text radius + 2 . After substitution, we get radius + 2*radius + 2 ! This is not what we expected. To prevent such unexpected expansion, we should always add parenthesis to our macro expression: #define SQUARE(x) ((x)*(x)) So now, SQUARE(radius + 2) gets expanded into ((radius + 2)*(radius + 2)) , which is what we would expect when we call SQUARE . To help the readers of your code know that you are referencing a macro rather than a function, all macros should be written with uppercase letters. Problem Set 20 Problem 20.1 a) Consider the macro below: #define MIN(a,b) a < b ? a : b long i = MIN ( 10 , 20 ); long j = MIN ( 10 , 20 ) + 1 ; What are the values for i and j after executing the above? b) #define MIN(a,b) a < b ? a : b long i = 10 ; long j = 20 ; long k = MIN ( j , i ++ ); What are the values of i and k after executing the above? Problem 20.2 Suppose we write our SWAP macro without the opening and closing brackets: #define SWAP(T, x, y) T temp = x;\\ x = y;\\ y = temp; What could go wrong?","title":"20. C Pre-processing"},{"location":"20-macro.html#unit-20-c-preprocessor-constants-and-macros","text":"In this unit, we are going to delve deeper into the C compilation process, focusing on a step called preprocessing . This step is usually the first step in the compilation process. Preprocessing is, in essence, a text processing and substitution process, and so it is not C specific. This process is used by C to implement, among other things: (i) file inclusion, (ii) macro, and (iii) conditional compilation. A C preprocessor processes all the lines in the input file that starts with a preprocessor directive . A directive starts with the letter # . You have seen two of such directives, #include to include a file, and #define to define a constant.","title":"Unit 20: C Preprocessor: Constants and Macros"},{"location":"20-macro.html#include","text":"The #include directive has the format #include <filename> or #include \"filename\" When the C preprocessor sees this directive, it reads the file specified by the given filename, and inserts the text, line-by-line, from this file, into the current file, in the location where the line #include occurs. Any C preprocessor directive in the included file is recursively processed.","title":"#include"},{"location":"20-macro.html#define-constant","text":"We have seen how we can use #define to define constant values in our code in our exercises and assignments. We should avoid hardcoding constant values (also called magic numbers ) in our code so that our code can be easily changed when the requirement of our program has changed. Take this code, for instance, from Taxi: double metered_fare ( long distance ) { double fare = 3.40 ; distance -= 1000 ; if ( distance <= 0 ) { return fare ; } if ( distance <= 9200 ) { fare += 0.22 * ( distance / 400 ); if ( distance % 400 > 0 ) { fare += 0.22 ; } } else { fare += 0.22 * ( 9200 / 400 ); } distance -= 9200 ; if ( distance <= 0 ) { return fare ; } fare += 0.22 * ( distance / 350 ); if ( distance % 350 > 0 ) { fare += 0.22 ; } return fare ; } In my answer posted, I have used many hardcoded values. Suppose one day, the taxi fare changes (and that day will come). Perhaps the base fare is more, perhaps the distance threshold is shorter. We will have to change the code above to calculate the new fare. By littering the code above with hardcoded values, the code is difficult and error-prone to change. Suppose we rewrite the code as: #define BASE_FARE 3.40 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.22 #define TIER_ONE_DISTANCE 400 #define TIER_ONE_LIMIT 9200 #define TIER_TWO_FARE 0.22 #define TIER_TWO_DISTANCE 350 double metered_fare ( long distance ) { double fare = BASE_FARE ; distance -= BASE_DISTANCE ; if ( distance <= 0 ) { return fare ; } if ( distance <= TIER_ONE_LIMIT ) { fare += TIER_ONE_FARE * ( distance / TIER_ONE_DISTANCE ); if ( distance % TIER_ONE_DISTANCE > 0 ) { fare += TIER_ONE_FARE ; } } else { fare += TIER_ONE_FARE * ( TIER_ONE_LIMIT / TIER_ONE_DISTANCE ); } distance -= TIER_ONE_LIMIT ; if ( distance <= 0 ) { return fare ; } fare += TIER_TWO_FARE * ( distance / TIER_TWO_DISTANCE ); if ( distance % TIER_TWO_DISTANCE > 0 ) { fare += TIER_TWO_FARE ; } return fare ; } We have factored out all the hardcoded values into constants we defined. It does make the code a bit harder to read, but now, it is super easy to change. Suppose, one day, the base taxi fare is decreased to $3.20, and then $0.20 per 500m subsequently up to 10km, and $0.15 per 600m thereafter, we only need to change: #define BASE_FARE 3.20 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.20 #define TIER_ONE_DISTANCE 500 #define TIER_ONE_LIMIT 10000 #define TIER_TWO_FARE 0.15 #define TIER_TWO_DISTANCE 600 The logic of the code remains the same. The #define directive should be followed an identifier and a token . The token may contain space but must be terminated by a newline. In the example above, BASE_FARE is the identifier, and 3.20 is the token. When the C preprocessor sees the #define directive, it replaces all instances of the identifier in the file with the token. This is merely a text substitution operation.","title":"#define Constant"},{"location":"20-macro.html#example","text":"Consider the example below. Suppose we have three files: /** * @file: a.c */ #include \"b.h\" int main () { foo ( PI ); } /** * @file: b.h */ #include \"c.h\" #define PI 3.1415926 /** * @file: c.h */ void foo ( double x ); Let's see what happen when we run C pre-processor on the file a.c . We can ask clang to stop the compilation process after the pre-processing phase, using the flag -E . clang -E a.c The command will produce the output after C pre-processing: # 1 \"a.c\" # 1 \"<built-in>\" 1 # 1 \"<built-in>\" 3 # 360 \"<built-in>\" 3 # 1 \"<command line>\" 1 # 1 \"<built-in>\" 2 # 1 \"a.c\" 2 # 1 \"./b.h\" 1 # 1 \"./c.h\" 1 void foo ( double x ); # 6 \"./b.h\" 2 # 5 \"a.c\" 2 int main () { foo ( 3.1415926 ); } The lines start with # are metadata meant for the compiler. If we ignore those, we can see that the file a.c has been expanded into void foo ( double x ); int main () { foo ( 3.1415926 ); } Line 1 above is included from file c.h , which in turn is included from file b.h . The C pre-processor also substitutes the text PI with the text 3.1415926 , as the identifier PI is defined in b.h .","title":"Example:"},{"location":"20-macro.html#define-macro","text":"The #define directive can be used for a more flexible and powerful text substitution feature called macro . A macro is a block of code that is given an identifying name and is substituted and expanded during pre-processing. For instance, we can write the following: #define SQUARE(x) x*x This macro is named SQUARE , just like a function we defined in Lecture 3 and it takes in a parameter x as well. But that's where the similarity ends. There are a few important differences between macros and functions in C: Macros are not called. They are only substituted during preprocessing phase which performs text processing on the source code. Macros have no information about types. It has no return type and the parameters have no type. Take the example below. The file: #define SQUARE(x) x*x #define PI 3.1415926 int main () { double radius = 4.0 ; cs1010_print_double ( PI * SQUARE ( radius )); } Get expanded into: int main () { double radius = 4.0 ; cs1010_print_double ( 3.1415926 * radius * radius ); } Let's look at another example. We have seen how to write a function that swaps two the value of variables. The one we wrote swaps two double . If we want to swap two long , or two char * , etc, we will need to write a new function for each one. Let's write a generic macro that does swapping for any type. #define SWAP(T, x, y) {\\ T temp;\\ temp = x;\\ x = y;\\ y = temp;\\ } int main (){ long x = 3.0 ; long y = - 1.0 ; SWAP ( long , x , y ); } The macro SWAP takes in three parameters, the first is the type T, the second and the third are the variables to be swapped. This macro definition spans multiple lines. Since C preprocessor ends the definition of a macro with the end of the line, we add a backslash character to \"escape\" the newline, telling the preprocessor not to treat the newline as the end of the macro definition. The code above gets expanded to: int main (){ long x = 3.0 ; long y = - 1.0 ; { long temp ; temp = x ; x = y ; y = temp ;}; }","title":"#define Macro"},{"location":"20-macro.html#pitfalls-and-best-practices","text":"It is easy to forget that macro is doing simple text substitution without an understanding of C syntax. When we write macros, we should always guard against improper usage of macros. Let's consider this: #define SQUARE(x) x*x SQUARE ( radius + 2 ) When the preprocessor substitutes the macro SQUARE , it replaces all instances of the text x with the text radius + 2 . After substitution, we get radius + 2*radius + 2 ! This is not what we expected. To prevent such unexpected expansion, we should always add parenthesis to our macro expression: #define SQUARE(x) ((x)*(x)) So now, SQUARE(radius + 2) gets expanded into ((radius + 2)*(radius + 2)) , which is what we would expect when we call SQUARE . To help the readers of your code know that you are referencing a macro rather than a function, all macros should be written with uppercase letters.","title":"Pitfalls and Best Practices"},{"location":"20-macro.html#problem-set-20","text":"","title":"Problem Set 20"},{"location":"20-macro.html#problem-201","text":"a) Consider the macro below: #define MIN(a,b) a < b ? a : b long i = MIN ( 10 , 20 ); long j = MIN ( 10 , 20 ) + 1 ; What are the values for i and j after executing the above? b) #define MIN(a,b) a < b ? a : b long i = 10 ; long j = 20 ; long k = MIN ( j , i ++ ); What are the values of i and k after executing the above?","title":"Problem 20.1"},{"location":"20-macro.html#problem-202","text":"Suppose we write our SWAP macro without the opening and closing brackets: #define SWAP(T, x, y) T temp = x;\\ x = y;\\ y = temp; What could go wrong?","title":"Problem 20.2"},{"location":"21-assert.html","text":"Unit 21: The assert Macro You have learned what is an assertion and how it can help you to reason about your programs. Previously we have only seen assertion as a commenting tool, to comment on certain properties that are guaranteed to be true at a certain point of a program. Now, we will make the concept of assertion even more powerful -- we can cause our program to throw an error if an assertion is ever violated. This way, we can tell immediately if certain assumptions or properties that we made in our code are violated. C provides a macro called assert() (in the header file assert.h ) which takes in a logical expression. This logical expression must always evaluate to true when assert is used. Otherwise, assert will throw an error, giving the file and the line number where the error occurred. Using assertions and the assert macro can help us pinpoint exactly where our code goes wrong, quickly. Take the following code, for instance: long nrows = 20 ; long ncols = 10 ; long matrix [ nrows ][ ncols ]; : matrix [ i ][ j ] = - 1 ; : Remember our rule: we can only access memory that has been allocated to us. So we need to make sure that i and j must be within the correct range. We can add an assert statement to check that i and j are correct. assert ( i >= 0 && i < nrows && j >= 0 && j < ncols ); matrix [ i ][ j ] = - 1 ; If the assertion fails, the program will exit and print something like this: assert : assert . c : 12 : int main () : Assertion ` i >= 0 && i < nrows && j >= 0 && j < ncols ' failed . Aborted So that we know on which line in our code the assertion has failed -- in this case, which is the line in our code we have tried to access memory that does not belong to us. As you reason about your code, sprinkle assert liberally in your code so that, if you are wrong about your reasoning or you make a careless mistake in your code, assert will spot that for you. Problem Set 21 Problem 21.1 Consider the code: void foo ( long x ) { if ( x % 2 == 0 ) { // do something } else { assert ( x % 2 == 1 ); } } Would the assert in Line 5 above ever fail? Problem 21.2 Take your add.c from Assignment 3 and add as many assert as you code to your code.","title":"21. Assert"},{"location":"21-assert.html#unit-21-the-assert-macro","text":"You have learned what is an assertion and how it can help you to reason about your programs. Previously we have only seen assertion as a commenting tool, to comment on certain properties that are guaranteed to be true at a certain point of a program. Now, we will make the concept of assertion even more powerful -- we can cause our program to throw an error if an assertion is ever violated. This way, we can tell immediately if certain assumptions or properties that we made in our code are violated. C provides a macro called assert() (in the header file assert.h ) which takes in a logical expression. This logical expression must always evaluate to true when assert is used. Otherwise, assert will throw an error, giving the file and the line number where the error occurred. Using assertions and the assert macro can help us pinpoint exactly where our code goes wrong, quickly. Take the following code, for instance: long nrows = 20 ; long ncols = 10 ; long matrix [ nrows ][ ncols ]; : matrix [ i ][ j ] = - 1 ; : Remember our rule: we can only access memory that has been allocated to us. So we need to make sure that i and j must be within the correct range. We can add an assert statement to check that i and j are correct. assert ( i >= 0 && i < nrows && j >= 0 && j < ncols ); matrix [ i ][ j ] = - 1 ; If the assertion fails, the program will exit and print something like this: assert : assert . c : 12 : int main () : Assertion ` i >= 0 && i < nrows && j >= 0 && j < ncols ' failed . Aborted So that we know on which line in our code the assertion has failed -- in this case, which is the line in our code we have tried to access memory that does not belong to us. As you reason about your code, sprinkle assert liberally in your code so that, if you are wrong about your reasoning or you make a careless mistake in your code, assert will spot that for you.","title":"Unit 21: The assert Macro"},{"location":"21-assert.html#problem-set-21","text":"","title":"Problem Set 21"},{"location":"21-assert.html#problem-211","text":"Consider the code: void foo ( long x ) { if ( x % 2 == 0 ) { // do something } else { assert ( x % 2 == 1 ); } } Would the assert in Line 5 above ever fail?","title":"Problem 21.1"},{"location":"21-assert.html#problem-212","text":"Take your add.c from Assignment 3 and add as many assert as you code to your code.","title":"Problem 21.2"},{"location":"22-efficiency.html","text":"Unit 22: Efficiency We have been writing code and solving problems, focusing on producing the correct output and using the various construct of C language appropriately. Now, we will introduce a new criterion on writing code: efficiency . No Redundant Work Writing efficient code basically means that we should not write code that runs unnecessarily. In my comments on your Assignment 2 , I gave you an example where the same function is_prime has different implementations -- some runs very slowly, while some runs quickly. I reproduce them here: bool is_prime ( long n ) { bool is_prime = true ; for ( long i = 2 ; i <= n - 1 ; i ++ ) { if ( n % i == 0 ) { is_prime = false ; } } return is_prime ; } bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } In fact, on my machine, the slowest version of is_prime took ~100s, while the fast one runs ~3ms when invoked with is_prime(10000000001) . The time taken is five orders of magnitude difference! But there is no magic here, as we merely apply the following principle: \"No redundant work\" If you recall, we improve the efficiency of is_prime by (i) returning false as soon as we found a proof that the input is not a prime, and (ii) not checking for divisor that is redundant. Worst Case Performance The two techniques we employed above behave slightly differently. For (i), we opportunistically stop our computation once we know the answer when the input is not a prime. However, in the worst case , when the input is a prime, we still have to check through all n-2 n-2 divisor, from 2 up to n-1 n-1 , before we can conclude that the input is a prime. Thus, for (i), we make our program faster for certain inputs but in the worst case, we are not able to speed up the program. The second technique is more interesting and more fruitful. With a little math, we can show that we only need to check for the divisor up to \\sqrt{n} \\sqrt{n} . Here, we are improving the worst case performance of is_prime , so whether the input is a prime or not, we always have a speed up. How much is the speed up in the worst case? In the input above, with the original slow code, in the worst case I need to check through ~10,000,000,001 divisors. With the faster version, I only need to check ~ \\sqrt{10,000,000,001} \\sqrt{10,000,000,001} = ~10,000 divisors. That's where the five orders of magnitude speed up comes from. No Repetition The second principle to improving the efficiency of the program is that \"No repetition\" -- we should not repeat work that has been done before. Let's look at the example from earlier this semester, where you are asked to compute the range of a list. Recall that the range of a list is the absolute difference between the largest element and the smallest element. We use this problem to motivate the use of function, where we denote range(L, k) = |max(L, k) - min(L, k)| range(L, k) = |max(L, k) - min(L, k)| . If we are to implement this solution in C, however, we would end up scanning through the list twice: first to find the max, then to find the min. The example code from Lecture 7 has shown that we could easily just go through the list once, use call-by-reference to output both the max and the min if we are willing to forgo the notion of pure functions and function-as-a-black-box. In your midterm, you see another example where we can go through the list once to find the second largest element, instead of twice: first to find the max, then to find the next largest. The performance improvement for not scanning through a list (or an array) twice is modest at most. Let's look at another example where, by not repeating ourselves, we can gain significant performance improvement. Finding Fibonacci Numbers Recall from your Exercise 3, the Fibonacci sequence of numbers are numbers formed by adding the previous two numbers to form the next numbers. In other words, the i i -th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2) (i-2) -th, and the (i-1) (i-1) -th. Here is one way we can find the Fibonacci numbers with a loop: long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } long first = 1 ; long second = 1 ; long third = 1 ; for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } return third ; } To find the n n -th Fibonacci number, we take n n steps in a loop. Now, let's see the following elegant recursive solution: long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } return fib ( n - 1 ) + fib ( n - 2 ); } This solution is short and follows directly from the definition of Fibonacci numbers. Running this, however, reveals something very disturbing. Let's say we call fib(n) . This invocation in turns calls fib(n-1) and fib(n-2) . fib(n-1) then calls fib(n-2) and fib(n-3) . So, fib(n-2) will be called twice -- so we are repeating ourselves, violating the no repetition principles. In fact, we will invoke fib() a large number of times. Big-O Notation How do we characterize the number of times fib() is called? To answer this, we will introduce to you the Big-O notation. The Big-O function is a mathematical function that computer scientists use to characterize the time and space efficiency of an algorithm. There is a formal definition to Big-O, which interested students can find out by Googling, or you can wait until you take CS2040C and CS3230. In CS1010, we will introduce Big-O using the intuition that it is the \"rate of growth\" of a function. To motivate Big-O, let's consider how we can count the number of \"steps\" taken by an algorithm. Let's consider this again: for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } If we consider each of the fundamental operations: comparison, addition, and assignment, as a step, then we can see that, in each loop, there is one comparison ( i != n ), two additions ( i + 1 , third = first + second ), four assignments. So we have seven operations per loop, with a total of n-1 n-1 loops. So we have 7n - 7 7n - 7 operations. In addition, we also need to count for the assignment i = 2 and the additional comparison before we exit the loop ( i != n ). So, in total, we have 7n - 5 7n - 5 operations. As you can see, such detailed counting of the steps in tedious, and in fact, not very meaningful. For instance, we did not account for reading values from the memory and writing of values into the memory, the performance of which becomes dependant on the architecture underneath. To free us from such low-level accounting of the number of steps, let's focus on the big picture. No matter how we count the number of steps, in the end, it is a linear function of n n . In order words, the number of steps taken by the algorithm to compute Fibonacci in a loop grows linearly with n n . Using the Big-O notation, we say that it takes O(n) O(n) steps. Given a mathematical function with multiple terms, the Big-O of this function is obtained by dropping any multiplicative constants and all terms, except for the one with the highest rate of growth . For instance, O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4) O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4) . Due to this focus on the term with highest rate of growth, and not bothering about other terms or multiplicative constants, it becomes very convenient for us to expression the time efficiency of an algorithm with O() O() -- we no longer need to count the steps precisely but just focus on the number of times it takes to run the algorithm in terms of n n . Take the example of is_prime . The slow algorithm takes O(n) O(n) , the fast algorithm takes O(\\sqrt{n}) O(\\sqrt{n}) . Take another example: to find the range of a list, both algorithms, regardless of whether we are taking two passes or one pass, take O(n) O(n) time. Rate of Growth Given two functions f(n) f(n) and g(n) g(n) , how do we determine which one has a higher rate of growth? We say that f(n) f(n) grows faster than g(n) g(n) if we can find a n_0 n_0 , such that f(n) > cg(n) f(n) > cg(n) for all n \\ge n_0 n \\ge n_0 and for some constant c c . For instance, which one grows faster? f(n) = n^n f(n) = n^n or g(n) = 2^n g(n) = 2^n ? Pick n = 1 n = 1 , we have f(1) < g(1) f(1) < g(1) 1 . Pick n = 2 n = 2 , we have f(2) f(2) equals g(2) g(2) . Pick n = 3 n = 3 , we have $f(3) > g(3) g(3) now, and we can see that for any n > 3 n > 3 , n^n > 2^n n^n > 2^n , so we can conclude that f(n) f(n) grows faster than g(n) g(n) . Example: Kendall Now, consider the algorithm to compute the Kendall-Tau distance. The code is given below. long count_inversion ( long i , long n , const long rank [ n ]) { long count = 0 ; for ( long j = i + 1 ; j < n ; j += 1 ) { if ( rank [ i ] > rank [ j ]) { count ++ ; } } return count ; } double kendall_tau ( long n , const long rank [ n ]) { long count = 0 ; for ( long i = 0 ; i < n - 1 ; i += 1 ) { count += count_inversion ( i , n , rank ); } return 2.0 * count / ( n * ( n - 1 )); } What is the running time of the function kendall_tau , expressed in Big-O notation in terms of n n , the length of the input array? To analyze the running time, we focus on the big picture, the part of the code that takes the most time, and we ignore all the other operations that take negligible time. In the function kendall_tau above, Line 16 is repeated many times, so let's focus on that. Looking at the looping conditions, we can conclude that Line 16 repeats O(n) O(n) times. It is tempting to conclude that kentall_tau takes O(n) O(n) steps here, but it would be wrong. Notice that Line 16 calls another function count_inversion . What is the running time of count_inversion ? Inside count_inversion , there is another loop that repeats n - i n - i times. Each time we call count_inversion , i increases, so the loop in count_inversion takes fewer steps each time the function is called. To calculate the total number of steps, we can compute the following sum sum_{i = 0}^{n} (n - i) sum_{i = 0}^{n} (n - i) , which is just n + (n-1) + (n-2) + .. + 2 + 1 n + (n-1) + (n-2) + .. + 2 + 1 . This sum is the sum of an arithmetic series and equals to n(n+1)/2 n(n+1)/2 . Since we use the Big-O notation, we can focus on the term with the highest rate of growth, n^2 n^2 , and ignore everything else. We have obtained the running time for kentall_tau function above as O(n^2) O(n^2) . Efficiency in CS1010 In CS1010, we will focus on the efficiency of your code in two senses: First, your code should not perform redundant work and it should not repeat itself unnecessarily. This criterion is independent of Big-O notation -- i.e., even though by optimizing the performance of your code, you do not change the worst-case Big-O performance, you should still optimize your code that makes it run faster. Second, your algorithm should run within a given Big-O running time. We will start to impose time limitations on the running time of your code, such that if you choose the wrong algorithm with the higher rate of growth, your code would not pass the test. Problem Set 22 Problem 22.1 Order the following functions in the increasing order of rate of growth: n! n! , 2^n 2^n , \\log_{10} n \\log_{10} n , \\ln n \\ln n , n^4 n^4 , n\\ln n n\\ln n , n n , n^2 n^2 , e^n e^n , \\sqrt{n} \\sqrt{n} Problem 22.2 What is the Big-O running time of the following code, in terms of n n ? a) for ( long i = 0 ; i < n ; i += 1 ) { for ( long j = 0 ; j < n ; j += 2 ) { cs1010_println_long ( i + j ); } } b) for ( long i = 1 ; i < n ; i *= 2 ) { for ( long j = 1 ; j < n ; j *= 2 ) { cs1010_println_long ( i + j ); } } c) long k = 1 ; for ( long j = 0 ; j < n ; j += 1 ) { k *= 2 ; for ( long i = 0 ; i < k ; i += 1 ) { cs1010_println_long ( i + j ); } } Note that we cannot conclude that g(n) g(n) grows faster than f(n) f(n) because of this. \u21a9","title":"22. Efficiency"},{"location":"22-efficiency.html#unit-22-efficiency","text":"We have been writing code and solving problems, focusing on producing the correct output and using the various construct of C language appropriately. Now, we will introduce a new criterion on writing code: efficiency .","title":"Unit 22: Efficiency"},{"location":"22-efficiency.html#no-redundant-work","text":"Writing efficient code basically means that we should not write code that runs unnecessarily. In my comments on your Assignment 2 , I gave you an example where the same function is_prime has different implementations -- some runs very slowly, while some runs quickly. I reproduce them here: bool is_prime ( long n ) { bool is_prime = true ; for ( long i = 2 ; i <= n - 1 ; i ++ ) { if ( n % i == 0 ) { is_prime = false ; } } return is_prime ; } bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } In fact, on my machine, the slowest version of is_prime took ~100s, while the fast one runs ~3ms when invoked with is_prime(10000000001) . The time taken is five orders of magnitude difference! But there is no magic here, as we merely apply the following principle: \"No redundant work\" If you recall, we improve the efficiency of is_prime by (i) returning false as soon as we found a proof that the input is not a prime, and (ii) not checking for divisor that is redundant.","title":"No Redundant Work"},{"location":"22-efficiency.html#worst-case-performance","text":"The two techniques we employed above behave slightly differently. For (i), we opportunistically stop our computation once we know the answer when the input is not a prime. However, in the worst case , when the input is a prime, we still have to check through all n-2 n-2 divisor, from 2 up to n-1 n-1 , before we can conclude that the input is a prime. Thus, for (i), we make our program faster for certain inputs but in the worst case, we are not able to speed up the program. The second technique is more interesting and more fruitful. With a little math, we can show that we only need to check for the divisor up to \\sqrt{n} \\sqrt{n} . Here, we are improving the worst case performance of is_prime , so whether the input is a prime or not, we always have a speed up. How much is the speed up in the worst case? In the input above, with the original slow code, in the worst case I need to check through ~10,000,000,001 divisors. With the faster version, I only need to check ~ \\sqrt{10,000,000,001} \\sqrt{10,000,000,001} = ~10,000 divisors. That's where the five orders of magnitude speed up comes from.","title":"Worst Case Performance"},{"location":"22-efficiency.html#no-repetition","text":"The second principle to improving the efficiency of the program is that \"No repetition\" -- we should not repeat work that has been done before. Let's look at the example from earlier this semester, where you are asked to compute the range of a list. Recall that the range of a list is the absolute difference between the largest element and the smallest element. We use this problem to motivate the use of function, where we denote range(L, k) = |max(L, k) - min(L, k)| range(L, k) = |max(L, k) - min(L, k)| . If we are to implement this solution in C, however, we would end up scanning through the list twice: first to find the max, then to find the min. The example code from Lecture 7 has shown that we could easily just go through the list once, use call-by-reference to output both the max and the min if we are willing to forgo the notion of pure functions and function-as-a-black-box. In your midterm, you see another example where we can go through the list once to find the second largest element, instead of twice: first to find the max, then to find the next largest. The performance improvement for not scanning through a list (or an array) twice is modest at most. Let's look at another example where, by not repeating ourselves, we can gain significant performance improvement.","title":"No Repetition"},{"location":"22-efficiency.html#finding-fibonacci-numbers","text":"Recall from your Exercise 3, the Fibonacci sequence of numbers are numbers formed by adding the previous two numbers to form the next numbers. In other words, the i i -th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2) (i-2) -th, and the (i-1) (i-1) -th. Here is one way we can find the Fibonacci numbers with a loop: long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } long first = 1 ; long second = 1 ; long third = 1 ; for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } return third ; } To find the n n -th Fibonacci number, we take n n steps in a loop. Now, let's see the following elegant recursive solution: long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } return fib ( n - 1 ) + fib ( n - 2 ); } This solution is short and follows directly from the definition of Fibonacci numbers. Running this, however, reveals something very disturbing. Let's say we call fib(n) . This invocation in turns calls fib(n-1) and fib(n-2) . fib(n-1) then calls fib(n-2) and fib(n-3) . So, fib(n-2) will be called twice -- so we are repeating ourselves, violating the no repetition principles. In fact, we will invoke fib() a large number of times.","title":"Finding Fibonacci Numbers"},{"location":"22-efficiency.html#big-o-notation","text":"How do we characterize the number of times fib() is called? To answer this, we will introduce to you the Big-O notation. The Big-O function is a mathematical function that computer scientists use to characterize the time and space efficiency of an algorithm. There is a formal definition to Big-O, which interested students can find out by Googling, or you can wait until you take CS2040C and CS3230. In CS1010, we will introduce Big-O using the intuition that it is the \"rate of growth\" of a function. To motivate Big-O, let's consider how we can count the number of \"steps\" taken by an algorithm. Let's consider this again: for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } If we consider each of the fundamental operations: comparison, addition, and assignment, as a step, then we can see that, in each loop, there is one comparison ( i != n ), two additions ( i + 1 , third = first + second ), four assignments. So we have seven operations per loop, with a total of n-1 n-1 loops. So we have 7n - 7 7n - 7 operations. In addition, we also need to count for the assignment i = 2 and the additional comparison before we exit the loop ( i != n ). So, in total, we have 7n - 5 7n - 5 operations. As you can see, such detailed counting of the steps in tedious, and in fact, not very meaningful. For instance, we did not account for reading values from the memory and writing of values into the memory, the performance of which becomes dependant on the architecture underneath. To free us from such low-level accounting of the number of steps, let's focus on the big picture. No matter how we count the number of steps, in the end, it is a linear function of n n . In order words, the number of steps taken by the algorithm to compute Fibonacci in a loop grows linearly with n n . Using the Big-O notation, we say that it takes O(n) O(n) steps. Given a mathematical function with multiple terms, the Big-O of this function is obtained by dropping any multiplicative constants and all terms, except for the one with the highest rate of growth . For instance, O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4) O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4) . Due to this focus on the term with highest rate of growth, and not bothering about other terms or multiplicative constants, it becomes very convenient for us to expression the time efficiency of an algorithm with O() O() -- we no longer need to count the steps precisely but just focus on the number of times it takes to run the algorithm in terms of n n . Take the example of is_prime . The slow algorithm takes O(n) O(n) , the fast algorithm takes O(\\sqrt{n}) O(\\sqrt{n}) . Take another example: to find the range of a list, both algorithms, regardless of whether we are taking two passes or one pass, take O(n) O(n) time.","title":"Big-O Notation"},{"location":"22-efficiency.html#rate-of-growth","text":"Given two functions f(n) f(n) and g(n) g(n) , how do we determine which one has a higher rate of growth? We say that f(n) f(n) grows faster than g(n) g(n) if we can find a n_0 n_0 , such that f(n) > cg(n) f(n) > cg(n) for all n \\ge n_0 n \\ge n_0 and for some constant c c . For instance, which one grows faster? f(n) = n^n f(n) = n^n or g(n) = 2^n g(n) = 2^n ? Pick n = 1 n = 1 , we have f(1) < g(1) f(1) < g(1) 1 . Pick n = 2 n = 2 , we have f(2) f(2) equals g(2) g(2) . Pick n = 3 n = 3 , we have $f(3) > g(3) g(3) now, and we can see that for any n > 3 n > 3 , n^n > 2^n n^n > 2^n , so we can conclude that f(n) f(n) grows faster than g(n) g(n) .","title":"Rate of Growth"},{"location":"22-efficiency.html#example-kendall","text":"Now, consider the algorithm to compute the Kendall-Tau distance. The code is given below. long count_inversion ( long i , long n , const long rank [ n ]) { long count = 0 ; for ( long j = i + 1 ; j < n ; j += 1 ) { if ( rank [ i ] > rank [ j ]) { count ++ ; } } return count ; } double kendall_tau ( long n , const long rank [ n ]) { long count = 0 ; for ( long i = 0 ; i < n - 1 ; i += 1 ) { count += count_inversion ( i , n , rank ); } return 2.0 * count / ( n * ( n - 1 )); } What is the running time of the function kendall_tau , expressed in Big-O notation in terms of n n , the length of the input array? To analyze the running time, we focus on the big picture, the part of the code that takes the most time, and we ignore all the other operations that take negligible time. In the function kendall_tau above, Line 16 is repeated many times, so let's focus on that. Looking at the looping conditions, we can conclude that Line 16 repeats O(n) O(n) times. It is tempting to conclude that kentall_tau takes O(n) O(n) steps here, but it would be wrong. Notice that Line 16 calls another function count_inversion . What is the running time of count_inversion ? Inside count_inversion , there is another loop that repeats n - i n - i times. Each time we call count_inversion , i increases, so the loop in count_inversion takes fewer steps each time the function is called. To calculate the total number of steps, we can compute the following sum sum_{i = 0}^{n} (n - i) sum_{i = 0}^{n} (n - i) , which is just n + (n-1) + (n-2) + .. + 2 + 1 n + (n-1) + (n-2) + .. + 2 + 1 . This sum is the sum of an arithmetic series and equals to n(n+1)/2 n(n+1)/2 . Since we use the Big-O notation, we can focus on the term with the highest rate of growth, n^2 n^2 , and ignore everything else. We have obtained the running time for kentall_tau function above as O(n^2) O(n^2) .","title":"Example: Kendall"},{"location":"22-efficiency.html#efficiency-in-cs1010","text":"In CS1010, we will focus on the efficiency of your code in two senses: First, your code should not perform redundant work and it should not repeat itself unnecessarily. This criterion is independent of Big-O notation -- i.e., even though by optimizing the performance of your code, you do not change the worst-case Big-O performance, you should still optimize your code that makes it run faster. Second, your algorithm should run within a given Big-O running time. We will start to impose time limitations on the running time of your code, such that if you choose the wrong algorithm with the higher rate of growth, your code would not pass the test.","title":"Efficiency in CS1010"},{"location":"22-efficiency.html#problem-set-22","text":"","title":"Problem Set 22"},{"location":"22-efficiency.html#problem-221","text":"Order the following functions in the increasing order of rate of growth: n! n! , 2^n 2^n , \\log_{10} n \\log_{10} n , \\ln n \\ln n , n^4 n^4 , n\\ln n n\\ln n , n n , n^2 n^2 , e^n e^n , \\sqrt{n} \\sqrt{n}","title":"Problem 22.1"},{"location":"22-efficiency.html#problem-222","text":"What is the Big-O running time of the following code, in terms of n n ? a) for ( long i = 0 ; i < n ; i += 1 ) { for ( long j = 0 ; j < n ; j += 2 ) { cs1010_println_long ( i + j ); } } b) for ( long i = 1 ; i < n ; i *= 2 ) { for ( long j = 1 ; j < n ; j *= 2 ) { cs1010_println_long ( i + j ); } } c) long k = 1 ; for ( long j = 0 ; j < n ; j += 1 ) { k *= 2 ; for ( long i = 0 ; i < k ; i += 1 ) { cs1010_println_long ( i + j ); } } Note that we cannot conclude that g(n) g(n) grows faster than f(n) f(n) because of this. \u21a9","title":"Problem 22.2"},{"location":"23-search.html","text":"Unit 23: Searching Let's continue the discussion on efficiency on one of the fundamental problems in computing: how to look for something. You have seen a similar problem in the problem Index in Exercise 3: Given a list of items L L and query item q q , find if q q is in L L . Let's write a function to solve this. Our function returns -1 if q q is not in the list. It returns the position of q q in the list otherwise. long search ( long n , const long list [ n ], long q ) { for ( long i = 0 ; i < n ; i += 1 ) { if ( list [ i ] == q ) { return i ; } return - 1 ; } What is the worst-case running time, expressed in Big-O notation, of the function above? Suppose the query q q is not in the list, we will have to scan the whole list, once. The worst case running time is, therefore, O(n) O(n) . Can we do better? It turns out that this running time O(n) O(n) is also the best that we can do because we cannot be sure that q q does not exist until we check every single element in the list. So there is no shortcut. Binary Search But, do we always have to check every element in the list? It turns out that, like many real-life situations, if the input list is sorted , we do not have to scan through every element. We can eliminate a huge chunk of the elements based on whether a chosen element is bigger or smaller than q q . Suppose that the input list is sorted in increasing order. Pick a random element x x from the list. Any element to the left of x x must be less than or equal to x x , and any element to the right of x x must be greater or equal to x x . Suppose that q > x q > x , then we know that q q must be to the right of x x , there is no need to search to the left of x x . Otherwise, q < x q < x , and q q must be to the left of x x , and there is no need to search to the right of x x . We can code this out using a recursive function below: /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } else if ( list [ mid ] > q ) { return search ( list , i , mid - 1 , q ); } return search ( list , mid + 1 , j , q ); } We call this function with: search ( list , 0 , n - 1 , q ); The search algorithm above is called binary search since it repeatedly cut the range of values to search by half. Why is it correct? It is not obvious at first glance that the code above correctly searches for q q in L L . Let's analyze this function more systematically by writing an assertion for this function. What we want to do here is to eliminate elements in the array that cannot possibly contain q q -- these are elements outside of the list[i] .. list[j] range. In other words, we want to assert that // { q is not in list[0]..list[i-1] and list[j+1]..list[n-1] } at the beginning of the function. In other words, this is a precondition for the function. Let's see if this precondition is true at the beginning. Since i i is 0 0 and j j is n-1 n-1 , the ranges list[0]..list[i-1] and list[j+1]..list[n-1] are empty, so the assertion is true. What happen if i > j i > j ? This implies that i - 1 > j - 1 i - 1 > j - 1 , so the range list[0] .. list[i-1] and the range list[j+1] .. list[n-1] overlap. We can be sure that q q is not anywhere in list . Let's see how we ensure this assertion is true in the recursive call. : } else if ( list [ mid ] > q ) { return search ( list , i , mid - 1 , q ); } : Line 3 of the snippet above is invoked only if list[mid] > q . Since the array list is sorted, we know for sure that any element in list[mid+1] .. list[j] is larger than q q . So, q q cannot be anywhere in that range. We can assert, between Line 3 and Line 4 above: // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } Thus, when Line 4 is invoked, the same assertion holds true. You can apply the same argument to the call: return search ( list , mid + 1 , j , q ); To summarize, we annotate the code above with the assertions: /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @pre q is not in list[0]..list[i-1] and list[j+1]..list[n-1] * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { // { q is not in list[0]..list[n-1] } return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } else if ( list [ mid ] > q ) { // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } return search ( list , i , mid - 1 , q ); } // { q is not in list[0]..list[mid] and list[j]..list[n-1] } return search ( list , mid + 1 , j , q ); } How Efficient is Binary Search We have seen that if the input list is not sorted, then we minimally have to check every element in the list, leading to an O(n) O(n) algorithm. With a sorted input and using binary search, however, we can do a better. Let's consider the worst case, where q q is not in the list. Note that every comparison we make, we reduce the range of elements to search by half, until we reach one element. We start with n n elements that could possibly contain q q . After one comparison, we are left with n/2 n/2 . After another comparison, we are left with n/4 n/4 , etc. It takes only O(\\log_2 n) O(\\log_2 n) steps until we reach one element in the list. This is a big improvement over O(n) O(n) time! Appendix: Complete Code #include \"cs1010.h\" /* Look for q in list[i]..list[j]. * * @pre list is sorted in increasing order * @pre q is not in list[0]..list[i-1], list[j+1]..list[n-1] * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( j < i ) { return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } if ( list [ mid ] > q ) { return search ( list , i , mid - 1 , q ); } // { list[mid] < q } return search ( list , mid + 1 , j , q ); } int main () { long a [] = { 1 , 3 , 5 , 9 , 11 , 13 , 14 , 19 }; long q = cs1010_read_long (); cs1010_println_long ( search ( a , 0 , 7 , q )); }","title":"23. Binary Search"},{"location":"23-search.html#unit-23-searching","text":"Let's continue the discussion on efficiency on one of the fundamental problems in computing: how to look for something. You have seen a similar problem in the problem Index in Exercise 3: Given a list of items L L and query item q q , find if q q is in L L . Let's write a function to solve this. Our function returns -1 if q q is not in the list. It returns the position of q q in the list otherwise. long search ( long n , const long list [ n ], long q ) { for ( long i = 0 ; i < n ; i += 1 ) { if ( list [ i ] == q ) { return i ; } return - 1 ; } What is the worst-case running time, expressed in Big-O notation, of the function above? Suppose the query q q is not in the list, we will have to scan the whole list, once. The worst case running time is, therefore, O(n) O(n) . Can we do better? It turns out that this running time O(n) O(n) is also the best that we can do because we cannot be sure that q q does not exist until we check every single element in the list. So there is no shortcut.","title":"Unit 23: Searching"},{"location":"23-search.html#binary-search","text":"But, do we always have to check every element in the list? It turns out that, like many real-life situations, if the input list is sorted , we do not have to scan through every element. We can eliminate a huge chunk of the elements based on whether a chosen element is bigger or smaller than q q . Suppose that the input list is sorted in increasing order. Pick a random element x x from the list. Any element to the left of x x must be less than or equal to x x , and any element to the right of x x must be greater or equal to x x . Suppose that q > x q > x , then we know that q q must be to the right of x x , there is no need to search to the left of x x . Otherwise, q < x q < x , and q q must be to the left of x x , and there is no need to search to the right of x x . We can code this out using a recursive function below: /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } else if ( list [ mid ] > q ) { return search ( list , i , mid - 1 , q ); } return search ( list , mid + 1 , j , q ); } We call this function with: search ( list , 0 , n - 1 , q ); The search algorithm above is called binary search since it repeatedly cut the range of values to search by half.","title":"Binary Search"},{"location":"23-search.html#why-is-it-correct","text":"It is not obvious at first glance that the code above correctly searches for q q in L L . Let's analyze this function more systematically by writing an assertion for this function. What we want to do here is to eliminate elements in the array that cannot possibly contain q q -- these are elements outside of the list[i] .. list[j] range. In other words, we want to assert that // { q is not in list[0]..list[i-1] and list[j+1]..list[n-1] } at the beginning of the function. In other words, this is a precondition for the function. Let's see if this precondition is true at the beginning. Since i i is 0 0 and j j is n-1 n-1 , the ranges list[0]..list[i-1] and list[j+1]..list[n-1] are empty, so the assertion is true. What happen if i > j i > j ? This implies that i - 1 > j - 1 i - 1 > j - 1 , so the range list[0] .. list[i-1] and the range list[j+1] .. list[n-1] overlap. We can be sure that q q is not anywhere in list . Let's see how we ensure this assertion is true in the recursive call. : } else if ( list [ mid ] > q ) { return search ( list , i , mid - 1 , q ); } : Line 3 of the snippet above is invoked only if list[mid] > q . Since the array list is sorted, we know for sure that any element in list[mid+1] .. list[j] is larger than q q . So, q q cannot be anywhere in that range. We can assert, between Line 3 and Line 4 above: // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } Thus, when Line 4 is invoked, the same assertion holds true. You can apply the same argument to the call: return search ( list , mid + 1 , j , q ); To summarize, we annotate the code above with the assertions: /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @pre q is not in list[0]..list[i-1] and list[j+1]..list[n-1] * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { // { q is not in list[0]..list[n-1] } return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } else if ( list [ mid ] > q ) { // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } return search ( list , i , mid - 1 , q ); } // { q is not in list[0]..list[mid] and list[j]..list[n-1] } return search ( list , mid + 1 , j , q ); }","title":"Why is it correct?"},{"location":"23-search.html#how-efficient-is-binary-search","text":"We have seen that if the input list is not sorted, then we minimally have to check every element in the list, leading to an O(n) O(n) algorithm. With a sorted input and using binary search, however, we can do a better. Let's consider the worst case, where q q is not in the list. Note that every comparison we make, we reduce the range of elements to search by half, until we reach one element. We start with n n elements that could possibly contain q q . After one comparison, we are left with n/2 n/2 . After another comparison, we are left with n/4 n/4 , etc. It takes only O(\\log_2 n) O(\\log_2 n) steps until we reach one element in the list. This is a big improvement over O(n) O(n) time!","title":"How Efficient is Binary Search"},{"location":"23-search.html#appendix-complete-code","text":"#include \"cs1010.h\" /* Look for q in list[i]..list[j]. * * @pre list is sorted in increasing order * @pre q is not in list[0]..list[i-1], list[j+1]..list[n-1] * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( j < i ) { return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } if ( list [ mid ] > q ) { return search ( list , i , mid - 1 , q ); } // { list[mid] < q } return search ( list , mid + 1 , j , q ); } int main () { long a [] = { 1 , 3 , 5 , 9 , 11 , 13 , 14 , 19 }; long q = cs1010_read_long (); cs1010_println_long ( search ( a , 0 , 7 , q )); }","title":"Appendix: Complete Code"},{"location":"24-list.html","text":"Unit 24: Ordered / Unordered List One of the most useful and fundamental data abstraction in computing is a list of items. We have seen this in the very first example for CS1010. We have also seen how array can be used to represent a list. In this unit, we are going to delve deeper into representing a list with an array. So far, we have seen a list that is static. Once we created a list, it remains unchanged. To make a list useful, we need to be able to update the list -- either remove an item, replace an item, or add an item to the list. We will consider two types of list today. An ordered list, where the order of items is important and should be maintained, and an unordered list, where the order of items does not matter. Allocating Memory for a List Let's see how we can create a list. Since a list can grow or shrink, we should not allocate an array that fits perfectly the number of items in the list, as we have been doing. What we should do is to allocate an array with a size big enough to store the expected size of the list, and in case the list grows longer, to allocate more memory (using realloc ) and get a bigger array. The function to allocate a list should look like this:","title":"Unit 24: Ordered / Unordered List"},{"location":"24-list.html#unit-24-ordered-unordered-list","text":"One of the most useful and fundamental data abstraction in computing is a list of items. We have seen this in the very first example for CS1010. We have also seen how array can be used to represent a list. In this unit, we are going to delve deeper into representing a list with an array. So far, we have seen a list that is static. Once we created a list, it remains unchanged. To make a list useful, we need to be able to update the list -- either remove an item, replace an item, or add an item to the list. We will consider two types of list today. An ordered list, where the order of items is important and should be maintained, and an unordered list, where the order of items does not matter.","title":"Unit 24: Ordered / Unordered List"},{"location":"24-list.html#allocating-memory-for-a-list","text":"Let's see how we can create a list. Since a list can grow or shrink, we should not allocate an array that fits perfectly the number of items in the list, as we have been doing. What we should do is to allocate an array with a size big enough to store the expected size of the list, and in case the list grows longer, to allocate more memory (using realloc ) and get a bigger array. The function to allocate a list should look like this:","title":"Allocating Memory for a List"},{"location":"24-sort.html","text":"Unit 24: Sorting Sorting is one of the most fundamental computational problem. Given a list of items, we want to rearrange the items in some order. We have actually seen two algorithms to sort in this module: counting sort and selection sort. We are going to see two more today. Bubble Sort Bubble sort is probably the most well known, under-performed sorting algorithm 1 , but is taught in most CS classes because of its simplicity. The idea of bubble sort is to make multiple passes through the list. In each pass, we look for all possible adjacent pair of items. Any adjacent pair that is out of order are swapped so that they are in order. This process repeats until everything is in order. Let's look at an example. Suppose we have, as an input, the numbers 8 4 23 42 16 15 . In the first pass, we starts from the first item and check from left to right. The pair 8 4 is out of order, so we swap them, and we get 4 8 23 42 16 15 . The pair 8 23 and 23 42 are in order, so we do not need to swap them. The pair 42 16 is out of order. We swap them and get 4 8 23 16 42 15 . The pair 42 15 is again out of order, so we swap them and get 4 8 23 16 15 42 . The following sequence show the first pass through the array: 8 4 23 42 16 15 <- swap -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 <- swap -- -- 4 8 23 16 42 15 <- swap -- -- 4 8 23 16 15 42 After the first pass, notice that the largest element, 42, \"bubbles\" up through the list until it reaches the maximum position. We can now make the second pass, but we can exclude the last item, since it is already in place. 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 <- swap -- -- 4 8 16 23 15 42 <- swap -- -- 4 8 16 15 23 42 -- -- After the second pass, the second largest element, 23, is in its position. So we can exclude this item in the subsequent pass. The rest of the passes operates similarly. In the i i -th pass, we scan through array item 0 to n-i n-i , swapping any adjacent element that is out of order, until i = n - 1 i = n - 1 , in which case we only have two elements, we swap them if we are out of order, and we are done! The code for bubble sort can be written as follows: void bubble_pass ( long last , long a []) { for ( long i = 0 ; i < last ; i += 1 ) { if ( a [ i ] > a [ i + 1 ]) { swap ( a , i , i + 1 ); } } } void bubble_sort ( long n , long a [ n ]) { for ( long last = n - 1 ; last > 0 ; last -= 1 ) { bubble_pass ( last , a ); } } How many steps does it take to bubble-sort an array of n n elements? Since the i i -th pass scans through n-i n-i elements, and there are a n n passes in total, the analysis is similar to the one we did for the algorithm to compute the Kendall-tau distance -- bubble sort takes O(n^2) O(n^2) steps. Insertion Sort The next sorting algorithm we are going to discuss is insertion sort. This is another classic algorithm, that could perform better than bubble sort in some scenario. The idea of insertion sort is simple: we partition the input list into two, a sorted partition, and an unsorted partition. Then we repeatedly take the first element from the unsorted partition, find its rightful place in the sorted partition, and insert it into place. We start with a sorted partition of one element, and we end if the sorted partition contains all the elements. Take 8 4 23 42 16 15 as an example. I will use | to partition the array into a left sorted partition, and a right, unsorted, partition. 8 | 4 23 42 16 15 We pick the first element on the unsorted partition, 4, and insert it into the sorted partition. This involves shifting the elements in the sorted partition to the right until we find the rightful place for 4 . After this step, the sorted partition grows by 1 and the unsorted partition shrinks by 1. 4 8 | 23 42 16 15 In the next round, we take 23 , and finds its rightful place. It turns out 23 is already in its correct place. 4 8 23 | 42 16 15 In the next step, 42 is also in its correct place. 4 8 23 42 | 16 15 16 is next element, and we insert it between 8 and 23. 4 8 16 23 42 | 15 Finally we insert 15 and we are done, as there is no more element in the unsorted partition. 4 8 15 16 23 42 The code for insertion sort can be written as follows: void insert ( long a [], long curr ) { long i = curr - 1 ; long temp = a [ curr ]; while ( temp < a [ i ] && i >= 0 ) { a [ i + 1 ] = a [ i ]; i -= 1 ; } a [ i + 1 ] = temp ; } void insertion_sort ( long n , long a [ n ]) { for ( long curr = 1 ; curr < n ; curr += 1 ) { insert ( a , curr ); } } Animation Animations for various sorting algorithms, including some which you will learn in CS2040C, are available online on VisuAlgo Problem Set 24 Problem 24.1 In the implementation of bubble sort above, we always make n-1 n-1 passes through the array. It is, however, possible to stop the whole sorting procedure, when a pass through the array does not lead to any swapping. Modify the code above to achieve this optimization. Problem 24.2 a) Suppose the input list to insertion sort is already sorted. What is the running time of insertion sort? b) Suppose the input list to insertion sort is inversely sorted. What is the running time of insertion sort? Problem 24.3 What is the loop invariant for the loop in the function insert ? Appendix: Complete Code From Lecture #include <assert.h> #include \"cs1010.h\" void swap ( long a [], int i , int j ) { long temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } void print ( long len , long a [ len ]) { for ( long i = 0 ; i < len ; i += 1 ) { cs1010_print_long ( a [ i ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void bubble_pass ( long last , long a []) { for ( long i = 0 ; i < last - 1 ; i += 1 ) { if ( a [ i ] > a [ i + 1 ]) { swap ( a , i , i + 1 ); } } print ( 6 , a ); } void bubble_sort ( long len , long a [ len ]) { for ( long last = len - 1 ; last > 0 ; last -= 1 ) { bubble_pass ( last , a ); } } int main () { long a [] = { 44 , 4 , 23 , 42 , 16 , 15 }; bubble_sort ( 6 , a ); print ( 6 , a ); } #include \"cs1010.h\" void print ( long len , long a [ len ]) { for ( long i = 0 ; i < len ; i += 1 ) { cs1010_print_long ( a [ i ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void insert ( long a [], long curr ) { // insert a[curr] into a[0]..a[curr-1] in the right position long temp = a [ curr ]; long i = curr - 1 ; while ( temp < a [ i ] && i >= 0 ) { a [ i + 1 ] = a [ i ]; i -= 1 ; } // { temp >= a[i] || i < 0 } a [ i + 1 ] = temp ; } void insertion_sort ( long n , long a [ n ]) { for ( long curr = 1 ; curr < n ; curr += 1 ) { insert ( a , curr ); print ( n , a ); } } int main () { long a [] = { 44 , 4 , 23 , 42 , 16 , 15 }; insertion_sort ( 6 , a ); } https://www.youtube.com/watch?v=k4RRi_ntQc8 \u21a9","title":"24. Sorting"},{"location":"24-sort.html#unit-24-sorting","text":"Sorting is one of the most fundamental computational problem. Given a list of items, we want to rearrange the items in some order. We have actually seen two algorithms to sort in this module: counting sort and selection sort. We are going to see two more today.","title":"Unit 24: Sorting"},{"location":"24-sort.html#bubble-sort","text":"Bubble sort is probably the most well known, under-performed sorting algorithm 1 , but is taught in most CS classes because of its simplicity. The idea of bubble sort is to make multiple passes through the list. In each pass, we look for all possible adjacent pair of items. Any adjacent pair that is out of order are swapped so that they are in order. This process repeats until everything is in order. Let's look at an example. Suppose we have, as an input, the numbers 8 4 23 42 16 15 . In the first pass, we starts from the first item and check from left to right. The pair 8 4 is out of order, so we swap them, and we get 4 8 23 42 16 15 . The pair 8 23 and 23 42 are in order, so we do not need to swap them. The pair 42 16 is out of order. We swap them and get 4 8 23 16 42 15 . The pair 42 15 is again out of order, so we swap them and get 4 8 23 16 15 42 . The following sequence show the first pass through the array: 8 4 23 42 16 15 <- swap -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 <- swap -- -- 4 8 23 16 42 15 <- swap -- -- 4 8 23 16 15 42 After the first pass, notice that the largest element, 42, \"bubbles\" up through the list until it reaches the maximum position. We can now make the second pass, but we can exclude the last item, since it is already in place. 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 <- swap -- -- 4 8 16 23 15 42 <- swap -- -- 4 8 16 15 23 42 -- -- After the second pass, the second largest element, 23, is in its position. So we can exclude this item in the subsequent pass. The rest of the passes operates similarly. In the i i -th pass, we scan through array item 0 to n-i n-i , swapping any adjacent element that is out of order, until i = n - 1 i = n - 1 , in which case we only have two elements, we swap them if we are out of order, and we are done! The code for bubble sort can be written as follows: void bubble_pass ( long last , long a []) { for ( long i = 0 ; i < last ; i += 1 ) { if ( a [ i ] > a [ i + 1 ]) { swap ( a , i , i + 1 ); } } } void bubble_sort ( long n , long a [ n ]) { for ( long last = n - 1 ; last > 0 ; last -= 1 ) { bubble_pass ( last , a ); } } How many steps does it take to bubble-sort an array of n n elements? Since the i i -th pass scans through n-i n-i elements, and there are a n n passes in total, the analysis is similar to the one we did for the algorithm to compute the Kendall-tau distance -- bubble sort takes O(n^2) O(n^2) steps.","title":"Bubble Sort"},{"location":"24-sort.html#insertion-sort","text":"The next sorting algorithm we are going to discuss is insertion sort. This is another classic algorithm, that could perform better than bubble sort in some scenario. The idea of insertion sort is simple: we partition the input list into two, a sorted partition, and an unsorted partition. Then we repeatedly take the first element from the unsorted partition, find its rightful place in the sorted partition, and insert it into place. We start with a sorted partition of one element, and we end if the sorted partition contains all the elements. Take 8 4 23 42 16 15 as an example. I will use | to partition the array into a left sorted partition, and a right, unsorted, partition. 8 | 4 23 42 16 15 We pick the first element on the unsorted partition, 4, and insert it into the sorted partition. This involves shifting the elements in the sorted partition to the right until we find the rightful place for 4 . After this step, the sorted partition grows by 1 and the unsorted partition shrinks by 1. 4 8 | 23 42 16 15 In the next round, we take 23 , and finds its rightful place. It turns out 23 is already in its correct place. 4 8 23 | 42 16 15 In the next step, 42 is also in its correct place. 4 8 23 42 | 16 15 16 is next element, and we insert it between 8 and 23. 4 8 16 23 42 | 15 Finally we insert 15 and we are done, as there is no more element in the unsorted partition. 4 8 15 16 23 42 The code for insertion sort can be written as follows: void insert ( long a [], long curr ) { long i = curr - 1 ; long temp = a [ curr ]; while ( temp < a [ i ] && i >= 0 ) { a [ i + 1 ] = a [ i ]; i -= 1 ; } a [ i + 1 ] = temp ; } void insertion_sort ( long n , long a [ n ]) { for ( long curr = 1 ; curr < n ; curr += 1 ) { insert ( a , curr ); } }","title":"Insertion Sort"},{"location":"24-sort.html#animation","text":"Animations for various sorting algorithms, including some which you will learn in CS2040C, are available online on VisuAlgo","title":"Animation"},{"location":"24-sort.html#problem-set-24","text":"","title":"Problem Set 24"},{"location":"24-sort.html#problem-241","text":"In the implementation of bubble sort above, we always make n-1 n-1 passes through the array. It is, however, possible to stop the whole sorting procedure, when a pass through the array does not lead to any swapping. Modify the code above to achieve this optimization.","title":"Problem 24.1"},{"location":"24-sort.html#problem-242","text":"a) Suppose the input list to insertion sort is already sorted. What is the running time of insertion sort? b) Suppose the input list to insertion sort is inversely sorted. What is the running time of insertion sort?","title":"Problem 24.2"},{"location":"24-sort.html#problem-243","text":"What is the loop invariant for the loop in the function insert ?","title":"Problem 24.3"},{"location":"24-sort.html#appendix-complete-code-from-lecture","text":"#include <assert.h> #include \"cs1010.h\" void swap ( long a [], int i , int j ) { long temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } void print ( long len , long a [ len ]) { for ( long i = 0 ; i < len ; i += 1 ) { cs1010_print_long ( a [ i ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void bubble_pass ( long last , long a []) { for ( long i = 0 ; i < last - 1 ; i += 1 ) { if ( a [ i ] > a [ i + 1 ]) { swap ( a , i , i + 1 ); } } print ( 6 , a ); } void bubble_sort ( long len , long a [ len ]) { for ( long last = len - 1 ; last > 0 ; last -= 1 ) { bubble_pass ( last , a ); } } int main () { long a [] = { 44 , 4 , 23 , 42 , 16 , 15 }; bubble_sort ( 6 , a ); print ( 6 , a ); } #include \"cs1010.h\" void print ( long len , long a [ len ]) { for ( long i = 0 ; i < len ; i += 1 ) { cs1010_print_long ( a [ i ]); cs1010_print_string ( \" \" ); } cs1010_println_string ( \"\" ); } void insert ( long a [], long curr ) { // insert a[curr] into a[0]..a[curr-1] in the right position long temp = a [ curr ]; long i = curr - 1 ; while ( temp < a [ i ] && i >= 0 ) { a [ i + 1 ] = a [ i ]; i -= 1 ; } // { temp >= a[i] || i < 0 } a [ i + 1 ] = temp ; } void insertion_sort ( long n , long a [ n ]) { for ( long curr = 1 ; curr < n ; curr += 1 ) { insert ( a , curr ); print ( n , a ); } } int main () { long a [] = { 44 , 4 , 23 , 42 , 16 , 15 }; insertion_sort ( 6 , a ); } https://www.youtube.com/watch?v=k4RRi_ntQc8 \u21a9","title":"Appendix: Complete Code From Lecture"},{"location":"25-tower.html","text":"Unit 25: Tower of Hanoi In this unit and the next, we will see how we can use recursion to solve more complex problems. We will start with the Tower of Hanoi problem in this unit. The Tower of Hanoi problem is a famous mathematical puzzle invented by French mathematician \u00c9douard Lucas in 1883. It goes like this: There are three pegs and n n disks of various size that we can slide into any of the pegs. There are a few rules that we have to obey: we can only move one disk at a time; we can only move the topmost disk from one peg and place the disk on another peg; no disk can be placed on top of a smaller disk. In the beginning, we have all the disks in one peg. The goal is to move all the disks onto another peg. Wikipedia has the following animation showing how to solve the puzzle with 4 disks in 15 steps. by Andr\u00e9 Karwath aka Aka - Own work , CC BY-SA 2.5 , Link You can play a version online here Using Recursion Recall the two steps in recursive problem solving: (i) reduce the problem to the simplest version where we can solve it trivially; and (ii) assuming that we can solve the simpler version of the problem, we combine the solution to solve the more complex version. What is the simplest version of the Tower of Hanoi puzzle? It is the version with only a single disk. In this version, the solution is trivial -- we just move the disk from the source peg to the destination peg Let's label the pegs A, B, and C, with A being the source and C being the destination. We will use peg B as the temporary placeholder. Now, let's assume that we can solve the Tower of Hanoi puzzle for k-1 k-1 disks. How can we solve the puzzle for k k disks? It turns out the solution is equally trivial. First, move the top k-1 k-1 disk from A to B. This would free up the largest disk, which we move from A to C. Then, we move the k-1 k-1 disk from B to C. The figures above illustrate the recursion steps. The first figure shows the original configuration. The second figure shows the recursive step -- by wishful thinking, we believe that we can solve the puzzle for k-1 k-1 disks and move k-1 k-1 disks from A to B, using C as the placeholder. The third figure shows the move after moving the largest disk from A to C. The last figure shows the move of k-1 k-1 disks from B to C. Now that A is empty, the last move uses A as the placeholder. Representing the Tower of Hanoi in Code To write a solution for the Tower of Hanoi, we need to decide how to represent the disks and the pegs in our code. We are going to abstract out only the necessary details. Such an abstraction process is similar to what we have done so far, representing elevations data as integers, student ids as integers, etc. Here, we are representing physical objects, but note that the actual size of the disks, the location of the pegs, etc, do not matter in our code. As such, we will represent the disks with integers 1 to k k (1 being smallest, k k being the largest) and pegs with integers 1 to 3. The Solution Let's write the code for a function void solve_tower_of_hanoi(long k, long source, long dest) , which will print out the solution for moving k k disks from the peg source to the peg dest . void solve_tower_of_hanoi ( long k , long source , long dest , long placeholder ) { if ( k == 1 ) { print ( k , source , dest ); } else { solve_tower_of_hanoi ( k - 1 , source , placeholder , dest ); print ( k , source , dest ); solve_tower_of_hanoi ( k - 1 , placeholder , dest , source ); } } where print is a helper function to display the move to standard output. void print ( long k , long source , long dest ) { cs1010_print_string ( \"Disk \" ); cs1010_print_long ( k ); cs1010_print_string ( \": Peg \" ); cs1010_print_long ( source ); cs1010_print_string ( \" -> Peg \" ); cs1010_print_long ( dest ); } Running Time How many moves does it take to solve the Tower of Hanoi puzzle with k k disks? If k k is 1, then it takes one move. Otherwise, let us denote the number of moves taken as T(k) T(k) . From the code, we can see that it takes T(k) = 2T(k-1) + 1 T(k) = 2T(k-1) + 1 . An equation of this form is called a recurrance equation . You can learn how to solve such equations generally in later modules (e.g., CS3230), but, for now, we will expand the equation to derive the solution for T(k) T(k) . You can see that: T(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ... T(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ... So, T(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1 T(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1 Since T(1) = 1 T(1) = 1 , we have T(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1 T(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1 Thus, solving the Tower of Hanoi with k k disks takes 2^k-1 2^k-1 steps. Problem Set Problem 25.1 Suppose that we add a new restriction to the Tower of Hanoi puzzle. Let's say that the disks are on Peg A (or Peg 1) to begin with, and we want to move the disk to Peg C (or Peg 3). We are only allowed to move a disk either to Peg A Peg B from another peg or from Peg A Peg B to another peg. In other words, we cannot move the disks between Peg B or Peg C. Peg A and Peg C directly. Change the recursive algorithm above to solve the Tower of Hanoi with this new restriction. How many steps (use big O notation) are needed now? Appendix: Complete Code #include \"cs1010.h\" /** * Move Disk k from Peg source to Peg dest. * * @param[in] k The disk to move * @param[in] source The peg Disk k is currently at. * @param[in] dest The peg Disk k is moved to. */ void move ( long k , long source , long dest ) { cs1010_print_string ( \"Disk \" ); cs1010_print_long ( k ); cs1010_print_string ( \": Peg \" ); cs1010_print_long ( source ); cs1010_print_string ( \" -> Peg \" ); cs1010_println_long ( dest ); } void solve ( long k , long source , long dest , long placeholder ) { if ( k == 1 ) { move ( k , source , dest ); return ; } solve ( k - 1 , source , placeholder , dest ); move ( k , source , dest ); solve ( k - 1 , placeholder , dest , source ); } int main () { long k = cs1010_read_long (); solve ( k , 1 , 3 , 2 ); }","title":"25. Tower of Hanoi"},{"location":"25-tower.html#unit-25-tower-of-hanoi","text":"In this unit and the next, we will see how we can use recursion to solve more complex problems. We will start with the Tower of Hanoi problem in this unit. The Tower of Hanoi problem is a famous mathematical puzzle invented by French mathematician \u00c9douard Lucas in 1883. It goes like this: There are three pegs and n n disks of various size that we can slide into any of the pegs. There are a few rules that we have to obey: we can only move one disk at a time; we can only move the topmost disk from one peg and place the disk on another peg; no disk can be placed on top of a smaller disk. In the beginning, we have all the disks in one peg. The goal is to move all the disks onto another peg. Wikipedia has the following animation showing how to solve the puzzle with 4 disks in 15 steps. by Andr\u00e9 Karwath aka Aka - Own work , CC BY-SA 2.5 , Link You can play a version online here","title":"Unit 25: Tower of Hanoi"},{"location":"25-tower.html#using-recursion","text":"Recall the two steps in recursive problem solving: (i) reduce the problem to the simplest version where we can solve it trivially; and (ii) assuming that we can solve the simpler version of the problem, we combine the solution to solve the more complex version. What is the simplest version of the Tower of Hanoi puzzle? It is the version with only a single disk. In this version, the solution is trivial -- we just move the disk from the source peg to the destination peg Let's label the pegs A, B, and C, with A being the source and C being the destination. We will use peg B as the temporary placeholder. Now, let's assume that we can solve the Tower of Hanoi puzzle for k-1 k-1 disks. How can we solve the puzzle for k k disks? It turns out the solution is equally trivial. First, move the top k-1 k-1 disk from A to B. This would free up the largest disk, which we move from A to C. Then, we move the k-1 k-1 disk from B to C. The figures above illustrate the recursion steps. The first figure shows the original configuration. The second figure shows the recursive step -- by wishful thinking, we believe that we can solve the puzzle for k-1 k-1 disks and move k-1 k-1 disks from A to B, using C as the placeholder. The third figure shows the move after moving the largest disk from A to C. The last figure shows the move of k-1 k-1 disks from B to C. Now that A is empty, the last move uses A as the placeholder.","title":"Using Recursion"},{"location":"25-tower.html#representing-the-tower-of-hanoi-in-code","text":"To write a solution for the Tower of Hanoi, we need to decide how to represent the disks and the pegs in our code. We are going to abstract out only the necessary details. Such an abstraction process is similar to what we have done so far, representing elevations data as integers, student ids as integers, etc. Here, we are representing physical objects, but note that the actual size of the disks, the location of the pegs, etc, do not matter in our code. As such, we will represent the disks with integers 1 to k k (1 being smallest, k k being the largest) and pegs with integers 1 to 3.","title":"Representing the Tower of Hanoi in Code"},{"location":"25-tower.html#the-solution","text":"Let's write the code for a function void solve_tower_of_hanoi(long k, long source, long dest) , which will print out the solution for moving k k disks from the peg source to the peg dest . void solve_tower_of_hanoi ( long k , long source , long dest , long placeholder ) { if ( k == 1 ) { print ( k , source , dest ); } else { solve_tower_of_hanoi ( k - 1 , source , placeholder , dest ); print ( k , source , dest ); solve_tower_of_hanoi ( k - 1 , placeholder , dest , source ); } } where print is a helper function to display the move to standard output. void print ( long k , long source , long dest ) { cs1010_print_string ( \"Disk \" ); cs1010_print_long ( k ); cs1010_print_string ( \": Peg \" ); cs1010_print_long ( source ); cs1010_print_string ( \" -> Peg \" ); cs1010_print_long ( dest ); }","title":"The Solution"},{"location":"25-tower.html#running-time","text":"How many moves does it take to solve the Tower of Hanoi puzzle with k k disks? If k k is 1, then it takes one move. Otherwise, let us denote the number of moves taken as T(k) T(k) . From the code, we can see that it takes T(k) = 2T(k-1) + 1 T(k) = 2T(k-1) + 1 . An equation of this form is called a recurrance equation . You can learn how to solve such equations generally in later modules (e.g., CS3230), but, for now, we will expand the equation to derive the solution for T(k) T(k) . You can see that: T(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ... T(k) = 2T(k-1) + 1 = 4T(k-2) + 2 + 1 = 8T(k-3) + 4 + 2 + 1 = ... So, T(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1 T(k) = 2^{k-1}T(1) + 2^{k-2} + ... + 4 + 2 + 1 Since T(1) = 1 T(1) = 1 , we have T(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1 T(k) = 2^{k-1} + 2^{k-2} + ... + 4 + 2 + 1 = 2^k - 1 Thus, solving the Tower of Hanoi with k k disks takes 2^k-1 2^k-1 steps.","title":"Running Time"},{"location":"25-tower.html#problem-set","text":"","title":"Problem Set"},{"location":"25-tower.html#problem-251","text":"Suppose that we add a new restriction to the Tower of Hanoi puzzle. Let's say that the disks are on Peg A (or Peg 1) to begin with, and we want to move the disk to Peg C (or Peg 3). We are only allowed to move a disk either to Peg A Peg B from another peg or from Peg A Peg B to another peg. In other words, we cannot move the disks between Peg B or Peg C. Peg A and Peg C directly. Change the recursive algorithm above to solve the Tower of Hanoi with this new restriction. How many steps (use big O notation) are needed now?","title":"Problem 25.1"},{"location":"25-tower.html#appendix-complete-code","text":"#include \"cs1010.h\" /** * Move Disk k from Peg source to Peg dest. * * @param[in] k The disk to move * @param[in] source The peg Disk k is currently at. * @param[in] dest The peg Disk k is moved to. */ void move ( long k , long source , long dest ) { cs1010_print_string ( \"Disk \" ); cs1010_print_long ( k ); cs1010_print_string ( \": Peg \" ); cs1010_print_long ( source ); cs1010_print_string ( \" -> Peg \" ); cs1010_println_long ( dest ); } void solve ( long k , long source , long dest , long placeholder ) { if ( k == 1 ) { move ( k , source , dest ); return ; } solve ( k - 1 , source , placeholder , dest ); move ( k , source , dest ); solve ( k - 1 , placeholder , dest , source ); } int main () { long k = cs1010_read_long (); solve ( k , 1 , 3 , 2 ); }","title":"Appendix: Complete Code"},{"location":"26-permutation.html","text":"Unit 26: Permutations We have been using recursions to either compute or find a solution to a problem. In this unit, let's look at another useful application of recursion: to generate all possible permutations or combinations of items. Let's see a simple example of this: generate all permutations of the characters in a string of length n n . For simplicity, we assume that there is no repetition in the string. Recursive Formulation To formulate a recursive solution, as usual, let's simplify the problem. A simpler version of the problem is to permute a string of length n-1 n-1 . The trivial case is when we generate the permutation of a string with one character. There is only one possible permutation! Now, by wishful thinking, we assume that we know how to generate all permutations of a string of length n-1 n-1 . Here is what we do to generate all permutations of a string of length n n . For each character i i in the string, we move i i to the first position in the string. We have n-1 n-1 characters left, which we solve recursively, generating all possible permutations with i i as the first character. For example, consider a string length 3, abc . We start with a as the first character, and generate all the permutations of the string bc . We get two permutations abc and acb . The next character is b . We generate all permutations of the string ac . We get bac and bca . Similarly, we get the permutations cab and cba by considering c as the first character and permutating ba . The Code The idea above is implemented as the following: void permute ( char a [], long len , long curr ) { // permute characters a[curr]..a[len-1] and print out a for each permutation. if ( curr == len - 1 ) { cs1010_println_string ( a ); return ; } permute ( a , len , curr + 1 ); for ( long i = curr + 1 ; i < len ; i += 1 ) { swap ( a , curr , i ); permute ( a , len , curr + 1 ); swap ( a , i , curr ); } } Lines 3-6 above corresponds to the base case, where we have reached the end of the string, there is only one character left to permutate. Since there is only one possible permutation, we do not need to do anything except to print out the permutated string. Line 8 permutes the remaining string, a[curr + 1] to a[len - 1] , with character a[curr] intact. Lines 9-13 is a for loop which loops through all characters a[curr + 1] to a[len - 1] , and swaps each one to the position of a[curr] , and recursively permutes the string a[curr + 1] .. a[len - 1] . When we are done, we swap back the original a[curr] , this is to ensure that the string remains unchanged after permute is called. Running Time How efficient is the function permute ? We know that for a string of length n n , there are n! n! permutations, so the function permute should be at least n! n! . If it runs in O(n!) O(n!) steps, then our function above is as efficient as it can get. Let the number of times permute is called when we pass in a string of length n n be T(n) T(n) . Each invocation of permute(a, n, k) calls permute(a, n, k+1) recursively n-k n-k times. The first call to permute is permute(a, n, 0) . We stop when we call permute(a, n, n-1) . So T(1) = 1 T(1) = 1 . So, we have: T(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n! T(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n! We made n! n! calls to permute , so the function permute is as efficient as it gets. Problem Set Problem Set 26.1 In the code above, we assume that the string contains distinct characters. If there are duplicate characters in the string, duplicate permutations will be generated. For instance, if the input is aaa , the code above would print aaa six times. We can fix this by making a small change to the function permute above so that it does not generate duplicate permutations. This can be done by adding a condition (Line A). Write a boolean function that we can call in Line A to check if we should continue to permute the rest of the string, and therefore avoid generating duplicate permutations when the input string contains duplicate characters. void permute ( char a [], long len , long curr ) { // permute characters a[curr]..a[len-1] and print out a for each permutation. if ( curr == len - 1 ) { cs1010_println_string ( a ); return ; } permute ( a , len , curr + 1 ); for ( long i = curr + 1 ; i < len ; i += 1 ) { if (...) { // Line A swap ( a , curr , i ); permute ( a , len , curr + 1 ); swap ( a , i , curr ); } } } Appendix: Complete Code Written in Lecture #include \"cs1010.h\" #include <stdbool.h> #include <stdio.h> #include <string.h> void swap ( char a [], long i , long j ) { char temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } void permute ( char str [], long n , long k ) { if ( k == n - 1 ) { cs1010_println_string ( str ); return ; } permute ( str , n , k + 1 ); for ( long i = k + 1 ; i < n ; i += 1 ) { swap ( str , k , i ); permute ( str , n , k + 1 ); swap ( str , i , k ); } } int main () { char * str = cs1010_read_word (); permute ( str , strlen ( str ), 0 ); free ( str ); }","title":"26. Permutation"},{"location":"26-permutation.html#unit-26-permutations","text":"We have been using recursions to either compute or find a solution to a problem. In this unit, let's look at another useful application of recursion: to generate all possible permutations or combinations of items. Let's see a simple example of this: generate all permutations of the characters in a string of length n n . For simplicity, we assume that there is no repetition in the string.","title":"Unit 26: Permutations"},{"location":"26-permutation.html#recursive-formulation","text":"To formulate a recursive solution, as usual, let's simplify the problem. A simpler version of the problem is to permute a string of length n-1 n-1 . The trivial case is when we generate the permutation of a string with one character. There is only one possible permutation! Now, by wishful thinking, we assume that we know how to generate all permutations of a string of length n-1 n-1 . Here is what we do to generate all permutations of a string of length n n . For each character i i in the string, we move i i to the first position in the string. We have n-1 n-1 characters left, which we solve recursively, generating all possible permutations with i i as the first character. For example, consider a string length 3, abc . We start with a as the first character, and generate all the permutations of the string bc . We get two permutations abc and acb . The next character is b . We generate all permutations of the string ac . We get bac and bca . Similarly, we get the permutations cab and cba by considering c as the first character and permutating ba .","title":"Recursive Formulation"},{"location":"26-permutation.html#the-code","text":"The idea above is implemented as the following: void permute ( char a [], long len , long curr ) { // permute characters a[curr]..a[len-1] and print out a for each permutation. if ( curr == len - 1 ) { cs1010_println_string ( a ); return ; } permute ( a , len , curr + 1 ); for ( long i = curr + 1 ; i < len ; i += 1 ) { swap ( a , curr , i ); permute ( a , len , curr + 1 ); swap ( a , i , curr ); } } Lines 3-6 above corresponds to the base case, where we have reached the end of the string, there is only one character left to permutate. Since there is only one possible permutation, we do not need to do anything except to print out the permutated string. Line 8 permutes the remaining string, a[curr + 1] to a[len - 1] , with character a[curr] intact. Lines 9-13 is a for loop which loops through all characters a[curr + 1] to a[len - 1] , and swaps each one to the position of a[curr] , and recursively permutes the string a[curr + 1] .. a[len - 1] . When we are done, we swap back the original a[curr] , this is to ensure that the string remains unchanged after permute is called.","title":"The Code"},{"location":"26-permutation.html#running-time","text":"How efficient is the function permute ? We know that for a string of length n n , there are n! n! permutations, so the function permute should be at least n! n! . If it runs in O(n!) O(n!) steps, then our function above is as efficient as it can get. Let the number of times permute is called when we pass in a string of length n n be T(n) T(n) . Each invocation of permute(a, n, k) calls permute(a, n, k+1) recursively n-k n-k times. The first call to permute is permute(a, n, 0) . We stop when we call permute(a, n, n-1) . So T(1) = 1 T(1) = 1 . So, we have: T(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n! T(n) = nT(n-1) = n(n-1)T(n-2) = n(n-1)(n-2)T(n-3) = .. = n(n-1)(n-2)..T(1) = n! We made n! n! calls to permute , so the function permute is as efficient as it gets.","title":"Running Time"},{"location":"26-permutation.html#problem-set","text":"","title":"Problem Set"},{"location":"26-permutation.html#problem-set-261","text":"In the code above, we assume that the string contains distinct characters. If there are duplicate characters in the string, duplicate permutations will be generated. For instance, if the input is aaa , the code above would print aaa six times. We can fix this by making a small change to the function permute above so that it does not generate duplicate permutations. This can be done by adding a condition (Line A). Write a boolean function that we can call in Line A to check if we should continue to permute the rest of the string, and therefore avoid generating duplicate permutations when the input string contains duplicate characters. void permute ( char a [], long len , long curr ) { // permute characters a[curr]..a[len-1] and print out a for each permutation. if ( curr == len - 1 ) { cs1010_println_string ( a ); return ; } permute ( a , len , curr + 1 ); for ( long i = curr + 1 ; i < len ; i += 1 ) { if (...) { // Line A swap ( a , curr , i ); permute ( a , len , curr + 1 ); swap ( a , i , curr ); } } }","title":"Problem Set 26.1"},{"location":"26-permutation.html#appendix-complete-code-written-in-lecture","text":"#include \"cs1010.h\" #include <stdbool.h> #include <stdio.h> #include <string.h> void swap ( char a [], long i , long j ) { char temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } void permute ( char str [], long n , long k ) { if ( k == n - 1 ) { cs1010_println_string ( str ); return ; } permute ( str , n , k + 1 ); for ( long i = k + 1 ; i < n ; i += 1 ) { swap ( str , k , i ); permute ( str , n , k + 1 ); swap ( str , i , k ); } } int main () { char * str = cs1010_read_word (); permute ( str , strlen ( str ), 0 ); free ( str ); }","title":"Appendix: Complete Code Written in Lecture"},{"location":"27-queens.html","text":"Unit 27: N Queens We now look at how recursion can help with solving problems that require searching and backtracking . A classical example for this is the n n -queens problem, which can be stated as given a n \\times n n \\times n chessboard, find a possible placement of n n queens on the chessboard, such that the queens do not threaten each other. In other words, there is exactly one queen in each row, in each column, and in each diagonal. The 8-queens puzzle was first published by Max Bezzel in 1848, with the first solution published Franz Nauck in 1850. The generalized n n -queens problems were introduced later. It is known that there is no solution for n = 2 n = 2 and n = 3 n = 3 , but a solution exists for n > 3 n > 3 . If we visualize the chessboard as a 2D array, with # as the position of a queen, and . as an empty position on the board, then a solution to the 4-queens problem looks like this: .#.. ...# #... ..#. Recursive Formulation Let's see how we can formulate the problem recursively. The first step is to simplify the problem to the most trivial case where we can solve it. It is tempting to say that a simpler version of the problem is an n-1 n-1 -queens problem, and so the most trivial case is 1-queen. While the solution to 1-queen is trivial, there is no solution to both 2-queen and 3-queen problems. Further, if we have found a solution to the n-1 n-1 -queens problem, extending it to a solution of n n -queens problem is not trivial. Approach 1: Generate All Permutations As a start, let's borrow the idea from Unit 26 and generate all permutations of the queens' positions. Let's label the columns a , b , c , .. etc. Since we know that there must be exactly one queen in each row, and one queen in each column, the positions of the queens can be represented as a string that is a permutation of abcde.. . For instance, the solution of the 4-queen problem depicted above can be represented by bdac . A simple algorithm is thus to generate all possible n! n! permutations, and for each one, check if it is a valid placement. We already ensure that there is exactly one queen per row and one queen per column. It remains to check that the queens do not threaten each other diagonally. Let's write a function that checks, given a string representation of the queen positions, whether there is any queen that threaten another or not: bool has_a_queen_in_diagonal ( char queens [], long len , long i ) { char curr_col = queens [ i ]; char left_col = curr_col - 1 ; char right_col = curr_col + 1 ; for ( long row = i + 1 ; row < len ; row += 1 ) { if ( queens [ row ] == left_col || queens [ row ] == right_col ) { return true ; } left_col -= 1 ; right_col += 1 ; } return false ; } bool threaten_each_other_diagonally ( char queens [], long len ) { for ( long i = 0 ; i < len ; i += 1 ) { // for each queen in row i, check rows i+1 onwards, // on both left (-=1) and right (+=1) side, if there // is a queen in that column. if ( has_a_queen_in_diagonal ( queens , len , i )) { return true ; } } return false ; } Solving the n n queens problem is then easy. The code below prints out all possible solutions to the n n queens problem. void nqueens ( char queens [], long n , long row ) { if ( row == n - 1 ) { if ( ! threaten_each_other_diagonally ( queens , n )) { cs1010_println_string ( queens ); } return ; } nqueens ( queens , n , row + 1 ); for ( long i = row + 1 ; i < n ; i ++ ) { swap ( queens , row , i ); nqueens ( queens , n , row + 1 ); swap ( queens , row , i ); } } Approach 2: Pruning Impossible Solutions One of the principles to writing efficient code is to avoid doing useless work. The code above, which tests all permutations, actually generates much work that is useless. Suppose the queens in the first two rows already threaten each other, then, there is no need to continue to generate all possible placements of queens for the remaining rows. This concept is called pruning and is a key to speeding up many searching-based solutions. We want to prune away bad solutions as early as possible. This can be achieved easily, by checking if the queens already placed on the first k k rows threaten each other. void nqueens ( char queens [], long n , long row ) { if ( row == n - 1 ) { if ( ! threaten_each_other_diagonally ( queens , n )) { cs1010_println_string ( queens ); } return ; } if ( ! threaten_each_other_diagonally ( queens , row )) { nqueens ( queens , n , row + 1 ); } for ( long i = row + 1 ; i < n ; i ++ ) { swap ( queens , row , i ); if ( ! threaten_each_other_diagonally ( queens , row )) { nqueens ( queens , n , row + 1 ); } swap ( queens , row , i ); } } Adding these two conditionals can speed up the code significantly. Problem Set 27 Problem 27.1 In the code for Approach 2 above, we check if the queens placed on Rows 0 to row threaten each other, and call nqueens recursively only if these queens do not threaten each other. Identify the repetitive work being done in the calls threaten_each_other_diagonally , and suggest a way to remove the repetitive work. Problem 27.2 Consider the code to generate all possible permutations of a string from Problem 26.1. Suppose that we restrict the permutations to those where the same character does not appear next to each other. Modify the solution to Problem 26.1 to prune away permutations where the same character appears more than once consecutively. Appendix: Complete Code Written in Lecture #include \"cs1010.h\" #include <stdbool.h> #include <unistd.h> void draw ( char queens [], long n , long row ) { static char clear_screen [] = { 27 , '[' , '2' , 'J' , 27 , '[' , ';' , 'H' , 0 }; cs1010_print_string ( clear_screen ); for ( long i = 0 ; i <= row ; i += 1 ) { for ( char col = 'a' ; col < 'a' + n ; col += 1 ) { if ( queens [ i ] == col ) { putchar ( '#' ); } else { putchar ( '.' ); } } putchar ( '\\n' ); } for ( long i = row + 1 ; i < n ; i += 1 ) { for ( long col = 0 ; col < n ; col += 1 ) { putchar ( '.' ); } putchar ( '\\n' ); } usleep ( 10000 ); } void swap ( char a [], long i , long j ) { char temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } bool has_a_queen_in_diagonal ( const char queens [], long len , long i ) { char curr_col = queens [ i ]; char left_col = curr_col - 1 ; char right_col = curr_col + 1 ; for ( long row = i + 1 ; row < len ; row += 1 ) { if ( queens [ row ] == left_col || queens [ row ] == right_col ) { return true ; } left_col -= 1 ; right_col += 1 ; } return false ; } bool threaten_each_other_diagonally ( char queens [], long len ) { for ( long i = 0 ; i < len ; i += 1 ) { // for each queen in row i, check rows i+1 onwards, // on both left (-=1) and right (+=1) side, if there // is a queen in that column. if ( has_a_queen_in_diagonal ( queens , len , i )) { return true ; } } return false ; } bool nqueens ( char queens [], long n , long row ) { if ( row == n - 1 ) { draw ( queens , n , row ); if ( ! threaten_each_other_diagonally ( queens , n )) { cs1010_println_string ( queens ); return true ; } return false ; } if ( ! threaten_each_other_diagonally ( queens , row )) { bool result = nqueens ( queens , n , row + 1 ); if ( result ) { return true ; } } for ( long i = row + 1 ; i < n ; i += 1 ) { swap ( queens , row , i ); if ( ! threaten_each_other_diagonally ( queens , row )) { bool result = nqueens ( queens , n , row + 1 ); if ( result ) { return true ; } } swap ( queens , i , row ); } return false ; } int main () { long n = cs1010_read_long (); char queens [ n + 1 ]; char curr = 'a' ; for ( long i = 0 ; i < n ; i ++ ) { queens [ i ] = curr ; curr += 1 ; } queens [ n ] = '\\0' ; nqueens ( queens , n , 0 ); }","title":"27. N Queens"},{"location":"27-queens.html#unit-27-n-queens","text":"We now look at how recursion can help with solving problems that require searching and backtracking . A classical example for this is the n n -queens problem, which can be stated as given a n \\times n n \\times n chessboard, find a possible placement of n n queens on the chessboard, such that the queens do not threaten each other. In other words, there is exactly one queen in each row, in each column, and in each diagonal. The 8-queens puzzle was first published by Max Bezzel in 1848, with the first solution published Franz Nauck in 1850. The generalized n n -queens problems were introduced later. It is known that there is no solution for n = 2 n = 2 and n = 3 n = 3 , but a solution exists for n > 3 n > 3 . If we visualize the chessboard as a 2D array, with # as the position of a queen, and . as an empty position on the board, then a solution to the 4-queens problem looks like this: .#.. ...# #... ..#.","title":"Unit 27: N Queens"},{"location":"27-queens.html#recursive-formulation","text":"Let's see how we can formulate the problem recursively. The first step is to simplify the problem to the most trivial case where we can solve it. It is tempting to say that a simpler version of the problem is an n-1 n-1 -queens problem, and so the most trivial case is 1-queen. While the solution to 1-queen is trivial, there is no solution to both 2-queen and 3-queen problems. Further, if we have found a solution to the n-1 n-1 -queens problem, extending it to a solution of n n -queens problem is not trivial.","title":"Recursive Formulation"},{"location":"27-queens.html#approach-1-generate-all-permutations","text":"As a start, let's borrow the idea from Unit 26 and generate all permutations of the queens' positions. Let's label the columns a , b , c , .. etc. Since we know that there must be exactly one queen in each row, and one queen in each column, the positions of the queens can be represented as a string that is a permutation of abcde.. . For instance, the solution of the 4-queen problem depicted above can be represented by bdac . A simple algorithm is thus to generate all possible n! n! permutations, and for each one, check if it is a valid placement. We already ensure that there is exactly one queen per row and one queen per column. It remains to check that the queens do not threaten each other diagonally. Let's write a function that checks, given a string representation of the queen positions, whether there is any queen that threaten another or not: bool has_a_queen_in_diagonal ( char queens [], long len , long i ) { char curr_col = queens [ i ]; char left_col = curr_col - 1 ; char right_col = curr_col + 1 ; for ( long row = i + 1 ; row < len ; row += 1 ) { if ( queens [ row ] == left_col || queens [ row ] == right_col ) { return true ; } left_col -= 1 ; right_col += 1 ; } return false ; } bool threaten_each_other_diagonally ( char queens [], long len ) { for ( long i = 0 ; i < len ; i += 1 ) { // for each queen in row i, check rows i+1 onwards, // on both left (-=1) and right (+=1) side, if there // is a queen in that column. if ( has_a_queen_in_diagonal ( queens , len , i )) { return true ; } } return false ; } Solving the n n queens problem is then easy. The code below prints out all possible solutions to the n n queens problem. void nqueens ( char queens [], long n , long row ) { if ( row == n - 1 ) { if ( ! threaten_each_other_diagonally ( queens , n )) { cs1010_println_string ( queens ); } return ; } nqueens ( queens , n , row + 1 ); for ( long i = row + 1 ; i < n ; i ++ ) { swap ( queens , row , i ); nqueens ( queens , n , row + 1 ); swap ( queens , row , i ); } }","title":"Approach 1: Generate All Permutations"},{"location":"27-queens.html#approach-2-pruning-impossible-solutions","text":"One of the principles to writing efficient code is to avoid doing useless work. The code above, which tests all permutations, actually generates much work that is useless. Suppose the queens in the first two rows already threaten each other, then, there is no need to continue to generate all possible placements of queens for the remaining rows. This concept is called pruning and is a key to speeding up many searching-based solutions. We want to prune away bad solutions as early as possible. This can be achieved easily, by checking if the queens already placed on the first k k rows threaten each other. void nqueens ( char queens [], long n , long row ) { if ( row == n - 1 ) { if ( ! threaten_each_other_diagonally ( queens , n )) { cs1010_println_string ( queens ); } return ; } if ( ! threaten_each_other_diagonally ( queens , row )) { nqueens ( queens , n , row + 1 ); } for ( long i = row + 1 ; i < n ; i ++ ) { swap ( queens , row , i ); if ( ! threaten_each_other_diagonally ( queens , row )) { nqueens ( queens , n , row + 1 ); } swap ( queens , row , i ); } } Adding these two conditionals can speed up the code significantly.","title":"Approach 2: Pruning Impossible Solutions"},{"location":"27-queens.html#problem-set-27","text":"","title":"Problem Set 27"},{"location":"27-queens.html#problem-271","text":"In the code for Approach 2 above, we check if the queens placed on Rows 0 to row threaten each other, and call nqueens recursively only if these queens do not threaten each other. Identify the repetitive work being done in the calls threaten_each_other_diagonally , and suggest a way to remove the repetitive work.","title":"Problem 27.1"},{"location":"27-queens.html#problem-272","text":"Consider the code to generate all possible permutations of a string from Problem 26.1. Suppose that we restrict the permutations to those where the same character does not appear next to each other. Modify the solution to Problem 26.1 to prune away permutations where the same character appears more than once consecutively.","title":"Problem 27.2"},{"location":"27-queens.html#appendix-complete-code-written-in-lecture","text":"#include \"cs1010.h\" #include <stdbool.h> #include <unistd.h> void draw ( char queens [], long n , long row ) { static char clear_screen [] = { 27 , '[' , '2' , 'J' , 27 , '[' , ';' , 'H' , 0 }; cs1010_print_string ( clear_screen ); for ( long i = 0 ; i <= row ; i += 1 ) { for ( char col = 'a' ; col < 'a' + n ; col += 1 ) { if ( queens [ i ] == col ) { putchar ( '#' ); } else { putchar ( '.' ); } } putchar ( '\\n' ); } for ( long i = row + 1 ; i < n ; i += 1 ) { for ( long col = 0 ; col < n ; col += 1 ) { putchar ( '.' ); } putchar ( '\\n' ); } usleep ( 10000 ); } void swap ( char a [], long i , long j ) { char temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } bool has_a_queen_in_diagonal ( const char queens [], long len , long i ) { char curr_col = queens [ i ]; char left_col = curr_col - 1 ; char right_col = curr_col + 1 ; for ( long row = i + 1 ; row < len ; row += 1 ) { if ( queens [ row ] == left_col || queens [ row ] == right_col ) { return true ; } left_col -= 1 ; right_col += 1 ; } return false ; } bool threaten_each_other_diagonally ( char queens [], long len ) { for ( long i = 0 ; i < len ; i += 1 ) { // for each queen in row i, check rows i+1 onwards, // on both left (-=1) and right (+=1) side, if there // is a queen in that column. if ( has_a_queen_in_diagonal ( queens , len , i )) { return true ; } } return false ; } bool nqueens ( char queens [], long n , long row ) { if ( row == n - 1 ) { draw ( queens , n , row ); if ( ! threaten_each_other_diagonally ( queens , n )) { cs1010_println_string ( queens ); return true ; } return false ; } if ( ! threaten_each_other_diagonally ( queens , row )) { bool result = nqueens ( queens , n , row + 1 ); if ( result ) { return true ; } } for ( long i = row + 1 ; i < n ; i += 1 ) { swap ( queens , row , i ); if ( ! threaten_each_other_diagonally ( queens , row )) { bool result = nqueens ( queens , n , row + 1 ); if ( result ) { return true ; } } swap ( queens , i , row ); } return false ; } int main () { long n = cs1010_read_long (); char queens [ n + 1 ]; char curr = 'a' ; for ( long i = 0 ; i < n ; i ++ ) { queens [ i ] = curr ; curr += 1 ; } queens [ n ] = '\\0' ; nqueens ( queens , n , 0 ); }","title":"Appendix: Complete Code Written in Lecture"},{"location":"28-struct.html","text":"Unit 28: Structures We have so far been working with numbers, characters, and strings. Not all real-world objects can be easily abstracted and represented with numbers and characters. It is useful to create our own compound data type that represent real worlds objects. Each object typically has one or more attributes, which can be of different types: A module has a code, a title, and the number of MCs; A person has a name, height, weight, and age; A phone has a model, price, and brand. If you look back at the code that we have written, often there are multiple variables that are related to each other and \"belongs together.\" When we pass one as an argument into a function, often we need to pass another. It is useful to group them into a compound data type as well. For instance: A 1D array and its length; A 2D array, its width, and its height; A pixel, its row, its column, and its color. Structure in C In C, we can define a compound data type using a structure, through the C keyword struct . The syntax looks like this: struct matrix { double ** array ; long num_of_rows ; long num_of_columns ; }; In the definition above, the structure is given a name, matrix . The structure contains three members . The first is a pointer to a 2D array, the other two is the number of rows and number of columns of that array. Note that we need a semicolon ; after the definition of a struct . Here are a few more examples: struct circle { double x_of_center ; double y_of_center ; double radius ; }; struct module { char * code ; char * title ; long mc ; }; Declaring and Initializing a Structure Variable Let's see an example of how we can declare and initialize a structure variable: struct module cs1010 ; cs1010 . code = \"CS1010\" ; cs1010 . title = \"Programming Methodology\" ; cs1010 . mc = 4 ; Line 1 above declares a variable called cs1010 . Lines 2-4 initialize each member of the structure. Note that we use . to access each member. An alternative is to use a compound literal : struct module cs1010 = { . code = \"CS1010\" , . title = \"Programming Methodology\" , . mc = 4 }; Using compound literal is convenient in certain cases, as uninitialized members are set to 0 (similar to initializers of arrays). You can read and write to individual members of a structure variable just like any other variables. cs1010.mc = hours_spent_per_week/2.5; cs1010_println_long(cs1010.mc); Structure as Parameters We can pass a structure variable into a function just like a non-array variable. Unlike an array, a struct is called by value, i.e., it is copied onto the call stack of the function. Hence, the code below does not actually update the MCs of CS1010: void update_mc(struct module cs1010, long hours_spent_per_week) { cs1010.mc = hours_spent_per_week/2.5; } To call a structure by reference, we can pass in its pointer. void update_mc(struct module *cs1010, long hours_spent_per_week) { (*cs1010).mc = hours_spent_per_week/2.5; } The latter example is a more common idiom. Since a structure can contain multiple fields and usually occupies more bytes than a pointer, it is less efficient to copy a structure onto the call stack compared to copying its pointer. Since this is common, C provides another syntax for accessing the member of a structure through its pointer, using the \"arrow\" notation\" void update_mc(struct module *cs1010, long hours_spent_per_week) { cs1010->mc = hours_spent_per_week/2.5; } Returning a Structure A function can return structure. Remember in Unit 17 we said that C functions can return only one value and one way to get around this limitation is to use call by reference and the other is to use struct ? Here is how we use struct to return more than one values: struct answer { long max_n; long max_num_steps; }; struct answer find_max_steps ( long n ) { struct answer ans = { . max_n = 1 , . max_num_steps = 0 }; for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= ans . max_num_steps ) { ans . max_n = i ; ans . max_num_steps = num_of_steps ; } } return ans ; } When a function returns a struct , the structure gets copied back to the caller. Defining a Structure as a Type To avoid writing the keyword 'struct every time we declare a variable or parameter, let's introduce another keyword in C: typedef`. C allows programmers to define their own type based on the existing types. Suppose that I want a type that represents a color component (red, green, or blue) of a pixel. Each pixel can have a value between 0 to 255. So we can represent it with an unsigned char . I can define: typedef unsigned char color_t ; Recall that we use the suffix _t convention to denote user-defined type. You have probably seen these two types elsewhere size_t and time_t in the past. Now that we have defined color_t as a new type that is equivalent to unsigned char , we can use it just like another type: color_t r; void paint(color_t r, color_t g, color_t b); Using typedef on struct frees us from typing the word struct every time. We can do so with either: typedef struct module { char * code ; char * title ; long mc ; } module ; or typedef struct { char * code ; char * title ; long mc ; } module ; In either case, we can just use module like any other type: void update_mc(module cs1010, long hours_spent_per_week) { cs1010.mc = hours_spent_per_week/2.5; } If you use third-party libraries or C libraries, chances are you will come across such type. Use of typedef on struct is controversial. There is a school of thoughts that think it makes the code harder to read as it obscured the fact that a variable is a struct. Hidden costs in copying the variable onto the call stack as a parameter or returned value become non-obvious. Interested students can read Linux's Kernel Coding Style for the pros and cons of this approach.","title":"28. Structure"},{"location":"28-struct.html#unit-28-structures","text":"We have so far been working with numbers, characters, and strings. Not all real-world objects can be easily abstracted and represented with numbers and characters. It is useful to create our own compound data type that represent real worlds objects. Each object typically has one or more attributes, which can be of different types: A module has a code, a title, and the number of MCs; A person has a name, height, weight, and age; A phone has a model, price, and brand. If you look back at the code that we have written, often there are multiple variables that are related to each other and \"belongs together.\" When we pass one as an argument into a function, often we need to pass another. It is useful to group them into a compound data type as well. For instance: A 1D array and its length; A 2D array, its width, and its height; A pixel, its row, its column, and its color.","title":"Unit 28: Structures"},{"location":"28-struct.html#structure-in-c","text":"In C, we can define a compound data type using a structure, through the C keyword struct . The syntax looks like this: struct matrix { double ** array ; long num_of_rows ; long num_of_columns ; }; In the definition above, the structure is given a name, matrix . The structure contains three members . The first is a pointer to a 2D array, the other two is the number of rows and number of columns of that array. Note that we need a semicolon ; after the definition of a struct . Here are a few more examples: struct circle { double x_of_center ; double y_of_center ; double radius ; }; struct module { char * code ; char * title ; long mc ; };","title":"Structure in C"},{"location":"28-struct.html#declaring-and-initializing-a-structure-variable","text":"Let's see an example of how we can declare and initialize a structure variable: struct module cs1010 ; cs1010 . code = \"CS1010\" ; cs1010 . title = \"Programming Methodology\" ; cs1010 . mc = 4 ; Line 1 above declares a variable called cs1010 . Lines 2-4 initialize each member of the structure. Note that we use . to access each member. An alternative is to use a compound literal : struct module cs1010 = { . code = \"CS1010\" , . title = \"Programming Methodology\" , . mc = 4 }; Using compound literal is convenient in certain cases, as uninitialized members are set to 0 (similar to initializers of arrays). You can read and write to individual members of a structure variable just like any other variables. cs1010.mc = hours_spent_per_week/2.5; cs1010_println_long(cs1010.mc);","title":"Declaring and Initializing a Structure Variable"},{"location":"28-struct.html#structure-as-parameters","text":"We can pass a structure variable into a function just like a non-array variable. Unlike an array, a struct is called by value, i.e., it is copied onto the call stack of the function. Hence, the code below does not actually update the MCs of CS1010: void update_mc(struct module cs1010, long hours_spent_per_week) { cs1010.mc = hours_spent_per_week/2.5; } To call a structure by reference, we can pass in its pointer. void update_mc(struct module *cs1010, long hours_spent_per_week) { (*cs1010).mc = hours_spent_per_week/2.5; } The latter example is a more common idiom. Since a structure can contain multiple fields and usually occupies more bytes than a pointer, it is less efficient to copy a structure onto the call stack compared to copying its pointer. Since this is common, C provides another syntax for accessing the member of a structure through its pointer, using the \"arrow\" notation\" void update_mc(struct module *cs1010, long hours_spent_per_week) { cs1010->mc = hours_spent_per_week/2.5; }","title":"Structure as Parameters"},{"location":"28-struct.html#returning-a-structure","text":"A function can return structure. Remember in Unit 17 we said that C functions can return only one value and one way to get around this limitation is to use call by reference and the other is to use struct ? Here is how we use struct to return more than one values: struct answer { long max_n; long max_num_steps; }; struct answer find_max_steps ( long n ) { struct answer ans = { . max_n = 1 , . max_num_steps = 0 }; for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= ans . max_num_steps ) { ans . max_n = i ; ans . max_num_steps = num_of_steps ; } } return ans ; } When a function returns a struct , the structure gets copied back to the caller.","title":"Returning a Structure"},{"location":"28-struct.html#defining-a-structure-as-a-type","text":"To avoid writing the keyword 'struct every time we declare a variable or parameter, let's introduce another keyword in C: typedef`. C allows programmers to define their own type based on the existing types. Suppose that I want a type that represents a color component (red, green, or blue) of a pixel. Each pixel can have a value between 0 to 255. So we can represent it with an unsigned char . I can define: typedef unsigned char color_t ; Recall that we use the suffix _t convention to denote user-defined type. You have probably seen these two types elsewhere size_t and time_t in the past. Now that we have defined color_t as a new type that is equivalent to unsigned char , we can use it just like another type: color_t r; void paint(color_t r, color_t g, color_t b); Using typedef on struct frees us from typing the word struct every time. We can do so with either: typedef struct module { char * code ; char * title ; long mc ; } module ; or typedef struct { char * code ; char * title ; long mc ; } module ; In either case, we can just use module like any other type: void update_mc(module cs1010, long hours_spent_per_week) { cs1010.mc = hours_spent_per_week/2.5; } If you use third-party libraries or C libraries, chances are you will come across such type. Use of typedef on struct is controversial. There is a school of thoughts that think it makes the code harder to read as it obscured the fact that a variable is a struct. Hidden costs in copying the variable onto the call stack as a parameter or returned value become non-obvious. Interested students can read Linux's Kernel Coding Style for the pros and cons of this approach.","title":"Defining a Structure as a Type"},{"location":"29-stdio.html","text":"Unit 29: Standard I/O Functions We have been shielding you from the pain and pitfalls of using C I/O functions. Since you are close to \"graduate\" from CS1010, this is a good time to show you what the real world is like. printf The function printf is used to print a formatted string to the standard output. Unlike functions that we have seen so far, printf can take in a variable number of arguments, but it must have at least one argument -- a string written in a certain format. The rest of the arguments can be of different types. Let's look at an example: char * name = \"Siri\" ; printf ( \"Hello! My name is %s. \\n \" , name ); The code above prints Hello! My name is Siri. . There are two arguments to printf , both are strings. The first is the string to print. There is a placeholder %s in the string, which will be replaced by the second argument name . The string to print ends with \\n , which is the new line character. The placeholder %s is called a format modifier . It controls how to interpret the arguments (i.e., what type) and how to format the output. The general format is: %[flags][field_width][.precision][length_modifier]specifier The letter after % controls the interpretation of the argument. s for string, c for character, d for integer (base 10), f for floating point number, p for pointer (base 16). We can additionally prepend this with length modifier . ld for long integer, lld for long long , and lf for double . To format the output, we can prepend it with a number to indicate its field width , or minimum space used when printing. E.g., %3d will pad the number printed with space if the number printed is less than 3 digits. Adding a flag 0 in front, %03d , will pad the number with 0s if the number printed is less than 3 digits. Other flags include + , which tells printf to print a sign ( + or - ) for the number. For floating point numbers, we can additionally control the precision , or the number of digits printed after the decimal point. %3.4lf will print a double to four decimal points. Note: cs1010_println_double uses %.4lf as the format modifier. Pitfalls when using printf Mismatch Types printf does not check for the type of arguments we pass to it. The compiler does, but it only politely warns us instead of throwing an error like other type mismatches. If you ignore such warnings, you might print strange things like: printf ( \"%d %f \\n \" , 100000000000 , 100000000000 ); or worse, crash your program: printf ( \"%s %s \\n \" , 100000000000 , 100000000000 ); Mismatch Number of Arguments Since printf expects a variable number of arguments, you can pass it fewer arguments than expected and the code would still compile (with warnings). If you push ahead and run it anyway, printf will start to fetch arguments from the stack, pretending that it is there, causing weird things to happen. Consider: printf ( \"%d %s %s \\n \" , 10 ); It would cause printf to access memory content of the stack as strings. Printing User Input We should also never do this: char * str = cs1010_read_word (); printf ( str ); The reason is that we have no control over what the user would type as input: the user may type \"%s\" into the standard input, so the variable str now points to %s , which printf treats as a format modifier, and output the content of the stack! This is a huge security risk. We should always print a string using: printf ( \"%s\" , str ); scanf The function scanf is used to read inputs from the standard input. It requires us to pass in pointers to variables where we want to store the input value is. Like printf , it takes in one or more arguments, with the first argument being a format string containing one or more format specifier. The format specifier for scanf is simpler and has the following pattern: %[*][field_width][length_modifier]specifier For instance, to read an integer, a floating point number, and a string of at most 10 characters, long l ; double d ; char s [ 11 ]; scanf ( \"%ld %lf %10s\" , & l , & d , s ); scanf scans the standard input, try to match it to the format specified. The space in between the format specifier matches zero or more white spaces (space, tab, newline). Scanning stops when an input character does not match such a format character or when an input conversion fails. Adding a * to the format modifier means that scanf should consume the inputs but not store it in any variables. This, combined with %[``] is useful to clear any remaining data from the standard input. Pitfalls When Using scanf Checking for Error The function scanf fails silently when the input character does not match a format or when the input conversion fails. It might return a totally unexpected input. We should always check the return value of scanf to make sure that it is reading properly. long a ; scanf ( \"%ld\" , & a ); printf ( \"%ld\" , a ); The code above might print uninitialized value if the input is not an integer. We should check long a ; long result = scanf ( \"%ld\" , & a ); if ( result != 1 ) { printf ( \"%ld\" , a ); } The above, however, does not properly \"clear\" the standard input of the incorrect input. So the next scanf calls would still try to read it again! To clear the input, we can use the %*[^\\n] modifier, which read in any characters expect ( ^ ) the newline ( \\n ). long a ; long result = scanf ( \"%ld\" , & a ); if ( result != 1 ) { printf ( \"%ld\" , a ); } else { scanf ( \"*[^ \\n ]\" ); } As a side note, the %[] modifier is useful to read in strings containing a certain range of characters only. E.g., you can read %[a-zA-Z0-9] to match any sequence of alphanumeric characters. Invalid Pointers Since scanf expects the caller to pass in pointers to variables for it to store the results, we need to be careful about what we pass in. It is easy to pass in something like this: long * a ; scanf ( \"%ld\" , a ); The compiler would not warn us since the type matches perfectly. The program may crash since the pointer is not pointing to a valid memory location accessible by the program. Buffer Overflow When we use scanf to read a string, it keeps reading until it reaches an empty space, and stores everything that it reads into an array. The problem here is that we do not know when it will stop reading, and therefore how big is the array that we need to allocate for the input! Let's say we do: char name [ 10 ]; printf ( \"What's your name?\" , name ); scanf ( \"%s\" , name ); printf ( \"Hello %s! \\n \" , name ); The program would crash if we enter a very long string in the standard input. You can read a beginners' guide away from scanf() for more information. fgets fgets is a better alternative to scanf for reading inputs (Note: this is what CS1010 library use internally). fgets takes three parameters, a pointer to a string (or buffer), the size of the buffer, and the input to read from (which can be a file, a network socket, or in our case, most of the time stdin ). The advantage of fgets is that it never overflows the buffer (it knows the size). Once we read the input, we can use functions such as strtol or strtod to convert the strings to long or double . Avoid atol or atof Instead of strtol or strtof , some old school textbooks might show you that you can convert a string to a long or a double using atol or atof . You should avoid these two functions (even the man pages of atof says so!). They do not provide any mechanism for error checking if the string is not a valid integer or if the input is out of range of the type. You can read the source code for the CS1010 library to see how it uses fgets , strtol and related functions to parse numbers and strings from the standard inputs.","title":"29. stdio"},{"location":"29-stdio.html#unit-29-standard-io-functions","text":"We have been shielding you from the pain and pitfalls of using C I/O functions. Since you are close to \"graduate\" from CS1010, this is a good time to show you what the real world is like.","title":"Unit 29: Standard I/O Functions"},{"location":"29-stdio.html#printf","text":"The function printf is used to print a formatted string to the standard output. Unlike functions that we have seen so far, printf can take in a variable number of arguments, but it must have at least one argument -- a string written in a certain format. The rest of the arguments can be of different types. Let's look at an example: char * name = \"Siri\" ; printf ( \"Hello! My name is %s. \\n \" , name ); The code above prints Hello! My name is Siri. . There are two arguments to printf , both are strings. The first is the string to print. There is a placeholder %s in the string, which will be replaced by the second argument name . The string to print ends with \\n , which is the new line character. The placeholder %s is called a format modifier . It controls how to interpret the arguments (i.e., what type) and how to format the output. The general format is: %[flags][field_width][.precision][length_modifier]specifier The letter after % controls the interpretation of the argument. s for string, c for character, d for integer (base 10), f for floating point number, p for pointer (base 16). We can additionally prepend this with length modifier . ld for long integer, lld for long long , and lf for double . To format the output, we can prepend it with a number to indicate its field width , or minimum space used when printing. E.g., %3d will pad the number printed with space if the number printed is less than 3 digits. Adding a flag 0 in front, %03d , will pad the number with 0s if the number printed is less than 3 digits. Other flags include + , which tells printf to print a sign ( + or - ) for the number. For floating point numbers, we can additionally control the precision , or the number of digits printed after the decimal point. %3.4lf will print a double to four decimal points. Note: cs1010_println_double uses %.4lf as the format modifier.","title":"printf"},{"location":"29-stdio.html#pitfalls-when-using-printf","text":"","title":"Pitfalls when using printf"},{"location":"29-stdio.html#mismatch-types","text":"printf does not check for the type of arguments we pass to it. The compiler does, but it only politely warns us instead of throwing an error like other type mismatches. If you ignore such warnings, you might print strange things like: printf ( \"%d %f \\n \" , 100000000000 , 100000000000 ); or worse, crash your program: printf ( \"%s %s \\n \" , 100000000000 , 100000000000 );","title":"Mismatch Types"},{"location":"29-stdio.html#mismatch-number-of-arguments","text":"Since printf expects a variable number of arguments, you can pass it fewer arguments than expected and the code would still compile (with warnings). If you push ahead and run it anyway, printf will start to fetch arguments from the stack, pretending that it is there, causing weird things to happen. Consider: printf ( \"%d %s %s \\n \" , 10 ); It would cause printf to access memory content of the stack as strings.","title":"Mismatch Number of Arguments"},{"location":"29-stdio.html#printing-user-input","text":"We should also never do this: char * str = cs1010_read_word (); printf ( str ); The reason is that we have no control over what the user would type as input: the user may type \"%s\" into the standard input, so the variable str now points to %s , which printf treats as a format modifier, and output the content of the stack! This is a huge security risk. We should always print a string using: printf ( \"%s\" , str );","title":"Printing User Input"},{"location":"29-stdio.html#scanf","text":"The function scanf is used to read inputs from the standard input. It requires us to pass in pointers to variables where we want to store the input value is. Like printf , it takes in one or more arguments, with the first argument being a format string containing one or more format specifier. The format specifier for scanf is simpler and has the following pattern: %[*][field_width][length_modifier]specifier For instance, to read an integer, a floating point number, and a string of at most 10 characters, long l ; double d ; char s [ 11 ]; scanf ( \"%ld %lf %10s\" , & l , & d , s ); scanf scans the standard input, try to match it to the format specified. The space in between the format specifier matches zero or more white spaces (space, tab, newline). Scanning stops when an input character does not match such a format character or when an input conversion fails. Adding a * to the format modifier means that scanf should consume the inputs but not store it in any variables. This, combined with %[``] is useful to clear any remaining data from the standard input.","title":"scanf"},{"location":"29-stdio.html#pitfalls-when-using-scanf","text":"","title":"Pitfalls When Using scanf"},{"location":"29-stdio.html#checking-for-error","text":"The function scanf fails silently when the input character does not match a format or when the input conversion fails. It might return a totally unexpected input. We should always check the return value of scanf to make sure that it is reading properly. long a ; scanf ( \"%ld\" , & a ); printf ( \"%ld\" , a ); The code above might print uninitialized value if the input is not an integer. We should check long a ; long result = scanf ( \"%ld\" , & a ); if ( result != 1 ) { printf ( \"%ld\" , a ); } The above, however, does not properly \"clear\" the standard input of the incorrect input. So the next scanf calls would still try to read it again! To clear the input, we can use the %*[^\\n] modifier, which read in any characters expect ( ^ ) the newline ( \\n ). long a ; long result = scanf ( \"%ld\" , & a ); if ( result != 1 ) { printf ( \"%ld\" , a ); } else { scanf ( \"*[^ \\n ]\" ); } As a side note, the %[] modifier is useful to read in strings containing a certain range of characters only. E.g., you can read %[a-zA-Z0-9] to match any sequence of alphanumeric characters.","title":"Checking for Error"},{"location":"29-stdio.html#invalid-pointers","text":"Since scanf expects the caller to pass in pointers to variables for it to store the results, we need to be careful about what we pass in. It is easy to pass in something like this: long * a ; scanf ( \"%ld\" , a ); The compiler would not warn us since the type matches perfectly. The program may crash since the pointer is not pointing to a valid memory location accessible by the program.","title":"Invalid Pointers"},{"location":"29-stdio.html#buffer-overflow","text":"When we use scanf to read a string, it keeps reading until it reaches an empty space, and stores everything that it reads into an array. The problem here is that we do not know when it will stop reading, and therefore how big is the array that we need to allocate for the input! Let's say we do: char name [ 10 ]; printf ( \"What's your name?\" , name ); scanf ( \"%s\" , name ); printf ( \"Hello %s! \\n \" , name ); The program would crash if we enter a very long string in the standard input. You can read a beginners' guide away from scanf() for more information.","title":"Buffer Overflow"},{"location":"29-stdio.html#fgets","text":"fgets is a better alternative to scanf for reading inputs (Note: this is what CS1010 library use internally). fgets takes three parameters, a pointer to a string (or buffer), the size of the buffer, and the input to read from (which can be a file, a network socket, or in our case, most of the time stdin ). The advantage of fgets is that it never overflows the buffer (it knows the size). Once we read the input, we can use functions such as strtol or strtod to convert the strings to long or double .","title":"fgets"},{"location":"29-stdio.html#avoid-atol-or-atof","text":"Instead of strtol or strtof , some old school textbooks might show you that you can convert a string to a long or a double using atol or atof . You should avoid these two functions (even the man pages of atof says so!). They do not provide any mechanism for error checking if the string is not a valid integer or if the input is out of range of the type. You can read the source code for the CS1010 library to see how it uses fgets , strtol and related functions to parse numbers and strings from the standard inputs.","title":"Avoid atol or atof"},{"location":"30-module.html","text":"Unit 30: Modules So far, in CS1010, you have written code that is fewer than 500 lines. Real world, complex, software, however, has many more lines of code than this . To keep the code manageable and to speed up compilation , often we break the code into separate compilation units -- into multiple C files. Functions that are relevant to each other are usually included into the same C file. These C files can be compiled independently and then linked together into the executable. Let's look at a toy example. Suppose we have two functions max and min , two commonly used functions the operates on an array, and we put them in the file array.c long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } long min ( long list [], long length ) { long min_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] < min_so_far ) { min_so_far = list [ i ]; } } return min_so_far ; } The file array.c does not contain a main function, because it is not meant to be a standalone executable, but just a collection of functions. If you compile it with clang array.c you will receive an \"undefined symbol\" error that looks like: Undefined symbols for architecture x86_64: \"_main\", referenced from: implicit entry/start for main executable ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) To compile array.c , we need to pass the -c flag to clang : clang -c array.c The -c flag tells clang to pre-process the given C file, parse the C code, and generate the machine code. The generated machine code, however, is not directly executable due to the lack of main . Such a file is called an object file 1 and has the extension of .o (or .obj on some platforms). We can write another function main , in another file (let's called it main.c ): int main () { long a [] = { 4 , 8 , 15 , 16 , 23 , 42 }; max ( a , 6 ); } If you compile main.c : clang main.c You will get another \"undefined symbol\" error: Undefined symbols for architecture x86_64: \"_max\", referenced from: _main in main-a2aed5.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) The function max is not found because it is defined in array.c . To generate an executable, we should do this: clang main.c array.o Now, clang has both the definition of main and array to generate the executable. Note that we can also run this: clang main.c array.c Which cause clang to compile both main.c and array.c . The benefit of separate compilation, however, is lost. Suppose we make a change to main.c , array.c remains untouched -- so there is no need to recompile array.c at all. The principle of efficiency \"no repetitive work\" applies here. There is one tiny problem remains. When we compile the code above, we get a warning: main.c:4:3: warning: implicit declaration of function 'max' is invalid in C99 [-Wimplicit-function-declaration] max(a, 6); ^ 1 warning generated. We have seen this before in Unit 5 . The issue here is that we need to declare the prototype for max in main.c . We have seen that the right way to do this is to include a header file -- but in this case, we need to provide our own header file. Let's create array.h containing: long max ( long list [], long length ); long min ( long list [], long length ); and include this in main.c : #include \"array.h\" int main () { long a [] = { 4 , 8 , 15 , 16 , 23 , 42 }; max ( a , 6 ); } One of the key principles of good software engineering is to write reusable code. You have seen examples of this early in CS1010 when we introduced the concepts of functions. So far, we have written functions that can be reused in multiple places within the same program . There is another level of reusability, however, where written functions can be reused in multiple programs . You have seen examples of this in cs1010_read_long , where this function is written once but used tens of thousands times in CS1010. The pair array.c and array.h can be reused this way as well. They can be compiled with different main programs and used in different context. The term object in object file here means \"target\" rather than \"thing\", and should not be confused with the term object used in object-oriented programming (which means \"thing\"). \u21a9","title":"Unit 30: Modules"},{"location":"30-module.html#unit-30-modules","text":"So far, in CS1010, you have written code that is fewer than 500 lines. Real world, complex, software, however, has many more lines of code than this . To keep the code manageable and to speed up compilation , often we break the code into separate compilation units -- into multiple C files. Functions that are relevant to each other are usually included into the same C file. These C files can be compiled independently and then linked together into the executable. Let's look at a toy example. Suppose we have two functions max and min , two commonly used functions the operates on an array, and we put them in the file array.c long max ( long list [], long length ) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } long min ( long list [], long length ) { long min_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] < min_so_far ) { min_so_far = list [ i ]; } } return min_so_far ; } The file array.c does not contain a main function, because it is not meant to be a standalone executable, but just a collection of functions. If you compile it with clang array.c you will receive an \"undefined symbol\" error that looks like: Undefined symbols for architecture x86_64: \"_main\", referenced from: implicit entry/start for main executable ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) To compile array.c , we need to pass the -c flag to clang : clang -c array.c The -c flag tells clang to pre-process the given C file, parse the C code, and generate the machine code. The generated machine code, however, is not directly executable due to the lack of main . Such a file is called an object file 1 and has the extension of .o (or .obj on some platforms). We can write another function main , in another file (let's called it main.c ): int main () { long a [] = { 4 , 8 , 15 , 16 , 23 , 42 }; max ( a , 6 ); } If you compile main.c : clang main.c You will get another \"undefined symbol\" error: Undefined symbols for architecture x86_64: \"_max\", referenced from: _main in main-a2aed5.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) The function max is not found because it is defined in array.c . To generate an executable, we should do this: clang main.c array.o Now, clang has both the definition of main and array to generate the executable. Note that we can also run this: clang main.c array.c Which cause clang to compile both main.c and array.c . The benefit of separate compilation, however, is lost. Suppose we make a change to main.c , array.c remains untouched -- so there is no need to recompile array.c at all. The principle of efficiency \"no repetitive work\" applies here. There is one tiny problem remains. When we compile the code above, we get a warning: main.c:4:3: warning: implicit declaration of function 'max' is invalid in C99 [-Wimplicit-function-declaration] max(a, 6); ^ 1 warning generated. We have seen this before in Unit 5 . The issue here is that we need to declare the prototype for max in main.c . We have seen that the right way to do this is to include a header file -- but in this case, we need to provide our own header file. Let's create array.h containing: long max ( long list [], long length ); long min ( long list [], long length ); and include this in main.c : #include \"array.h\" int main () { long a [] = { 4 , 8 , 15 , 16 , 23 , 42 }; max ( a , 6 ); } One of the key principles of good software engineering is to write reusable code. You have seen examples of this early in CS1010 when we introduced the concepts of functions. So far, we have written functions that can be reused in multiple places within the same program . There is another level of reusability, however, where written functions can be reused in multiple programs . You have seen examples of this in cs1010_read_long , where this function is written once but used tens of thousands times in CS1010. The pair array.c and array.h can be reused this way as well. They can be compiled with different main programs and used in different context. The term object in object file here means \"target\" rather than \"thing\", and should not be confused with the term object used in object-oriented programming (which means \"thing\"). \u21a9","title":"Unit 30: Modules"},{"location":"about.html","text":"About CS1010 Module Description This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students. Who/Where/When Instructor : Ooi Wei Tsang Lecture Venue : I^3 I^3 Auditorium Lecture Time : Every Tuesday, 4pm - 6pm Office Hour : Every Wednesday, 4pm - 5pm Teaching Assistants : Wu Biao Yu Xiao Liang Dou Rengan Undergraduate Discussion Leaders : Archana Pradeep Au Liang Jun Chai Jie Feng (Jack) Chua Jun Hui D David Livingston Evan Tay Gu Wangfan Ho Boon Wee Addison Jeffery Kwoh Ji Hui Jiang Qinhua Joanne Ong Cui FanG Kerryn Eer Kyle Timothy Ng Chu Lim Heng Guang Lin Si Jie Nguyen Trong Truong Thanh Ong Shu Peng (Metta) Ong You Sheng Aaron Quek Shui Herng Zhang Tianyang Important Dates Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm), MPSH 1B Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am) Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon) Practical Exam 2 : Saturday, 10 November, 2018 (9am - 12noon) (1pm - 4pm) Assessment Weightage Programming Assignments : 30% Final Assessment : 30% Midterm Assessment : 15% Practical Exam 1 : 10% Practical Exam 2 : 15%","title":"About CS1010"},{"location":"about.html#about-cs1010","text":"","title":"About CS1010"},{"location":"about.html#module-description","text":"This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.","title":"Module Description"},{"location":"about.html#whowherewhen","text":"Instructor : Ooi Wei Tsang Lecture Venue : I^3 I^3 Auditorium Lecture Time : Every Tuesday, 4pm - 6pm Office Hour : Every Wednesday, 4pm - 5pm Teaching Assistants : Wu Biao Yu Xiao Liang Dou Rengan Undergraduate Discussion Leaders : Archana Pradeep Au Liang Jun Chai Jie Feng (Jack) Chua Jun Hui D David Livingston Evan Tay Gu Wangfan Ho Boon Wee Addison Jeffery Kwoh Ji Hui Jiang Qinhua Joanne Ong Cui FanG Kerryn Eer Kyle Timothy Ng Chu Lim Heng Guang Lin Si Jie Nguyen Trong Truong Thanh Ong Shu Peng (Metta) Ong You Sheng Aaron Quek Shui Herng Zhang Tianyang","title":"Who/Where/When"},{"location":"about.html#important-dates","text":"Midterm Assessment : Tuesday, 2 October, 2018 (4pm - 6pm), MPSH 1B Final Assessment : Tuesday, 27 Nov, 2018 (9am - 11am) Practical Exam 1 : Saturday, 6 October, 2018 (9am - 12noon) Practical Exam 2 : Saturday, 10 November, 2018 (9am - 12noon) (1pm - 4pm)","title":"Important Dates"},{"location":"about.html#assessment-weightage","text":"Programming Assignments : 30% Final Assessment : 30% Midterm Assessment : 15% Practical Exam 1 : 10% Practical Exam 2 : 15%","title":"Assessment Weightage"},{"location":"accounts.html","text":"CS1010 Accounts We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts: SoC UNIX Account You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010 (details coming soon). GitHub Account CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. Piazza Account CS1010 uses Piazza for Q&A and discussion. You should receive an email to register for Piazza.","title":"Accounts"},{"location":"accounts.html#cs1010-accounts","text":"We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts:","title":"CS1010 Accounts"},{"location":"accounts.html#soc-unix-account","text":"You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010 (details coming soon).","title":"SoC UNIX Account"},{"location":"accounts.html#github-account","text":"CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one.","title":"GitHub Account"},{"location":"accounts.html#piazza-account","text":"CS1010 uses Piazza for Q&A and discussion. You should receive an email to register for Piazza.","title":"Piazza Account"},{"location":"as01.html","text":"Assignment 1 Deadline 14 September, 2018 (Friday), 6:00pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already setup your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing simple C programs that involves arithmetic operations, long , double , and bool types, and conditional if / else statements. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as01 You should see the folder as01-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files invest.c , box.c , digits.c , and taxi.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. Submission When you are ready, run the following command to submit: ~cs1010/submit-as01 The four files invest.c , box.c , digits.c , and taxi.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Hermione Granger (Group 9) Grading This assignment contributes towards 3% of your final grade. The total marks for this assignment is 30. For Programming Assignment 1, the sole criteria for grading is correctness. Question 1: Invest (5 marks) If you invest m m dollars at r r % interest rate compounded annually, after n n years, your investment will grow to \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} dollars. Write a program invest.c that accepts three integers as input: principal m m , rate r r , and number of years n n , and computes the amount of money earned after n n years. You may assume that r <= 100 r < 100 r < 100 . Sample Run ooiwt@pe111:~/as01-skeleton$ ./invest 100 10 5 111.1110 ooiwt@pe111:~/as01-skeleton$ ./invest 20000 5 10 21052.6316 Question 2: Box (5 marks) Write a program box.c that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure). You may assume that the surface area of the box does not exceed the maximum value representable in the long data type. You should break down the problem into smaller ones: Write a new method area_of_rectangle that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area. Modify the method hypotenuse_of seen in Unit 5 to compute the diagonal of the box. (hint: pay attention to the type of the parameter and the return value). Sample Run ooiwt@pe111:~/as01-skeleton$ ./box 12 3 10 372 15.9060 ooiwt@pe111:~/as01-skeleton$ ./box 10 20 30 2200 37.4166 Question 3: Digits (5 marks) Write a program digits.c that reads in a non-negative integer, and prints the sum of the individual digits in this integer. For instance, if the input is 1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26. You should not use a loop to solve this, but rather, you should write a function sum_of_digits that takes in an integer and return the sum of the digits of that integer, that calls itself: if the input to sum_of_digits has only one digit, return this digit. Otherwise, use the modulo operator % and integer division / to extract the last digit (e.g., 1 ) and the rest of the digits (e.g., 193309 ) respectively, and call sum_of_digits on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25). Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26). Sample Run ooiwt@pe111:~/as01-skeleton$ ./digits 1933091 26 ooiwt@pe111:~/as01-skeleton$ ./digits 0 0 Question 4: Taxi Fare (15 marks) The taxi fare structure in Singapore must be one of the most complex in the world! Check out: http://www.taxisingapore.com/taxi-fare/ . For the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure: Basic Fare The first 1 km or less (Flag Down) $3.40 Every 400 m thereafter or less, up to 10.2 km $0.22 Every 350 m thereafter or less, after 10.2 km $0.22 Surcharge Monday to Friday 6:00 to 9:29 25% of metered fare Daily 18:00 to 23:59 25% of metered fare Daily 0:00 (midnight) to 5:59 50% of metered fare Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred. Write a program taxi.c that computes the taxi fare. The program, called taxi , takes in four integers as inputs: The first is the day of the week. It can only be the value 1 to 7 , 1 being Monday, 7 being Sunday. The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours. The forth and final input is the distance of the trip, in meters. Your program should print a single floating point number, which is the cost of the fare in dollars. Examine the following examples for more details: Example 1 ooiwt@pe111:~/as01-skeleton$ ./taxi 1 17 59 1000 3.4000 Start: Mon 17:59 Distance: 1,000 m The metered fare is $3.40 since the distance travelled is 1km. The boarding time is before 18:00 so there is no surcharge. The total fare is $3.40. Example 2 ooiwt@pe111:~/as01-skeleton$ ./taxi 1 17 57 2000 4.0600 Start: Mon 17:57 Distance: 2,000 m The metered fare for the first 1,000 m (1km) is $3.40. The next 1,000 m is charged $0.22 for every 400 m (or less) travelled. The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06. The boarding time is before 18:00 so there is no surcharge. Example 3 ooiwt@pe111:~/as01-skeleton$ ./taxi 1 5 50 15000 17.3100 Start: Mon 05:50 Distance: 15,000 m The metered fare for the first 1,000 m (1km) is $3.40. The next 9,200 m is charged $0.22 for every 400 m travelled. The pessengar is charged an additional 23 x $0.22 = $5.06. The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled). The pessengar is charged an additional 14 x $0.22 = $3.08. The total metered fare is $11.54. The boarding time is before 6:00 so there is a 50% surcharge. Total fare is $17.31. Hints You can break down this problem into multiple subproblems, each can be solved by a function. Write one function to answer each question below : given the day of the week, is it a weekday? given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)? given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)? given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)? You can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function. Think about the four inputs to the taxi program. Which one is needed to compute the metered fare? Which ones are used to compute the surcharge? Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.","title":"1. Invest, Box, Digits, and Taxi"},{"location":"as01.html#assignment-1","text":"","title":"Assignment 1"},{"location":"as01.html#deadline","text":"14 September, 2018 (Friday), 6:00pm.","title":"Deadline"},{"location":"as01.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already setup your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as01.html#learning-outcomes","text":"Be comfortable writing simple C programs that involves arithmetic operations, long , double , and bool types, and conditional if / else statements. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.","title":"Learning Outcomes"},{"location":"as01.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as01 You should see the folder as01-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as01.html#solving-the-assignments","text":"Edit the files invest.c , box.c , digits.c , and taxi.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed.","title":"Solving The Assignments"},{"location":"as01.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as01 The four files invest.c , box.c , digits.c , and taxi.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded.","title":"Submission"},{"location":"as01.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Hermione Granger (Group 9)","title":"Identifying Yourself"},{"location":"as01.html#grading","text":"This assignment contributes towards 3% of your final grade. The total marks for this assignment is 30. For Programming Assignment 1, the sole criteria for grading is correctness.","title":"Grading"},{"location":"as01.html#question-1-invest-5-marks","text":"If you invest m m dollars at r r % interest rate compounded annually, after n n years, your investment will grow to \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} \\frac{m(1 - (r/100)^{n+1})}{1 - r/100} dollars. Write a program invest.c that accepts three integers as input: principal m m , rate r r , and number of years n n , and computes the amount of money earned after n n years. You may assume that r <= 100 r < 100 r < 100 .","title":"Question 1: Invest (5 marks)"},{"location":"as01.html#sample-run","text":"ooiwt@pe111:~/as01-skeleton$ ./invest 100 10 5 111.1110 ooiwt@pe111:~/as01-skeleton$ ./invest 20000 5 10 21052.6316","title":"Sample Run"},{"location":"as01.html#question-2-box-5-marks","text":"Write a program box.c that reads three positive integers representing the length, width, and height of a box, and output (i) its surface area, and (ii) the length of the diagonal between two vertices of the box that are furthest apart (see figure). You may assume that the surface area of the box does not exceed the maximum value representable in the long data type. You should break down the problem into smaller ones: Write a new method area_of_rectangle that computes the area of a rectangle given the width and height of the rectangle, then use it to compute the surface area. Modify the method hypotenuse_of seen in Unit 5 to compute the diagonal of the box. (hint: pay attention to the type of the parameter and the return value).","title":"Question 2: Box (5 marks)"},{"location":"as01.html#sample-run_1","text":"ooiwt@pe111:~/as01-skeleton$ ./box 12 3 10 372 15.9060 ooiwt@pe111:~/as01-skeleton$ ./box 10 20 30 2200 37.4166","title":"Sample Run"},{"location":"as01.html#question-3-digits-5-marks","text":"Write a program digits.c that reads in a non-negative integer, and prints the sum of the individual digits in this integer. For instance, if the input is 1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26. You should not use a loop to solve this, but rather, you should write a function sum_of_digits that takes in an integer and return the sum of the digits of that integer, that calls itself: if the input to sum_of_digits has only one digit, return this digit. Otherwise, use the modulo operator % and integer division / to extract the last digit (e.g., 1 ) and the rest of the digits (e.g., 193309 ) respectively, and call sum_of_digits on the rest of the digits to find its sum (e.g., 1+9+3+3+0+9 = 25). Finally we add the last digit to this sum to get the total we seek (e.g., 1 + 25 = 26).","title":"Question 3: Digits (5 marks)"},{"location":"as01.html#sample-run_2","text":"ooiwt@pe111:~/as01-skeleton$ ./digits 1933091 26 ooiwt@pe111:~/as01-skeleton$ ./digits 0 0","title":"Sample Run"},{"location":"as01.html#question-4-taxi-fare-15-marks","text":"The taxi fare structure in Singapore must be one of the most complex in the world! Check out: http://www.taxisingapore.com/taxi-fare/ . For the purpose of this exercise, we will just use the following simpli\ufb01ed fare structure: Basic Fare The first 1 km or less (Flag Down) $3.40 Every 400 m thereafter or less, up to 10.2 km $0.22 Every 350 m thereafter or less, after 10.2 km $0.22 Surcharge Monday to Friday 6:00 to 9:29 25% of metered fare Daily 18:00 to 23:59 25% of metered fare Daily 0:00 (midnight) to 5:59 50% of metered fare Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharged is incurred. Write a program taxi.c that computes the taxi fare. The program, called taxi , takes in four integers as inputs: The first is the day of the week. It can only be the value 1 to 7 , 1 being Monday, 7 being Sunday. The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours. The forth and final input is the distance of the trip, in meters. Your program should print a single floating point number, which is the cost of the fare in dollars. Examine the following examples for more details:","title":"Question 4: Taxi Fare (15 marks)"},{"location":"as01.html#example-1","text":"ooiwt@pe111:~/as01-skeleton$ ./taxi 1 17 59 1000 3.4000 Start: Mon 17:59 Distance: 1,000 m The metered fare is $3.40 since the distance travelled is 1km. The boarding time is before 18:00 so there is no surcharge. The total fare is $3.40.","title":"Example 1"},{"location":"as01.html#example-2","text":"ooiwt@pe111:~/as01-skeleton$ ./taxi 1 17 57 2000 4.0600 Start: Mon 17:57 Distance: 2,000 m The metered fare for the first 1,000 m (1km) is $3.40. The next 1,000 m is charged $0.22 for every 400 m (or less) travelled. The pessengar is charged an additional 3 x $0.22, giving the total of metered fare of $4.06. The boarding time is before 18:00 so there is no surcharge.","title":"Example 2"},{"location":"as01.html#example-3","text":"ooiwt@pe111:~/as01-skeleton$ ./taxi 1 5 50 15000 17.3100 Start: Mon 05:50 Distance: 15,000 m The metered fare for the first 1,000 m (1km) is $3.40. The next 9,200 m is charged $0.22 for every 400 m travelled. The pessengar is charged an additional 23 x $0.22 = $5.06. The remaining 4,800 m is charged $0.22 for every 350 m (or less) travelled). The pessengar is charged an additional 14 x $0.22 = $3.08. The total metered fare is $11.54. The boarding time is before 6:00 so there is a 50% surcharge. Total fare is $17.31.","title":"Example 3"},{"location":"as01.html#hints","text":"You can break down this problem into multiple subproblems, each can be solved by a function. Write one function to answer each question below : given the day of the week, is it a weekday? given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)? given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)? given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)? You can further breakdown the calculation of fare into two parts: the basic metered fare and the surcharge. Each of these can be its own function. Think about the four inputs to the taxi program. Which one is needed to compute the metered fare? Which ones are used to compute the surcharge? Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.","title":"Hints"},{"location":"as02.html","text":"Assignment 2: Collatz, Weekday, Circle, Pattern Deadline 21 September, 2018 (Friday), 6:00pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops with while / for / do-while statements. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as02 You should see the folder as02-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files collatz.c , weekday.c , circle.c , and pattern.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. Submission When you are ready, run the following command to submit: ~cs1010/submit-as02 The four files collatz.c , weekday.c , circle.c , and pattern.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the four C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Elsa of Arendelle (Group 9) Grading This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are two marking criteria: correctness and style. For each question, 2 marks are allocated for coding style. Please refer to the CS1010 C Style Guide and follow the recommended guideline. The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question). Question 1: Collatz (6 marks) The Collatz Conjecture was introduced by the mathematician Lothar Collatz in 1937. Also known as the 3n+1 3n+1 conjecture, the problem can be stated very simply but yet no one is able to prove that it is true or false. The conjecture states the following: Consider the following operation on a positive integer n n : if n n is even, divide it by two; otherwise, triple it and add one. Suppose we form a sequence of numbers by performing this operation repeatedly, beginning with any positive integer, then this process will eventually reach the number 1, for any initial positive integer n n . For instance, if n = 10 n = 10 , then we have the sequence 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 . The smallest number of steps taken by this process for n n to reach 1 is called the total stopping time . In the example above, the total stopping time for 10 is 6. Write a program collatz.c that reads in a positive integer N N from the standard input and finds out, among the numbers between 1 to N N , inclusive, which one has the largest total stopping time. If two numbers have the same total stopping time, we break ties by choosing the larger number as the answer. Your program should print to the standard output, the number with the largest total stopping time and its corresponding total stopping time. Sample Run ooiwt@pe114:~/as02-skeleton$ ./collatz 1 1 0 ooiwt@pe114:~/as02-skeleton$ ./collatz 10 9 19 ooiwt@pe114:~/as02-skeleton$ ./collatz 1000 871 178 Question 2: Weekday (6 marks) Write a program weekday.c that reads three positive integers representing the year, month, and day of a date respectively, and prints out which day of the week this date is to the standard output. Possible outputs are \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\". The earliest date that can be given as input is January 1, 1900 (which is a Monday). You may find reusing functions you have written in Exercise 2 useful. Sample Run ooiwt@pe114:~/as02-skeleton$ ./weekday 1900 1 1 Monday ooiwt@pe114:~/as02-skeleton$ ./weekday 1904 2 29 Monday ooiwt@pe114:~/as02-skeleton$ ./weekday 2018 9 14 Friday Question 3: Circle (6 marks) Write a program circle.c that reads in a positive integer r r from the standard input, and prints a circle of radius r r to the standard output. We can consider this circle as being printed on a canvas of size (2r+1) \\times (2r+1) (2r+1) \\times (2r+1) , with the top left corner being (0, 0) (0, 0) and the center of the circle at the position (r, r) (r, r) . The figure below shows an example with r = 2 r = 2 . For each location (x, y) (x, y) , let the distance of (x, y) (x, y) to the center be d_{x,y} d_{x,y} . To print the circle, we print the following for each location (x,y) (x,y) : if |d_{x,y} - r| < 0.1 |d_{x,y} - r| < 0.1 , print @ otherwise, if |d_{x,y} - r| < 0.3 |d_{x,y} - r| < 0.3 , print O (that's uppercase o, not zero) otherwise, if |d_{x,y} - r| < 0.5 |d_{x,y} - r| < 0.5 , print * otherwise, if |d_{x,y} - r| < 0.7 |d_{x,y} - r| < 0.7 , print + otherwise, print (white space) Your output must contain exactly 2r+1 2r+1 rows, each row exactly 2r+1 2r+1 characters (including the white spaces but excluding the newline). Note that in the sample runs below, the white spaces are not visible. Sample Run ooiwt@pe114:~/as02-skeleton$ ./circle 1 *@* @ @ *@* ooiwt@pe114:~/as02-skeleton$ ./circle 5 *@@@* +@+ +@+ @ @ *+ +* @ @ @ @ @ @ *+ +* @ @ +@+ +@+ *@@@* ooiwt@pe114:~/as02-skeleton$ ./circle 10 *O@@@O* OO+ +OO +@+ +@+ +O O+ @ @ O+ +O O O *+ +* O O @ @ @ @ @ @ O O *+ +* O O O+ +O @ @ +O O+ +@+ +@+ OO+ +OO *O@@@O* Question 4: Pattern (12 marks) Even though the sequence of prime numbers appears to be random, mathematicians have found some intriguing patterns related to prime numbers. In this question, you are asked to write a program to draw a variation of the \"Parallax Compression\" pattern discovered by a software engineer, Shaun Gilchrist . The pattern visualizes the distribution of prime number in a triangle, in the following way. The inputs given are an interval n n ( n \\ge 1 n \\ge 1 ) and the height of the triangle h h . The triangle has h h rows. The first row of the triangle has one cell, the second row has three cells, the third row has five, etc. The cells are centrally aligned so that visually they form an equilateral triangle. We call the left-most cell of each row the leading cell . Each cell in the triangle contains n n integers. The first cell in the first row contains the numbers 1, 2, ..., n n . The leading cell of the next row, row 2, contains n n numbers between n+1 n+1 and 3n 3n , with increment of 2: i.e., n+1, n+3, n+5, .. n+(2n-1) n+1, n+3, n+5, .. n+(2n-1) . The leading cell of the next row, row 3, contains the numbers 3n + 1 3n + 1 and 6n 6n , with increment of 3: i.e., 3n+1, 3n+4, 3n+7, .. 3n+(3n-2) 3n+1, 3n+4, 3n+7, .. 3n+(3n-2) , etc. For instance, if n n is 5, the leading cells of the first three rows contain the numbers [1, 2, 3, 4, 5], [6, 8, 10, 12, 14], [16, 19, 22, 25, 28], respectively. The rest of the cells in each row contains n n numbers where each is one more than a number contained in the cell on its left. So, in row 2, the numbers in the three cells are [6, 8, 10, 12, 14], [7, 9, 11, 13, 15] and [8, 10, 12, 14, 16]. In row 3, the cells contain [16, 19, 22, 25, 28], [17, 20, 23, 26, 29], [18, 21, 24, 27, 30], [19, 22, 25, 28, 31], and [20, 23, 26, 29, 32]. Now, to visualize the distribution of primes, we do the following, for each cell of the triangle that contains either 1 or at least one prime, we print # to the standard output at the corresponding position. Otherwise, we print (a white space). Your output must contain exactly 2r+1 h h rows, each row exactly 2r+1 2h-1 2h-1 characters (including the white spaces but excluding the newline). Note that in the sample runs below, the white spaces are not visible. Example 1 ooiwt@pe114:~/as02-skeleton$ ./pattern 2 4 # # # ## ## # # # # See the figures below: The figure above shows the shape of the triangle with height 4. The shaded locations belong to the triangle. Each square represents a cell. The figure above shows the integers contained in each of the triangle cells with an interval of 2. The figure above shows the pattern that emerges if we color each cell that contains at least one prime a darker shade. In our program, we use # to represent such a cell. More Examples ooiwt@pe114:~/as02-skeleton$ ./pattern 11 11 # # ## ## # # # # #### #### # # # # ###### # #### # # # # # # # # ## ## ## ## ## ## # # # # # # # # ###### ### ########## ooiwt@pe114:~/as02-skeleton$ ./pattern 100 29 # # # ## ## # # # # #### #### # # # # ###### ###### # # # # # # # # ## ## ## ## ## ## # # # # # # # # ########## ########## # # # # # # # # ############ ############ # # # # # # # # # # # # ## # ## # ## ## # ## # ## # # # # # # # # # # # # # # # # ################ ################ # # # # # # # # # # # # ################## ################## # # # # # # # # # # # # # # # # ## ## # ## # ## ## ## ## # ## # ## ## # # # # # # # # # # # # # # # # # # # # ###################### ###################### # # # # # # # # # # # # # # # # #### #### #### #### #### #### #### #### #### #### # # # # # # # # # # # # # # # # # # # # # # # # ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## # # # # # # # # # # # # # # # # # # # # # # # # ############################ ############################","title":"2. Collatz, Weekday, Circle, Pattern"},{"location":"as02.html#assignment-2-collatz-weekday-circle-pattern","text":"","title":"Assignment 2: Collatz, Weekday, Circle, Pattern"},{"location":"as02.html#deadline","text":"21 September, 2018 (Friday), 6:00pm.","title":"Deadline"},{"location":"as02.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as02.html#learning-outcomes","text":"Be comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops with while / for / do-while statements. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.","title":"Learning Outcomes"},{"location":"as02.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as02 You should see the folder as02-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as02.html#solving-the-assignments","text":"Edit the files collatz.c , weekday.c , circle.c , and pattern.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed.","title":"Solving The Assignments"},{"location":"as02.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as02 The four files collatz.c , weekday.c , circle.c , and pattern.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the four C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as02.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Elsa of Arendelle (Group 9)","title":"Identifying Yourself"},{"location":"as02.html#grading","text":"This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are two marking criteria: correctness and style. For each question, 2 marks are allocated for coding style. Please refer to the CS1010 C Style Guide and follow the recommended guideline. The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question).","title":"Grading"},{"location":"as02.html#question-1-collatz-6-marks","text":"The Collatz Conjecture was introduced by the mathematician Lothar Collatz in 1937. Also known as the 3n+1 3n+1 conjecture, the problem can be stated very simply but yet no one is able to prove that it is true or false. The conjecture states the following: Consider the following operation on a positive integer n n : if n n is even, divide it by two; otherwise, triple it and add one. Suppose we form a sequence of numbers by performing this operation repeatedly, beginning with any positive integer, then this process will eventually reach the number 1, for any initial positive integer n n . For instance, if n = 10 n = 10 , then we have the sequence 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1 . The smallest number of steps taken by this process for n n to reach 1 is called the total stopping time . In the example above, the total stopping time for 10 is 6. Write a program collatz.c that reads in a positive integer N N from the standard input and finds out, among the numbers between 1 to N N , inclusive, which one has the largest total stopping time. If two numbers have the same total stopping time, we break ties by choosing the larger number as the answer. Your program should print to the standard output, the number with the largest total stopping time and its corresponding total stopping time.","title":"Question 1: Collatz (6 marks)"},{"location":"as02.html#sample-run","text":"ooiwt@pe114:~/as02-skeleton$ ./collatz 1 1 0 ooiwt@pe114:~/as02-skeleton$ ./collatz 10 9 19 ooiwt@pe114:~/as02-skeleton$ ./collatz 1000 871 178","title":"Sample Run"},{"location":"as02.html#question-2-weekday-6-marks","text":"Write a program weekday.c that reads three positive integers representing the year, month, and day of a date respectively, and prints out which day of the week this date is to the standard output. Possible outputs are \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\". The earliest date that can be given as input is January 1, 1900 (which is a Monday). You may find reusing functions you have written in Exercise 2 useful.","title":"Question 2: Weekday (6 marks)"},{"location":"as02.html#sample-run_1","text":"ooiwt@pe114:~/as02-skeleton$ ./weekday 1900 1 1 Monday ooiwt@pe114:~/as02-skeleton$ ./weekday 1904 2 29 Monday ooiwt@pe114:~/as02-skeleton$ ./weekday 2018 9 14 Friday","title":"Sample Run"},{"location":"as02.html#question-3-circle-6-marks","text":"Write a program circle.c that reads in a positive integer r r from the standard input, and prints a circle of radius r r to the standard output. We can consider this circle as being printed on a canvas of size (2r+1) \\times (2r+1) (2r+1) \\times (2r+1) , with the top left corner being (0, 0) (0, 0) and the center of the circle at the position (r, r) (r, r) . The figure below shows an example with r = 2 r = 2 . For each location (x, y) (x, y) , let the distance of (x, y) (x, y) to the center be d_{x,y} d_{x,y} . To print the circle, we print the following for each location (x,y) (x,y) : if |d_{x,y} - r| < 0.1 |d_{x,y} - r| < 0.1 , print @ otherwise, if |d_{x,y} - r| < 0.3 |d_{x,y} - r| < 0.3 , print O (that's uppercase o, not zero) otherwise, if |d_{x,y} - r| < 0.5 |d_{x,y} - r| < 0.5 , print * otherwise, if |d_{x,y} - r| < 0.7 |d_{x,y} - r| < 0.7 , print + otherwise, print (white space) Your output must contain exactly 2r+1 2r+1 rows, each row exactly 2r+1 2r+1 characters (including the white spaces but excluding the newline). Note that in the sample runs below, the white spaces are not visible.","title":"Question 3: Circle (6 marks)"},{"location":"as02.html#sample-run_2","text":"ooiwt@pe114:~/as02-skeleton$ ./circle 1 *@* @ @ *@* ooiwt@pe114:~/as02-skeleton$ ./circle 5 *@@@* +@+ +@+ @ @ *+ +* @ @ @ @ @ @ *+ +* @ @ +@+ +@+ *@@@* ooiwt@pe114:~/as02-skeleton$ ./circle 10 *O@@@O* OO+ +OO +@+ +@+ +O O+ @ @ O+ +O O O *+ +* O O @ @ @ @ @ @ O O *+ +* O O O+ +O @ @ +O O+ +@+ +@+ OO+ +OO *O@@@O*","title":"Sample Run"},{"location":"as02.html#question-4-pattern-12-marks","text":"Even though the sequence of prime numbers appears to be random, mathematicians have found some intriguing patterns related to prime numbers. In this question, you are asked to write a program to draw a variation of the \"Parallax Compression\" pattern discovered by a software engineer, Shaun Gilchrist . The pattern visualizes the distribution of prime number in a triangle, in the following way. The inputs given are an interval n n ( n \\ge 1 n \\ge 1 ) and the height of the triangle h h . The triangle has h h rows. The first row of the triangle has one cell, the second row has three cells, the third row has five, etc. The cells are centrally aligned so that visually they form an equilateral triangle. We call the left-most cell of each row the leading cell . Each cell in the triangle contains n n integers. The first cell in the first row contains the numbers 1, 2, ..., n n . The leading cell of the next row, row 2, contains n n numbers between n+1 n+1 and 3n 3n , with increment of 2: i.e., n+1, n+3, n+5, .. n+(2n-1) n+1, n+3, n+5, .. n+(2n-1) . The leading cell of the next row, row 3, contains the numbers 3n + 1 3n + 1 and 6n 6n , with increment of 3: i.e., 3n+1, 3n+4, 3n+7, .. 3n+(3n-2) 3n+1, 3n+4, 3n+7, .. 3n+(3n-2) , etc. For instance, if n n is 5, the leading cells of the first three rows contain the numbers [1, 2, 3, 4, 5], [6, 8, 10, 12, 14], [16, 19, 22, 25, 28], respectively. The rest of the cells in each row contains n n numbers where each is one more than a number contained in the cell on its left. So, in row 2, the numbers in the three cells are [6, 8, 10, 12, 14], [7, 9, 11, 13, 15] and [8, 10, 12, 14, 16]. In row 3, the cells contain [16, 19, 22, 25, 28], [17, 20, 23, 26, 29], [18, 21, 24, 27, 30], [19, 22, 25, 28, 31], and [20, 23, 26, 29, 32]. Now, to visualize the distribution of primes, we do the following, for each cell of the triangle that contains either 1 or at least one prime, we print # to the standard output at the corresponding position. Otherwise, we print (a white space). Your output must contain exactly 2r+1 h h rows, each row exactly 2r+1 2h-1 2h-1 characters (including the white spaces but excluding the newline). Note that in the sample runs below, the white spaces are not visible.","title":"Question 4: Pattern (12 marks)"},{"location":"as02.html#example-1","text":"ooiwt@pe114:~/as02-skeleton$ ./pattern 2 4 # # # ## ## # # # # See the figures below: The figure above shows the shape of the triangle with height 4. The shaded locations belong to the triangle. Each square represents a cell. The figure above shows the integers contained in each of the triangle cells with an interval of 2. The figure above shows the pattern that emerges if we color each cell that contains at least one prime a darker shade. In our program, we use # to represent such a cell.","title":"Example 1"},{"location":"as02.html#more-examples","text":"ooiwt@pe114:~/as02-skeleton$ ./pattern 11 11 # # ## ## # # # # #### #### # # # # ###### # #### # # # # # # # # ## ## ## ## ## ## # # # # # # # # ###### ### ########## ooiwt@pe114:~/as02-skeleton$ ./pattern 100 29 # # # ## ## # # # # #### #### # # # # ###### ###### # # # # # # # # ## ## ## ## ## ## # # # # # # # # ########## ########## # # # # # # # # ############ ############ # # # # # # # # # # # # ## # ## # ## ## # ## # ## # # # # # # # # # # # # # # # # ################ ################ # # # # # # # # # # # # ################## ################## # # # # # # # # # # # # # # # # ## ## # ## # ## ## ## ## # ## # ## ## # # # # # # # # # # # # # # # # # # # # ###################### ###################### # # # # # # # # # # # # # # # # #### #### #### #### #### #### #### #### #### #### # # # # # # # # # # # # # # # # # # # # # # # # ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## # # # # # # # # # # # # # # # # # # # # # # # # ############################ ############################","title":"More Examples"},{"location":"as03.html","text":"Assignment 3: Kendall, Histogram, CountingSort Deadline 5 October, 2018 (Friday), 6:00pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, and arrays. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as03 You should see the folder as03-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files kandall.c , histogram.c , countingsort.c , to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. Submission When you are ready, run the following command to submit: ~cs1010/submit-as03 The four files kendall.c , histogram.c , countingsort.c , will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the four C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Peter Parker (Group 9) Grading This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are two marking criteria: correctness and style. For each question, 2 marks are allocated for coding style. Please refer to the CS1010 C Style Guide and follow the recommended guideline. The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question). We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalze students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Question 1: Kendall (10 marks) Suppose that we are given a set of items and we ask two different parties to rank the items according to some order. We may get two different order of the items. How do we measure how similar (or dissimilar) the two rankings are? For example, consider a search engine that returns a list of web pages ranked by their relevance to the search query. A user may not always agree with the ranking of the search engine and may judge the relevance of the search result differently, i.e., the user may have his or her own ranking. This measurement of similarity between the ranking by the search engine and the ranking by the user gives us a metric on how good the search engine result is. The more similar it is to the ranking of the user, the better the search engine is in ranking in the search results. One way to measure the similarity of two rankings is the Kendall tau distance . You will write a program kendall that calculates the normalized Kendall tau distance for this question. We will represent a ranking by the order of the items. The first item is ranked 1, second is ranked 2, and so on. To simplify the problem, we take one of the ranking that we want to calculate the Kendall tau distance on, and label the items sequentially, as the sequence 1, 2, 3, 4, 5, ... n n , where n n is the number of items. We call this the base ranking. The other ranking will then be a permutation of the numbers 1 to n n . For example, suppost we have three items A, B, C. the first ranking ranks the items as B, C, A. The second ranking ranks the items C, A, B. After relabelling the first ranking as 1, 2, 3, the second ranking becomes 2, 3, 1. The Kendall tau distance counts the number of pairs of items in one ranking that are ranked in different order in the other ranking. In the example above, we have three possible pairs: Pair Ranking 1 Ranking 2 A-B B then A A then B A-C C then A C then A B-C B then C C then B Out of the three pairs, the pair A-B and B-C are ordered differently in the two rankings, so that Kendall tau distance is 2. The normalized Kendall tau distance is the ratio of the number of pairs ranked in different order to all possible number of pairs. In the example above, the normalized Kendall distance is \u2154 = 0.6666. Your program should read the following from the standard input: The first positive integer, n n , is the number of items ( n > 1 n > 1 ). The next n n numbers is a permutation of integers between 1 to n n . This corresponds to the ranking of the items from 1 to n n . Your program should print the normalized Kendall tau distance between the ranking read above and the base ranking (1, 2, 3, .. n n ) to the standard output. Sample Run ooiwt@pe118:~/as03-skeleton$ ./kendall 3 2 3 1 0.6667 ooiwt@pe118:~/as03-skeleton$ ./kendall 10 1 2 3 4 5 6 7 8 9 10 0.0000 ooiwt@pe118:~/as03-skeleton$ ./kendall 6 6 5 4 3 2 1 1.0000 Question 2: Histogram (10 marks) It is often useful to visualize the distribution of numerical data using a histogram. In this question, you will write a program called histogram that plots the histogram for real numbers ranged between 0 and 100 (inclusive). Our histogram will have 10 buckets, b_0, b_1, ... b_9 b_0, b_1, ... b_9 . The bucket b_i b_i corresponds to the interval [ 10i, 10(i+1) 10i, 10(i+1) ) (includes 10i 10i , but excludes 10(i+1) 10(i+1) ), except b_9 b_9 , which includes 100 . To plot the histogram, we count how many percent of the data falls into each bucket. Let the percentage of data that falls into bucket b_i b_i be k_i k_i %. We set the length of each bar in histogram to be at most 10 characters, so we scale down k_i k_i by 10 to get the length l_i l_i . We then draw on the screen using character \"\u2588\" and \"\u258c\", according to the following rules: If l_i l_i is an integer, then we draw \"\u2588\" l_i l_i times. Otherwise, if x < l_i \\le x + 0.5 x < l_i \\le x + 0.5 for some integer x x , then we draw \"\u2588\" x x times followed by a \"\u258c\". Otherwise, if x + 0.5 < l_i < x + 1 x + 0.5 < l_i < x + 1 for some integer x x , then we draw \"\u2588\" x+1 x+1 times. Your program should read the following from the standard input: a positive integer n n , followed by n n real numbers, corresponding to data to plot the histogram with. Your program should print the axis and labels, as well as the bars for the histogram as shown in the same run. The code to print both axis and labels are already given in the skeleton histogram.c . The string that corresponding to \"\u2588\" and \"\u258c\" are also given in the code, defined as BLOCK and HALF_BLOCK . Sample Run ooiwt@pe118:~/as03-skeleton$ ./histogram 10 25 35 35 45 45 45 45 55 55 65 \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 10 - 20 20 - 30 \u2588 30 - 40 \u2588\u2588 40 - 50 \u2588\u2588\u2588\u2588 50 - 60 \u2588\u2588 60 - 70 \u2588 70 - 80 80 - 90 90 - 100 ooiwt@pe118:~/as03-skeleton$ ./histogram 1 100 \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 10 - 20 20 - 30 30 - 40 40 - 50 50 - 60 60 - 70 70 - 80 80 - 90 90 - 100 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 ooiwt@pe118:~/as03-skeleton$ ./histogram < inputs/histogram.5.in \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 \u258c 10 - 20 \u258c 20 - 30 30 - 40 \u258c 40 - 50 50 - 60 \u258c 60 - 70 \u2588 70 - 80 \u2588\u2588 80 - 90 \u2588\u2588\u2588\u2588\u2588\u258c 90 - 100 \u2588\u2588 The last histogram above plots the actual data from your Assignment 1 marks (scaled up 3x to have the range of 0 - 90). Question 3: CountingSort (10 marks) Sorting is a fundamental computational problem: given a list of items, we want to rearrange the items in some order. In this question, you will write you first sorting algorithm, called counting sort . This is an extremely fast algorithm for sorting positive integers if the range of the integers are limited. The idea of counting sort is that, given the list of integers (each guranteed to be between 1 to k k ) to sort, we count how many times 1 appear in the list, how many times 2 appears in the list, etc. Finally, we print out each number between 1 to k k according to how many times they appear in the list, skipping those numbers who do not appear. For instance, suppose we have 6 integers between 1 to 9: 5 5 3 2 8 2 . We first count how many times each number appears. Then we print the sorted list the following way: 2 appears twice, so we print 2 2 The number 3 appears once, we print 3 The number 5 appears twice, we print 5 5 Finally 8 appears once, we print 8 The printed output is thus 2 2 3 5 5 8 which is the numbers sorted in increasing order. Write a program countingsort.c that reads the following in order from the standard input: n n the number of integers to sort k k the maximum value of the integers to sort The next n n numbers are the integers to be sorted, each guaranteed to be between 1 and k k . Sort the integers using the algorithms above and print them in increasing order to the standard output, one integer on each line. Note that if you use any other algorithms to sort the numbers, you will be penalized heavily. Input Validation: For this question, you need to validate that the numbers are actually ranged between 1 and k k . Any inputs that are not in this range must be omitted in the output. Sample Run ooiwt@pe118:~/as03-skeleton$ ./countingsort 6 9 5 5 3 2 8 2 2 2 3 5 5 8 ooiwt@pe118:~/as03-skeleton$ ./countingsort 3 1000 256 872 112 112 256 872 ooiwt@pe118:~/as03-skeleton$ ./countingsort 4 3 3 2 -3 2 2 2 3","title":"3. Kendall, Histogram, CountingSort"},{"location":"as03.html#assignment-3-kendall-histogram-countingsort","text":"","title":"Assignment 3: Kendall, Histogram, CountingSort"},{"location":"as03.html#deadline","text":"5 October, 2018 (Friday), 6:00pm.","title":"Deadline"},{"location":"as03.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as03.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, and arrays. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.","title":"Learning Outcomes"},{"location":"as03.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as03 You should see the folder as03-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as03.html#solving-the-assignments","text":"Edit the files kandall.c , histogram.c , countingsort.c , to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed.","title":"Solving The Assignments"},{"location":"as03.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as03 The four files kendall.c , histogram.c , countingsort.c , will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the four C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as03.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Peter Parker (Group 9)","title":"Identifying Yourself"},{"location":"as03.html#grading","text":"This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are two marking criteria: correctness and style. For each question, 2 marks are allocated for coding style. Please refer to the CS1010 C Style Guide and follow the recommended guideline. The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Even if your code produces the correct output all the time, you may still lose marks if you do not write your code properly (e.g., using the most appropriate type, violating the constraints set by the question). We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalze students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as03.html#question-1-kendall-10-marks","text":"Suppose that we are given a set of items and we ask two different parties to rank the items according to some order. We may get two different order of the items. How do we measure how similar (or dissimilar) the two rankings are? For example, consider a search engine that returns a list of web pages ranked by their relevance to the search query. A user may not always agree with the ranking of the search engine and may judge the relevance of the search result differently, i.e., the user may have his or her own ranking. This measurement of similarity between the ranking by the search engine and the ranking by the user gives us a metric on how good the search engine result is. The more similar it is to the ranking of the user, the better the search engine is in ranking in the search results. One way to measure the similarity of two rankings is the Kendall tau distance . You will write a program kendall that calculates the normalized Kendall tau distance for this question. We will represent a ranking by the order of the items. The first item is ranked 1, second is ranked 2, and so on. To simplify the problem, we take one of the ranking that we want to calculate the Kendall tau distance on, and label the items sequentially, as the sequence 1, 2, 3, 4, 5, ... n n , where n n is the number of items. We call this the base ranking. The other ranking will then be a permutation of the numbers 1 to n n . For example, suppost we have three items A, B, C. the first ranking ranks the items as B, C, A. The second ranking ranks the items C, A, B. After relabelling the first ranking as 1, 2, 3, the second ranking becomes 2, 3, 1. The Kendall tau distance counts the number of pairs of items in one ranking that are ranked in different order in the other ranking. In the example above, we have three possible pairs: Pair Ranking 1 Ranking 2 A-B B then A A then B A-C C then A C then A B-C B then C C then B Out of the three pairs, the pair A-B and B-C are ordered differently in the two rankings, so that Kendall tau distance is 2. The normalized Kendall tau distance is the ratio of the number of pairs ranked in different order to all possible number of pairs. In the example above, the normalized Kendall distance is \u2154 = 0.6666. Your program should read the following from the standard input: The first positive integer, n n , is the number of items ( n > 1 n > 1 ). The next n n numbers is a permutation of integers between 1 to n n . This corresponds to the ranking of the items from 1 to n n . Your program should print the normalized Kendall tau distance between the ranking read above and the base ranking (1, 2, 3, .. n n ) to the standard output.","title":"Question 1: Kendall (10 marks)"},{"location":"as03.html#sample-run","text":"ooiwt@pe118:~/as03-skeleton$ ./kendall 3 2 3 1 0.6667 ooiwt@pe118:~/as03-skeleton$ ./kendall 10 1 2 3 4 5 6 7 8 9 10 0.0000 ooiwt@pe118:~/as03-skeleton$ ./kendall 6 6 5 4 3 2 1 1.0000","title":"Sample Run"},{"location":"as03.html#question-2-histogram-10-marks","text":"It is often useful to visualize the distribution of numerical data using a histogram. In this question, you will write a program called histogram that plots the histogram for real numbers ranged between 0 and 100 (inclusive). Our histogram will have 10 buckets, b_0, b_1, ... b_9 b_0, b_1, ... b_9 . The bucket b_i b_i corresponds to the interval [ 10i, 10(i+1) 10i, 10(i+1) ) (includes 10i 10i , but excludes 10(i+1) 10(i+1) ), except b_9 b_9 , which includes 100 . To plot the histogram, we count how many percent of the data falls into each bucket. Let the percentage of data that falls into bucket b_i b_i be k_i k_i %. We set the length of each bar in histogram to be at most 10 characters, so we scale down k_i k_i by 10 to get the length l_i l_i . We then draw on the screen using character \"\u2588\" and \"\u258c\", according to the following rules: If l_i l_i is an integer, then we draw \"\u2588\" l_i l_i times. Otherwise, if x < l_i \\le x + 0.5 x < l_i \\le x + 0.5 for some integer x x , then we draw \"\u2588\" x x times followed by a \"\u258c\". Otherwise, if x + 0.5 < l_i < x + 1 x + 0.5 < l_i < x + 1 for some integer x x , then we draw \"\u2588\" x+1 x+1 times. Your program should read the following from the standard input: a positive integer n n , followed by n n real numbers, corresponding to data to plot the histogram with. Your program should print the axis and labels, as well as the bars for the histogram as shown in the same run. The code to print both axis and labels are already given in the skeleton histogram.c . The string that corresponding to \"\u2588\" and \"\u258c\" are also given in the code, defined as BLOCK and HALF_BLOCK .","title":"Question 2: Histogram (10 marks)"},{"location":"as03.html#sample-run_1","text":"ooiwt@pe118:~/as03-skeleton$ ./histogram 10 25 35 35 45 45 45 45 55 55 65 \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 10 - 20 20 - 30 \u2588 30 - 40 \u2588\u2588 40 - 50 \u2588\u2588\u2588\u2588 50 - 60 \u2588\u2588 60 - 70 \u2588 70 - 80 80 - 90 90 - 100 ooiwt@pe118:~/as03-skeleton$ ./histogram 1 100 \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 10 - 20 20 - 30 30 - 40 40 - 50 50 - 60 60 - 70 70 - 80 80 - 90 90 - 100 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 ooiwt@pe118:~/as03-skeleton$ ./histogram < inputs/histogram.5.in \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 \u258c 10 - 20 \u258c 20 - 30 30 - 40 \u258c 40 - 50 50 - 60 \u258c 60 - 70 \u2588 70 - 80 \u2588\u2588 80 - 90 \u2588\u2588\u2588\u2588\u2588\u258c 90 - 100 \u2588\u2588 The last histogram above plots the actual data from your Assignment 1 marks (scaled up 3x to have the range of 0 - 90).","title":"Sample Run"},{"location":"as03.html#question-3-countingsort-10-marks","text":"Sorting is a fundamental computational problem: given a list of items, we want to rearrange the items in some order. In this question, you will write you first sorting algorithm, called counting sort . This is an extremely fast algorithm for sorting positive integers if the range of the integers are limited. The idea of counting sort is that, given the list of integers (each guranteed to be between 1 to k k ) to sort, we count how many times 1 appear in the list, how many times 2 appears in the list, etc. Finally, we print out each number between 1 to k k according to how many times they appear in the list, skipping those numbers who do not appear. For instance, suppose we have 6 integers between 1 to 9: 5 5 3 2 8 2 . We first count how many times each number appears. Then we print the sorted list the following way: 2 appears twice, so we print 2 2 The number 3 appears once, we print 3 The number 5 appears twice, we print 5 5 Finally 8 appears once, we print 8 The printed output is thus 2 2 3 5 5 8 which is the numbers sorted in increasing order. Write a program countingsort.c that reads the following in order from the standard input: n n the number of integers to sort k k the maximum value of the integers to sort The next n n numbers are the integers to be sorted, each guaranteed to be between 1 and k k . Sort the integers using the algorithms above and print them in increasing order to the standard output, one integer on each line. Note that if you use any other algorithms to sort the numbers, you will be penalized heavily. Input Validation: For this question, you need to validate that the numbers are actually ranged between 1 and k k . Any inputs that are not in this range must be omitted in the output.","title":"Question 3: CountingSort (10 marks)"},{"location":"as03.html#sample-run_2","text":"ooiwt@pe118:~/as03-skeleton$ ./countingsort 6 9 5 5 3 2 8 2 2 2 3 5 5 8 ooiwt@pe118:~/as03-skeleton$ ./countingsort 3 1000 256 872 112 112 256 872 ooiwt@pe118:~/as03-skeleton$ ./countingsort 4 3 3 2 -3 2 2 2 3","title":"Sample Run"},{"location":"as04.html","text":"Assignment 4: SelectionSort, Add, Mastermind Deadline 12 October, 2018 (Friday), 6:00pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays, and strings. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as04 You should see the folder as04-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files selectionsort.c , add.c , mastermind.c , to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. Submission When you are ready, run the following command to submit: ~cs1010/submit-as04 The files selectionsort.c , add.c , mastermind.c , will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Jean Luc Picard (Group 9) Grading This assignment contributes towards 4% of your final grade. The total mark for this assignment is 40 marks. There are three marking criteria: correctness, documentation, and style. Documentation: For each question, two marks are allocated for documentation. Please refer to the documentation and follow the recommended format. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. Style: For each question, two marks are allocated for style. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Question 1: SelectionSort (10 marks) You have implemented counting sort, a simple and fast sorting algorithm that works on integers with limited range. But if the range of possible values to be sorted is huge or unlimited, then, counting sort does not work so well, and we need a different kind of sorting algorithm. In this question, you are asked to implement selection sort. The idea behind selection sort is simple, and we will illustrate with the sequence 15 23 16 4 42 8 . To sort an array with n n values in increasing order, selection sort first finds the maximum value, then moves it into its proper place, that is, the last position. This move is achieved by swapping the value currently in the last position with the maximum value. For instance, for 15 23 16 4 42 8 , 42 is the maximum value and 8 wrongly occupies the position reserved for the maximum value. After the first step, the array becomes 15 23 16 4 8 42 . We now focus on sorting the first n-1 n-1 values in the array (since the maximum is in place). To do this, we find the second largest value, and move it to the second last position. The array becomes 15 8 16 4 23 48 after this second step. The algorithm continues, moving the third largest value into place, the fourth largest value into place, etc., until the array is sorted. The table below shows the evolution of the array. Step Array Remarks 0 15 23 16 4 42 8 Input Array 1 15 23 16 4 8 42 Swap 42 and 8 2 15 8 16 4 23 42 Swap 23 and 8 3 15 8 4 16 23 42 Swap 16 and 4 4 4 8 15 16 23 42 Swap 15 and 4 5 4 8 15 16 23 42 8 happens to already be in position 6 4 8 15 16 23 42 4 must already be in position Write a program selectionsort that, reads the following, from the standard input, n n , the number of integers to sort followed by n n integers into an array, and prints, to the standard output, n - 1 n - 1 lines, each line showing the array after moving the largest or the next largest element into position. You can assume that the input list of n n integers to be sorted are unique -- i.e., no repetition. Sample Run ooiwt@pe119:~/as04-skeleton$ ./selectionsort 6 15 23 16 4 42 8 15 23 16 4 8 42 15 8 16 4 23 42 15 8 4 16 23 42 4 8 15 16 23 42 4 8 15 16 23 42 ooiwt@pe119:~/as04-skeleton$ ./selectionsort 3 0 4 8 0 4 8 0 4 8 ooiwt@pe119:~/as04-skeleton$ ./selectionsort 5 1 3 5 4 2 1 3 2 4 5 1 3 2 4 5 1 2 3 4 5 1 2 3 4 5 Question 2: Add (15 marks) In this question, you are asked to write a program that adds two non-negative numbers which can be arbitrarily large. The types provided by C can only represent a number up to a certain value. We have seen that long long int is not even big enough to represent 21!. For this question, we will represent a number using an arbitrarily long string consisting of characters (of type char ) '0' to '9' (note: not integer 0 to 9). C supports arithmetic operations on char values as well. To convert between the numerical value of a digit character, we can do the following: To convert from a digit character to its numerical value, we subtract the char '0' . For instance, '6' - '0' will give us the value 6 . To convert from a numerical value of a digit to its character, we add the char '0' . For instance, 6 + '0' will give us the character '6' . You can read a sequence of non-space characters from the standard input using cs1010_read_word , and print a sequence of characters (i.e., a string) to the standard output using cs1010_println_string . Write a program add that reads from the standard input two non-negative numbers represented as strings consisting of digits '0' to '9', and prints to the standard output the sum of the two numbers. You will likely need to use the C standard library function strlen , which returns you the number of characters in a string (excluding the terminating '\\0'). Look up on how to use this function on your own. Sample Run ooiwt@pe119:~/as04-skeleton$ ./add 1 1 2 ooiwt@pe119:~/as04-skeleton$ ./add 7 8 15 ooiwt@pe119:~/as04-skeleton$ ./add 999999 1 1000000 ooiwt@pe119:~/as04-skeleton$ ./add 1400060514000605140006051400605 19330911933091193309119330911933091 19332311993605193914259336963333696 Question 3: Mastermind (15 marks) Photo by fl\u00f6schen , some right reserved Mastermind is a board game played by two players, a coder and a codebreaker . The coder creates a code consists of four color pegs, chosen from pegs of six different colors (cyan, green, red, blue, purple, orange). Repetition of the same colors is allowed. The codebreaker's task is to guess the colors of the pegs and the order their appears in the code. The game proceeds in rounds. In each round, the codebreaker tries to guess the code by specifying the colors and the order of the colors. The coder then provides feedback to the codebreaker, with two smaller pegs of black and white color. A black color peg is placed if the codebreaker guesses correctly a peg in both position and color. A white color peg is placed if the codebreaker guesses correctly a peg in color but not in the position. Based on the feedback, the codebreaker guesses again in the next round. In the actual board game, the codebreaker wins if he guesses correctly every color in the correct order. The coder wins if the codebreaker failed to guess correctly after 8 guesses. Write a program called mastermind that simulates the Mastermind game. The program first reads in the code from the standard inputs. We denote the colors with their initials, c , g , r , b , p , o . Hence, the code is a 4-letter word. For instance, the code prob corresponds the pegs purple, red, orange, blue, in that order. It then reads in a sequence of guesses, each is a 4-letter word consists of the letter c , g , r , b , p , o . For each guess, the program prints out two numbers, the first is the number of pegs that are correct in both position and color. The second, is the number of pegs that are correct in color but not position. Note that we do not double count, so the total of these two numbers is at most 4. For example, if the code is prob and the guess is borg , the program prints 0 3 . Since none of the guesses is correct in both color and position. The three colors b , o , r , however, appear in the code, albeit in a different position. Suppose the guess is rrrr , the program prints 1 0 . The third r is the guess appears in the correct position and correct color. There is no other r in the code, so the second number is 0. This example illustrates that we do not double count. We do not match the other r s in the guess to the r in the code, once the r in the code has been matched. The program terminates when the guess is the same as the code. Sample Run ooiwt@pe119:~/as04-skeleton$ ./mastermind prob borg 0 3 rrrr 1 0 bbbb 1 0 oorr 0 2 prob 4 0 ooiwt@pe119:~/as04-skeleton$ ./mastermind cccp borg 0 0 prob 0 1 oooc 0 1 crrc 1 1 pcpc 1 2 cpcp 3 0 cccp 4 0","title":"4. SelectionSort, Add, Mastermind"},{"location":"as04.html#assignment-4-selectionsort-add-mastermind","text":"","title":"Assignment 4: SelectionSort, Add, Mastermind"},{"location":"as04.html#deadline","text":"12 October, 2018 (Friday), 6:00pm.","title":"Deadline"},{"location":"as04.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as04.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays, and strings. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.","title":"Learning Outcomes"},{"location":"as04.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as04 You should see the folder as04-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as04.html#solving-the-assignments","text":"Edit the files selectionsort.c , add.c , mastermind.c , to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed.","title":"Solving The Assignments"},{"location":"as04.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as04 The files selectionsort.c , add.c , mastermind.c , will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as04.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Jean Luc Picard (Group 9)","title":"Identifying Yourself"},{"location":"as04.html#grading","text":"This assignment contributes towards 4% of your final grade. The total mark for this assignment is 40 marks. There are three marking criteria: correctness, documentation, and style. Documentation: For each question, two marks are allocated for documentation. Please refer to the documentation and follow the recommended format. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. Style: For each question, two marks are allocated for style. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as04.html#question-1-selectionsort-10-marks","text":"You have implemented counting sort, a simple and fast sorting algorithm that works on integers with limited range. But if the range of possible values to be sorted is huge or unlimited, then, counting sort does not work so well, and we need a different kind of sorting algorithm. In this question, you are asked to implement selection sort. The idea behind selection sort is simple, and we will illustrate with the sequence 15 23 16 4 42 8 . To sort an array with n n values in increasing order, selection sort first finds the maximum value, then moves it into its proper place, that is, the last position. This move is achieved by swapping the value currently in the last position with the maximum value. For instance, for 15 23 16 4 42 8 , 42 is the maximum value and 8 wrongly occupies the position reserved for the maximum value. After the first step, the array becomes 15 23 16 4 8 42 . We now focus on sorting the first n-1 n-1 values in the array (since the maximum is in place). To do this, we find the second largest value, and move it to the second last position. The array becomes 15 8 16 4 23 48 after this second step. The algorithm continues, moving the third largest value into place, the fourth largest value into place, etc., until the array is sorted. The table below shows the evolution of the array. Step Array Remarks 0 15 23 16 4 42 8 Input Array 1 15 23 16 4 8 42 Swap 42 and 8 2 15 8 16 4 23 42 Swap 23 and 8 3 15 8 4 16 23 42 Swap 16 and 4 4 4 8 15 16 23 42 Swap 15 and 4 5 4 8 15 16 23 42 8 happens to already be in position 6 4 8 15 16 23 42 4 must already be in position Write a program selectionsort that, reads the following, from the standard input, n n , the number of integers to sort followed by n n integers into an array, and prints, to the standard output, n - 1 n - 1 lines, each line showing the array after moving the largest or the next largest element into position. You can assume that the input list of n n integers to be sorted are unique -- i.e., no repetition.","title":"Question 1: SelectionSort (10 marks)"},{"location":"as04.html#sample-run","text":"ooiwt@pe119:~/as04-skeleton$ ./selectionsort 6 15 23 16 4 42 8 15 23 16 4 8 42 15 8 16 4 23 42 15 8 4 16 23 42 4 8 15 16 23 42 4 8 15 16 23 42 ooiwt@pe119:~/as04-skeleton$ ./selectionsort 3 0 4 8 0 4 8 0 4 8 ooiwt@pe119:~/as04-skeleton$ ./selectionsort 5 1 3 5 4 2 1 3 2 4 5 1 3 2 4 5 1 2 3 4 5 1 2 3 4 5","title":"Sample Run"},{"location":"as04.html#question-2-add-15-marks","text":"In this question, you are asked to write a program that adds two non-negative numbers which can be arbitrarily large. The types provided by C can only represent a number up to a certain value. We have seen that long long int is not even big enough to represent 21!. For this question, we will represent a number using an arbitrarily long string consisting of characters (of type char ) '0' to '9' (note: not integer 0 to 9). C supports arithmetic operations on char values as well. To convert between the numerical value of a digit character, we can do the following: To convert from a digit character to its numerical value, we subtract the char '0' . For instance, '6' - '0' will give us the value 6 . To convert from a numerical value of a digit to its character, we add the char '0' . For instance, 6 + '0' will give us the character '6' . You can read a sequence of non-space characters from the standard input using cs1010_read_word , and print a sequence of characters (i.e., a string) to the standard output using cs1010_println_string . Write a program add that reads from the standard input two non-negative numbers represented as strings consisting of digits '0' to '9', and prints to the standard output the sum of the two numbers. You will likely need to use the C standard library function strlen , which returns you the number of characters in a string (excluding the terminating '\\0'). Look up on how to use this function on your own.","title":"Question 2: Add (15 marks)"},{"location":"as04.html#sample-run_1","text":"ooiwt@pe119:~/as04-skeleton$ ./add 1 1 2 ooiwt@pe119:~/as04-skeleton$ ./add 7 8 15 ooiwt@pe119:~/as04-skeleton$ ./add 999999 1 1000000 ooiwt@pe119:~/as04-skeleton$ ./add 1400060514000605140006051400605 19330911933091193309119330911933091 19332311993605193914259336963333696","title":"Sample Run"},{"location":"as04.html#question-3-mastermind-15-marks","text":"Photo by fl\u00f6schen , some right reserved Mastermind is a board game played by two players, a coder and a codebreaker . The coder creates a code consists of four color pegs, chosen from pegs of six different colors (cyan, green, red, blue, purple, orange). Repetition of the same colors is allowed. The codebreaker's task is to guess the colors of the pegs and the order their appears in the code. The game proceeds in rounds. In each round, the codebreaker tries to guess the code by specifying the colors and the order of the colors. The coder then provides feedback to the codebreaker, with two smaller pegs of black and white color. A black color peg is placed if the codebreaker guesses correctly a peg in both position and color. A white color peg is placed if the codebreaker guesses correctly a peg in color but not in the position. Based on the feedback, the codebreaker guesses again in the next round. In the actual board game, the codebreaker wins if he guesses correctly every color in the correct order. The coder wins if the codebreaker failed to guess correctly after 8 guesses. Write a program called mastermind that simulates the Mastermind game. The program first reads in the code from the standard inputs. We denote the colors with their initials, c , g , r , b , p , o . Hence, the code is a 4-letter word. For instance, the code prob corresponds the pegs purple, red, orange, blue, in that order. It then reads in a sequence of guesses, each is a 4-letter word consists of the letter c , g , r , b , p , o . For each guess, the program prints out two numbers, the first is the number of pegs that are correct in both position and color. The second, is the number of pegs that are correct in color but not position. Note that we do not double count, so the total of these two numbers is at most 4. For example, if the code is prob and the guess is borg , the program prints 0 3 . Since none of the guesses is correct in both color and position. The three colors b , o , r , however, appear in the code, albeit in a different position. Suppose the guess is rrrr , the program prints 1 0 . The third r is the guess appears in the correct position and correct color. There is no other r in the code, so the second number is 0. This example illustrates that we do not double count. We do not match the other r s in the guess to the r in the code, once the r in the code has been matched. The program terminates when the guess is the same as the code.","title":"Question 3: Mastermind (15 marks)"},{"location":"as04.html#sample-run_2","text":"ooiwt@pe119:~/as04-skeleton$ ./mastermind prob borg 0 3 rrrr 1 0 bbbb 1 0 oorr 0 2 prob 4 0 ooiwt@pe119:~/as04-skeleton$ ./mastermind cccp borg 0 0 prob 0 1 oooc 0 1 crrc 1 1 pcpc 1 2 cpcp 3 0 cccp 4 0","title":"Sample Run"},{"location":"as05.html","text":"Assignment 5: Social, Life Deadline 19 October, 2018 (Friday), 6:00pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as05 You should see the folder as05-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files social.c and life.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. new For Question 2, Life, there is no automated testing. So you will not see life: passed as per usual. Instead, you should run each test case manually and view the resulting animation. If an animation is too big to fit into your terminal, try enlarging the terminal or reducing the size of the terminal fonts. The largest canvas is 100 rows and 100 cols. Submission When you are ready, run the following command to submit: ~cs1010/submit-as05 The files social.c and life.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Mikasa Ackermann Grading This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are three marking criteria: correctness, documentation, and style. Documentation: For each question, two marks are allocated for documentation. Please refer to the documentation and follow the recommended format. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. new Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Question 1: Social (15 marks) The idea of six degrees of separation states that everyone in the world is connected to every other person by at most 6 hops. Suppose that a person A A is a friend of a person B B , then we say that A A is one hop away from B B . Consider a friend of B B , say C C , who is not a friend of A A . So C C is a friend of a friend of A A . We say that C C is two hops away from A A . Six degree of separation generally means there is a chain of friendship that can connect any two people in the world with no more than 6 hops. In this question, we are going to compute the chain of friendships up to the k k degree. Suppose there are n n people, and we know the social network of these n n people -- i.e., we know who is friend with who. Write a program social to compute a social network representing who is connected to who via a friendship chain of degree k k . We assume that friendship is bi-directional -- if A A is a friend of B B , then B B is a friend of A A . Because of this, we can represent a social network as a lower triangular matrix ( using jagged 2D array ). A proper type to store in each element of the matrix is bool . To simplify our life, however, we store each element of the matrix as a char , with '1' representing a friendship connection, '0' otherwise. The social network for n n people is thus an array of n n strings, each string containing characters of '0' and '1' only. The first row of the matrix is a string of length one; the second row is of length two; third row, length three, etc. The last character of each string (i.e., the diagonal of the matrix) is 1 since everyone is a friend with him/herself. For instance, suppose we have the following social network, with Row 1 for Person A A , Row 2 for Person B B , Row 3 for Person C C . 1 01 011 The social network above indicates that B B and C C are friends with each other. A A is not a friend with neither. As another example, the social network below shows an extra person D D (Row 4). 1 01 011 1011 D D is friend with both A A and C C . Suppose now we consider the social network of degree 2. A A is two hops away from C C ( A A knows D D and D D knows C C ). B B is also two hops away from D D ( B B knows C C and C C knows D D ). The generated social network of degree 2 becomes: 1 01 111 1111 Note that we cannot say everyone is connected to everyone else up to degree 2 in this example since A A is not a friend of a friend of B B -- i.e., A A and B B are still not connected, even if we consider a friendship chain of degree 2. Write a program social , that reads from standard input two positive integers n n and k k , followed by n n lines of strings consisting of '1' or '0' representing the social network of these n n people. Print, to the standard output, the social network formed by a friendship chain of degree k k . Finally, print, to the standard output, YES if everyone is connected to everyone within k hops, or NO otherwise. The purpose of this question is for you to practice using a jagged 2D array. Hence, you are not allowed to store the input matrix or intermediate matrices using a rectangular array , or you risk being penalized heavily for this question. Sample Run ooiwt@pe119:~/as05-skeleton$ cat inputs/social.1.in 3 1 1 11 011 ooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.1.in 1 11 011 NO ooiwt@pe119:~/as05-skeleton$ cat inputs/social.2.in 4 2 1 01 011 1011 ooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.2.in 1 01 111 1111 NO ooiwt@pe119:~/as05-skeleton$ cat inputs/social.3.in 5 2 1 11 011 0011 10011 ooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.3.in 1 11 111 1111 11111 YES Question 2: Life (15 marks) The \"Game of Life\" is a game played on a two-dimensional orthogonal grid of square cells, while each cell has only two possible states: alive or dead. The game is played in iterations. During each iteration, each cell becomes alive or dead, depending on the state of its four neighboring cells in the previous iteration. Interesting patterns and moving behavior can be created, sometimes infinitely, from an initial state. Refer to wiki page for more details if you are interested. In this problem, we are going to simulate a game of life for a certain number of iterations, given a starting state. Here is a complete description of the rules of the simulation. The universe is a bounded plane and can be simply referred to as a two-dimensional orthogonal grid of square cells with n n rows and m m columns. For convenience, we let row indexes as 0 to n-1 n-1 from top to bottom, and column indexes as 0 to m-1 m-1 from left to right. So in total, there are n \\times m n \\times m cells. The neighbor of a cell is defined as the eight cells that are either horizontally, vertically, or diagonally connected to the cell. An initial state is given, with each cell is marked as either \"live\" or \"dead\". In each iteration, a cell may switch its state, according to rules below, by referring to the state of the previous iteration: Any live cell with fewer than two live neighbors becomes dead Any live cell with two or three live neighbors remains alive. Any live cell with more than three live neighbors becomes dead. Any dead cell with exactly three live neighbors becomes alive Border cells, i.e., cells with row number 0 or n-1 n-1 , or column number 0 or m-1 m-1 , are always dead. This is to simplify and bound the universe. Write a program life that reads, from the standard inputs, three positive integers n n ( n > 2 n > 2 ), m m ( m > 2 m > 2 ) and k k , where n n and m m denotes the number of rows and number of columns of the universe (an n\\times m n\\times m grid), and k k is the number of iterations to simulate. It then reads, from the standard input, n n rows, with m m characters in each row representing the initial state. Each character is either alive ( '#' ) or dead ( '.' ). The program then prints, to standard output, an animation of the universe for k k iterations. The output should only contain n n rows with m m characters in each row. Similarly, you must use # to represent a live cell, and . to represents a dead cell. Animation on Screen We have provided a few lines of code in the skeleton file. You should insert this at appropriate places: char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H'}; : cs1010_print_string(clear_screen); // TODO(by student) draw the universe usleep(250*1000); Line 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal. Line 5 calls the system function usleep that takes in the number of microseconds. Calling usleep causes the program to pause for that amount of time. We set the sleeping time to 250ms. You can reduce if you wish but you must not increase this beyond 250ms or your program might fail when we test it during grading. Sample Inputs The pattern from life.1.in is called a blinker. The pattern from life.2.in is called a pentadecathlon. The pattern from life.4.in is called a pulsar. We provide a total of seven patterns for your to play with. If you wish the check if your output is correct, you can still redirect the output from life to a file, and compare it with the corresponding output under the output directory using the diff command: ooiwt@pe119:~/as05-skeleton$ ./life < inputs/life.3.in > OUT ooiwt@pe119:~/as05-skeleton$ diff OUT outputs/life.3.out If diff does not list any differences, then the output from your life is the same as the expected output. Students interested to play more game of life can also check out LifeWiki for more patterns and spiral-click into various information about this game.","title":"5. Social, Life"},{"location":"as05.html#assignment-5-social-life","text":"","title":"Assignment 5: Social, Life"},{"location":"as05.html#deadline","text":"19 October, 2018 (Friday), 6:00pm.","title":"Deadline"},{"location":"as05.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as05.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be.","title":"Learning Outcomes"},{"location":"as05.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as05 You should see the folder as05-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as05.html#solving-the-assignments","text":"Edit the files social.c and life.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. new For Question 2, Life, there is no automated testing. So you will not see life: passed as per usual. Instead, you should run each test case manually and view the resulting animation. If an animation is too big to fit into your terminal, try enlarging the terminal or reducing the size of the terminal fonts. The largest canvas is 100 rows and 100 cols.","title":"Solving The Assignments"},{"location":"as05.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as05 The files social.c and life.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as05.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Mikasa Ackermann","title":"Identifying Yourself"},{"location":"as05.html#grading","text":"This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are three marking criteria: correctness, documentation, and style. Documentation: For each question, two marks are allocated for documentation. Please refer to the documentation and follow the recommended format. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. new Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as05.html#question-1-social-15-marks","text":"The idea of six degrees of separation states that everyone in the world is connected to every other person by at most 6 hops. Suppose that a person A A is a friend of a person B B , then we say that A A is one hop away from B B . Consider a friend of B B , say C C , who is not a friend of A A . So C C is a friend of a friend of A A . We say that C C is two hops away from A A . Six degree of separation generally means there is a chain of friendship that can connect any two people in the world with no more than 6 hops. In this question, we are going to compute the chain of friendships up to the k k degree. Suppose there are n n people, and we know the social network of these n n people -- i.e., we know who is friend with who. Write a program social to compute a social network representing who is connected to who via a friendship chain of degree k k . We assume that friendship is bi-directional -- if A A is a friend of B B , then B B is a friend of A A . Because of this, we can represent a social network as a lower triangular matrix ( using jagged 2D array ). A proper type to store in each element of the matrix is bool . To simplify our life, however, we store each element of the matrix as a char , with '1' representing a friendship connection, '0' otherwise. The social network for n n people is thus an array of n n strings, each string containing characters of '0' and '1' only. The first row of the matrix is a string of length one; the second row is of length two; third row, length three, etc. The last character of each string (i.e., the diagonal of the matrix) is 1 since everyone is a friend with him/herself. For instance, suppose we have the following social network, with Row 1 for Person A A , Row 2 for Person B B , Row 3 for Person C C . 1 01 011 The social network above indicates that B B and C C are friends with each other. A A is not a friend with neither. As another example, the social network below shows an extra person D D (Row 4). 1 01 011 1011 D D is friend with both A A and C C . Suppose now we consider the social network of degree 2. A A is two hops away from C C ( A A knows D D and D D knows C C ). B B is also two hops away from D D ( B B knows C C and C C knows D D ). The generated social network of degree 2 becomes: 1 01 111 1111 Note that we cannot say everyone is connected to everyone else up to degree 2 in this example since A A is not a friend of a friend of B B -- i.e., A A and B B are still not connected, even if we consider a friendship chain of degree 2. Write a program social , that reads from standard input two positive integers n n and k k , followed by n n lines of strings consisting of '1' or '0' representing the social network of these n n people. Print, to the standard output, the social network formed by a friendship chain of degree k k . Finally, print, to the standard output, YES if everyone is connected to everyone within k hops, or NO otherwise. The purpose of this question is for you to practice using a jagged 2D array. Hence, you are not allowed to store the input matrix or intermediate matrices using a rectangular array , or you risk being penalized heavily for this question.","title":"Question 1: Social (15 marks)"},{"location":"as05.html#sample-run","text":"ooiwt@pe119:~/as05-skeleton$ cat inputs/social.1.in 3 1 1 11 011 ooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.1.in 1 11 011 NO ooiwt@pe119:~/as05-skeleton$ cat inputs/social.2.in 4 2 1 01 011 1011 ooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.2.in 1 01 111 1111 NO ooiwt@pe119:~/as05-skeleton$ cat inputs/social.3.in 5 2 1 11 011 0011 10011 ooiwt@pe119:~/as05-skeleton$ ./social < inputs/social.3.in 1 11 111 1111 11111 YES","title":"Sample Run"},{"location":"as05.html#question-2-life-15-marks","text":"The \"Game of Life\" is a game played on a two-dimensional orthogonal grid of square cells, while each cell has only two possible states: alive or dead. The game is played in iterations. During each iteration, each cell becomes alive or dead, depending on the state of its four neighboring cells in the previous iteration. Interesting patterns and moving behavior can be created, sometimes infinitely, from an initial state. Refer to wiki page for more details if you are interested. In this problem, we are going to simulate a game of life for a certain number of iterations, given a starting state. Here is a complete description of the rules of the simulation. The universe is a bounded plane and can be simply referred to as a two-dimensional orthogonal grid of square cells with n n rows and m m columns. For convenience, we let row indexes as 0 to n-1 n-1 from top to bottom, and column indexes as 0 to m-1 m-1 from left to right. So in total, there are n \\times m n \\times m cells. The neighbor of a cell is defined as the eight cells that are either horizontally, vertically, or diagonally connected to the cell. An initial state is given, with each cell is marked as either \"live\" or \"dead\". In each iteration, a cell may switch its state, according to rules below, by referring to the state of the previous iteration: Any live cell with fewer than two live neighbors becomes dead Any live cell with two or three live neighbors remains alive. Any live cell with more than three live neighbors becomes dead. Any dead cell with exactly three live neighbors becomes alive Border cells, i.e., cells with row number 0 or n-1 n-1 , or column number 0 or m-1 m-1 , are always dead. This is to simplify and bound the universe. Write a program life that reads, from the standard inputs, three positive integers n n ( n > 2 n > 2 ), m m ( m > 2 m > 2 ) and k k , where n n and m m denotes the number of rows and number of columns of the universe (an n\\times m n\\times m grid), and k k is the number of iterations to simulate. It then reads, from the standard input, n n rows, with m m characters in each row representing the initial state. Each character is either alive ( '#' ) or dead ( '.' ). The program then prints, to standard output, an animation of the universe for k k iterations. The output should only contain n n rows with m m characters in each row. Similarly, you must use # to represent a live cell, and . to represents a dead cell.","title":"Question 2: Life (15 marks)"},{"location":"as05.html#animation-on-screen","text":"We have provided a few lines of code in the skeleton file. You should insert this at appropriate places: char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H'}; : cs1010_print_string(clear_screen); // TODO(by student) draw the universe usleep(250*1000); Line 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal. Line 5 calls the system function usleep that takes in the number of microseconds. Calling usleep causes the program to pause for that amount of time. We set the sleeping time to 250ms. You can reduce if you wish but you must not increase this beyond 250ms or your program might fail when we test it during grading.","title":"Animation on Screen"},{"location":"as05.html#sample-inputs","text":"The pattern from life.1.in is called a blinker. The pattern from life.2.in is called a pentadecathlon. The pattern from life.4.in is called a pulsar. We provide a total of seven patterns for your to play with. If you wish the check if your output is correct, you can still redirect the output from life to a file, and compare it with the corresponding output under the output directory using the diff command: ooiwt@pe119:~/as05-skeleton$ ./life < inputs/life.3.in > OUT ooiwt@pe119:~/as05-skeleton$ diff OUT outputs/life.3.out If diff does not list any differences, then the output from your life is the same as the expected output. Students interested to play more game of life can also check out LifeWiki for more patterns and spiral-click into various information about this game.","title":"Sample Inputs"},{"location":"as06.html","text":"Assignment 6: Permutation 1 2 3 Deadline 26 October, 2018 (Friday), 23:59pm New time Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. (new) Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as06 You should see the folder as06-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files permutate1.c , permutate2.c , permutate3.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. (new) You should solve each problem using the most straightforward algorithm that you can think of first. Make sure that it runs correctly before trying to improve the efficiency of the algorithm. To compile and run tests with the sample inputs and outputs: make A minimal set of test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You should add more test cases or edit the given ones to extensively test your programs . Submission When you are ready, run the following command to submit: ~cs1010/submit-as06 The C files given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Sheldon Cooper (Group 09) Grading This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are four marking criteria: efficiency, correctness, documentation, and style. (new) Efficiency: For each question, some marks are allocated for efficiency. See the question for the breakdown and marking criteria for efficiency. Documentation: For each question, two marks are allocated for documentation. Please refer to the documentation and follow the recommended format. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Question 1: Permutation 1 (6 marks) Write a program permutation1 , that, given two list of numbers, L_1 L_1 and L_2 L_2 , checks if L_2 L_2 is a permutation of L_1 L_1 . We say one list is a permutation of another, if the two lists contain exactly the same numbers, but possibly in different order. For instance, the list 1 3 4 9 10 10 is a permutation of 10 9 10 3 1 4 , since they contain the same numbers in different order. Your program should read, from the standard input, a positive integer n n , a list L_1 L_1 , consists of n n integer values a list L_2 L_2 , consists of n n integer values and print, to the standard output, YES if L_2 L_2 is a permutation of L_1 L_1 , and NO otherwise. Your solution must take no more than O(n^2) O(n^2) time. The grading criteria for this question is: Marks Documentation 2 Correctness 3 Efficiency 1 A solution that takes longer than O(n^2) O(n^2) will receive 0 marks for efficiency. Furthermore, your solution needs to be correct to receive marks for efficiency. Question 2: Permutation 2 (10 marks) Write a program permutation2 , that, given two strings, consists of alphabets 'a' to 'z', S_1 S_1 and S_2 S_2 , checks if S_2 S_2 is a permutation of S_1 S_1 . We say a string is a permutation of another, if the two strings contain exactly the same alphabets, but possibly in different order. For instance, nus is a permutation of sun . Your program should read, from the standard input, a string S_1 S_1 , consists of n n lowercase alphabets ( a to z ) a string S_2 S_2 , consists of n n lowercase alphabets ( a to z ) and print, to the standard output, YES if S_2 S_2 is a permutation of S_1 S_1 , and NO otherwise. Your solution must take no more than O(n) O(n) time. The grading criteria for this question is: Marks Documentation 2 Correctness 3 Efficiency 5 A solution that takes longer than O(n) O(n) will receive 0 marks for efficiency. Furthermore, your solution needs to be correct to receive marks for efficiency. Question 3: Permutation 3 (14 marks) Write a program permutation3 , that, given two strings, consists of alphabets 'a' to 'z', S_1 S_1 and S_2 S_2 , checks if S_2 S_1 S_1 is a permutation of some substring of S_1 S_2 S_2 . A substring of length k k is a consecutive sequence of k k characters from a string. For instance, nus is a permutation of a substring of suntec , since suntec contains sun . ntu is also a permutation of a substring of suntec , since suntec contains unt . smu is not a permutation of any substring of suntec . Your program should read, from the standard input, a string S_1 S_1 , consists of k k characters, chosen from a to z a string S_2 S_2 , consists of n n characters, chosen from a to z and print, to the standard output, YES if S_1 S_1 is a permutation of some substring of length k k from S_2 S_2 , and NO otherwise. The grading criteria for this question is: Marks Documentation 2 Correctness 5 Efficiency 7 Your solution needs to be correct to receive marks for efficiency. The efficiency marks are given as follows: O(nk^2) O(nk^2) solution: 2 marks O(nk) O(nk) solution: 4 marks O(n+k) O(n+k) solution: 7 marks Hint Avoid repetitive work!","title":"6. Permutation 1 2 3"},{"location":"as06.html#assignment-6-permutation-1-2-3","text":"","title":"Assignment 6: Permutation 1 2 3"},{"location":"as06.html#deadline","text":"26 October, 2018 (Friday), 23:59pm New time","title":"Deadline"},{"location":"as06.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as06.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. (new) Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.","title":"Learning Outcomes"},{"location":"as06.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as06 You should see the folder as06-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as06.html#solving-the-assignments","text":"Edit the files permutate1.c , permutate2.c , permutate3.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. (new) You should solve each problem using the most straightforward algorithm that you can think of first. Make sure that it runs correctly before trying to improve the efficiency of the algorithm. To compile and run tests with the sample inputs and outputs: make A minimal set of test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You should add more test cases or edit the given ones to extensively test your programs .","title":"Solving The Assignments"},{"location":"as06.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as06 The C files given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as06.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Sheldon Cooper (Group 09)","title":"Identifying Yourself"},{"location":"as06.html#grading","text":"This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are four marking criteria: efficiency, correctness, documentation, and style. (new) Efficiency: For each question, some marks are allocated for efficiency. See the question for the breakdown and marking criteria for efficiency. Documentation: For each question, two marks are allocated for documentation. Please refer to the documentation and follow the recommended format. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as06.html#question-1-permutation-1-6-marks","text":"Write a program permutation1 , that, given two list of numbers, L_1 L_1 and L_2 L_2 , checks if L_2 L_2 is a permutation of L_1 L_1 . We say one list is a permutation of another, if the two lists contain exactly the same numbers, but possibly in different order. For instance, the list 1 3 4 9 10 10 is a permutation of 10 9 10 3 1 4 , since they contain the same numbers in different order. Your program should read, from the standard input, a positive integer n n , a list L_1 L_1 , consists of n n integer values a list L_2 L_2 , consists of n n integer values and print, to the standard output, YES if L_2 L_2 is a permutation of L_1 L_1 , and NO otherwise. Your solution must take no more than O(n^2) O(n^2) time. The grading criteria for this question is: Marks Documentation 2 Correctness 3 Efficiency 1 A solution that takes longer than O(n^2) O(n^2) will receive 0 marks for efficiency. Furthermore, your solution needs to be correct to receive marks for efficiency.","title":"Question 1: Permutation 1 (6 marks)"},{"location":"as06.html#question-2-permutation-2-10-marks","text":"Write a program permutation2 , that, given two strings, consists of alphabets 'a' to 'z', S_1 S_1 and S_2 S_2 , checks if S_2 S_2 is a permutation of S_1 S_1 . We say a string is a permutation of another, if the two strings contain exactly the same alphabets, but possibly in different order. For instance, nus is a permutation of sun . Your program should read, from the standard input, a string S_1 S_1 , consists of n n lowercase alphabets ( a to z ) a string S_2 S_2 , consists of n n lowercase alphabets ( a to z ) and print, to the standard output, YES if S_2 S_2 is a permutation of S_1 S_1 , and NO otherwise. Your solution must take no more than O(n) O(n) time. The grading criteria for this question is: Marks Documentation 2 Correctness 3 Efficiency 5 A solution that takes longer than O(n) O(n) will receive 0 marks for efficiency. Furthermore, your solution needs to be correct to receive marks for efficiency.","title":"Question 2: Permutation 2 (10 marks)"},{"location":"as06.html#question-3-permutation-3-14-marks","text":"Write a program permutation3 , that, given two strings, consists of alphabets 'a' to 'z', S_1 S_1 and S_2 S_2 , checks if S_2 S_1 S_1 is a permutation of some substring of S_1 S_2 S_2 . A substring of length k k is a consecutive sequence of k k characters from a string. For instance, nus is a permutation of a substring of suntec , since suntec contains sun . ntu is also a permutation of a substring of suntec , since suntec contains unt . smu is not a permutation of any substring of suntec . Your program should read, from the standard input, a string S_1 S_1 , consists of k k characters, chosen from a to z a string S_2 S_2 , consists of n n characters, chosen from a to z and print, to the standard output, YES if S_1 S_1 is a permutation of some substring of length k k from S_2 S_2 , and NO otherwise. The grading criteria for this question is: Marks Documentation 2 Correctness 5 Efficiency 7 Your solution needs to be correct to receive marks for efficiency. The efficiency marks are given as follows: O(nk^2) O(nk^2) solution: 2 marks O(nk) O(nk) solution: 4 marks O(n+k) O(n+k) solution: 7 marks Hint Avoid repetitive work!","title":"Question 3: Permutation 3 (14 marks)"},{"location":"as07.html","text":"Assignment 7: Peak, Scripts, Inversion Deadline 2 November 2018 (Friday), 23:59pm Prerequisites You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. Be comfortable designing algorithms related to solve computational problems related to searching and sorting, within the given big-O time efficiency bound. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work. Setup Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as07 You should see the folder as07-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the files peak.c , scripts.c , inversion.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make A minimal set of test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You should add more test cases or edit the given ones to extensively test your programs . Submission When you are ready, run the following command to submit: ~cs1010/submit-as07 The C files given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Sarah J. Connor (Group 09) Grading This assignment contributes towards 3% 4% of your final grade. The total mark for this assignment is 30 40 marks. There are five marking criteria: design, efficiency, correctness, documentation, and style. Design: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem. You should avoid repetitive code that can be factored out as a function. Writing everything in a single long function main or cutting-and-pasting code would likely cause you to loose mark for this criteria. Efficiency: See the question for the breakdown and marking criteria for efficiency. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Documentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly. Please refer to the documentation and follow the recommended format. We have added the compilation flag -Wdocumentation to help you identify documentation errors. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Question 1: Peak (10 marks) John helped his professor, Professor Reese, to conduct a topographic survey of a piece of land. He walked in a straight line, noting down the elevation of the land at every centimeter. After he is done, he passed the data to Professor Reese. The professor then asked him, \"what is the peak elevation of the land?\" John did not know the answer! He could write a program to scan through the millions of data points he collected, but he knew that, since you have taken CS1010, you can do a better job. So, John asked for your help. You first clarify the problem with John: \"What is a peak?\" To which John explained that a peak is a location that is strictly higher than the surrounding locations. You then asked: \"Is it guaranteed that there is exactly one peak?\" John then explained the pattern in the data: the elevation always either remains the same or increases as he walks. After he passed the peak, the elevation always either remains the same, or decreases. But he cannot remember if he ever encountered a peak -- it might be possible that the elevations data is always non-decreasing, or non-increasing, or there is a flat plateau where there are multiple highest locations with the same elevation. So, a peak might not exist. But if there is a peak, it is guaranteed that there is exactly one peak. \"Please, can you help me solve it in O(log n) O(log n) time?\" John pleaded. \"Piece of cake!\" You said. Write a program peak that reads from the standard input the following: An integer n n ( n \\ge 3 n \\ge 3 ), followed by n n integers, each representing the elevation of a location surveyed by John Then, prints, to the standard output, the index of the location of the peak if it exists, or no peak if a peak does not exist. The first elevation has an index of 0. An O(n) O(n) solution is trivial. You will get 0 marks if your solution simply scans through the array linearly looking for an elevation that is the peak. That is what John would do anyway! To get full marks for correctness and efficiency for this solution, your code should run in O(log n) O(log n) time when the input elevations are all distinct. Your code is allowed to take longer than O(log n) O(log n) if there are equal elevations in the input data, with the extreme case of O(n) O(n) when all elevation values are the same (the land is completely flat). Sample Run ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.1.in 5 1 3 5 4 2 ooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.1.in 2 ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.2.in 3 1 2 3 ooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.2.in no peak ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.3.in 4 -1 2 2 -1 ooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.3.in no peak Question 2: Scripts (10 marks) Professor Reese is teaching a huge class at the university. He finished grading a test and he asked John to help him enter the grades into IVLE grade book, in increasing order of the student id. John asked the professor, \"Are the scripts sorted?\", to which the professor answered, \"Almost! The top portion of the pile is sorted in increasing order. The rest, in decreasing order.\" The professor then left after saying \"Hasta la vista, baby,\" leaving John to wonder how to deal with the test scripts. John needed to sort the scripts in increasing order of the student id. So he messaged you to help him figure out an efficient algorithm to do this. \"No problemo!\", you said, \"Can be done in O(n) O(n) !\" You said. So you went ahead and wrote out the following program to show John how he can solve his problem in O(n) O(n) time. Write a program scripts that reads, from the standard input, the following: An integer n n ( n \\ge 1 n \\ge 1 ), followed by n n integers, each representing the student ids. The student ids are unique, i.e., there is no duplicate in the inputs. The student ids from the inputs are arranged in such a way that, the first k k are in increasing order, the remaining n - k n - k are in decreasing order. k k is not given in the input, and 0 \\le k \\le n 0 \\le k \\le n . Then, prints, to the standard output, the student ids in increasing order. An O(n^2) O(n^2) or O(n log n) O(n log n) solution is trivial. You will get 0 marks for correctness and efficiency if your solution simply uses one of the existing sorting algorithms to sort the scripts. Note also that you cannot use counting sort here since a student id can be represented with an arbitrarily large integer (but still fit in a long ). Hint: Allocate an output array and populate it with integers taken either from the front or from the back of the input array depending on which one is larger. Sample Run ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.1.in 5 1 3 5 4 2 ooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in 1 2 3 4 5 ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.2.in 3 1 20 300 ooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in 1 20 300 ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.3.in 1 -100 ooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.3.in -100 Question 3: Inversion (20 marks) Professor Reese called John in the evening. \"Mr. Connor, I told you that the pile of scripts is almost sorted. But I do not know what it means by almost actually. Can you help me figured out how to quantify that?\" John is clueless as well. So he called you. \"Ah, I learned this in CS1010 Assignment 3,\" you boasted, \"we can count the number of inversions.\" You then go on to explain that an inversion is a pair of scripts that are out of order. A perfectly sorted pile of scripts would have zero inversion, and an inversely sorted pile of scripts would have n \\times (n-1)/2 n \\times (n-1)/2 inversions. \"Let me help you to do this, in O(n) O(n) time!\" Write a program inversion that reads, from the standard input, the following: An integer n n ( n \\ge 1 n \\ge 1 ), followed by n n integers, each representing the student ids. The student ids are unique, i.e., there is no duplicate in the inputs. The student ids from the inputs are arranged in such a way that, the first k k are in increasing order, the remaining n - k n - k are in decreasing order. k k is not given in the input, and 0 \\le k \\le n 0 \\le k \\le n . You program should then prints, to the standard output, the number of inversions in the input. You have already solved this problem in Assignment 3 in O(n^2) O(n^2) time, so, an O(n^2) O(n^2) solution would receive 0 marks. An O(n log n) O(n log n) solution will get 10 marks for correctness and efficiency at most (Hint for O(n log n) O(n log n) solution: binary search). To get full marks for correctness and efficiency, you need to produce an O(n) O(n) solution (Hint for O(n) O(n) : sort). Sample Run ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.1.in 5 1 3 5 4 2 ooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in 4 ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.2.in 3 1 20 300 ooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in 0 ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.3.in 1 -100 ooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.3.in 0 Bug in Sample Output If you retrieve the assignment before 8am Saturday morning, your sample output for inversion.1.out says 5 , but it should be 4 . The inversions are 5 4 , 3 2 , 5 2 , and 4 2 .","title":"7. Peak, Scripts, Inversion"},{"location":"as07.html#assignment-7-peak-scripts-inversion","text":"","title":"Assignment 7: Peak, Scripts, Inversion"},{"location":"as07.html#deadline","text":"2 November 2018 (Friday), 23:59pm","title":"Deadline"},{"location":"as07.html#prerequisites","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisites"},{"location":"as07.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. Be comfortable designing algorithms related to solve computational problems related to searching and sorting, within the given big-O time efficiency bound. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.","title":"Learning Outcomes"},{"location":"as07.html#setup","text":"Click on this link to accept the assignment. Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as07 You should see the folder as07-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as07.html#solving-the-assignments","text":"Edit the files peak.c , scripts.c , inversion.c to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make A minimal set of test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You should add more test cases or edit the given ones to extensively test your programs .","title":"Solving The Assignments"},{"location":"as07.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as07 The C files given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as07.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Sarah J. Connor (Group 09)","title":"Identifying Yourself"},{"location":"as07.html#grading","text":"This assignment contributes towards 3% 4% of your final grade. The total mark for this assignment is 30 40 marks. There are five marking criteria: design, efficiency, correctness, documentation, and style. Design: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem. You should avoid repetitive code that can be factored out as a function. Writing everything in a single long function main or cutting-and-pasting code would likely cause you to loose mark for this criteria. Efficiency: See the question for the breakdown and marking criteria for efficiency. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Documentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly. Please refer to the documentation and follow the recommended format. We have added the compilation flag -Wdocumentation to help you identify documentation errors. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as07.html#question-1-peak-10-marks","text":"John helped his professor, Professor Reese, to conduct a topographic survey of a piece of land. He walked in a straight line, noting down the elevation of the land at every centimeter. After he is done, he passed the data to Professor Reese. The professor then asked him, \"what is the peak elevation of the land?\" John did not know the answer! He could write a program to scan through the millions of data points he collected, but he knew that, since you have taken CS1010, you can do a better job. So, John asked for your help. You first clarify the problem with John: \"What is a peak?\" To which John explained that a peak is a location that is strictly higher than the surrounding locations. You then asked: \"Is it guaranteed that there is exactly one peak?\" John then explained the pattern in the data: the elevation always either remains the same or increases as he walks. After he passed the peak, the elevation always either remains the same, or decreases. But he cannot remember if he ever encountered a peak -- it might be possible that the elevations data is always non-decreasing, or non-increasing, or there is a flat plateau where there are multiple highest locations with the same elevation. So, a peak might not exist. But if there is a peak, it is guaranteed that there is exactly one peak. \"Please, can you help me solve it in O(log n) O(log n) time?\" John pleaded. \"Piece of cake!\" You said. Write a program peak that reads from the standard input the following: An integer n n ( n \\ge 3 n \\ge 3 ), followed by n n integers, each representing the elevation of a location surveyed by John Then, prints, to the standard output, the index of the location of the peak if it exists, or no peak if a peak does not exist. The first elevation has an index of 0. An O(n) O(n) solution is trivial. You will get 0 marks if your solution simply scans through the array linearly looking for an elevation that is the peak. That is what John would do anyway! To get full marks for correctness and efficiency for this solution, your code should run in O(log n) O(log n) time when the input elevations are all distinct. Your code is allowed to take longer than O(log n) O(log n) if there are equal elevations in the input data, with the extreme case of O(n) O(n) when all elevation values are the same (the land is completely flat).","title":"Question 1: Peak (10 marks)"},{"location":"as07.html#sample-run","text":"ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.1.in 5 1 3 5 4 2 ooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.1.in 2 ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.2.in 3 1 2 3 ooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.2.in no peak ooiwt@pe119:~/as07-weitsang$ cat inputs/peak.3.in 4 -1 2 2 -1 ooiwt@pe119:~/as07-weitsang$ ./peak < inputs/peak.3.in no peak","title":"Sample Run"},{"location":"as07.html#question-2-scripts-10-marks","text":"Professor Reese is teaching a huge class at the university. He finished grading a test and he asked John to help him enter the grades into IVLE grade book, in increasing order of the student id. John asked the professor, \"Are the scripts sorted?\", to which the professor answered, \"Almost! The top portion of the pile is sorted in increasing order. The rest, in decreasing order.\" The professor then left after saying \"Hasta la vista, baby,\" leaving John to wonder how to deal with the test scripts. John needed to sort the scripts in increasing order of the student id. So he messaged you to help him figure out an efficient algorithm to do this. \"No problemo!\", you said, \"Can be done in O(n) O(n) !\" You said. So you went ahead and wrote out the following program to show John how he can solve his problem in O(n) O(n) time. Write a program scripts that reads, from the standard input, the following: An integer n n ( n \\ge 1 n \\ge 1 ), followed by n n integers, each representing the student ids. The student ids are unique, i.e., there is no duplicate in the inputs. The student ids from the inputs are arranged in such a way that, the first k k are in increasing order, the remaining n - k n - k are in decreasing order. k k is not given in the input, and 0 \\le k \\le n 0 \\le k \\le n . Then, prints, to the standard output, the student ids in increasing order. An O(n^2) O(n^2) or O(n log n) O(n log n) solution is trivial. You will get 0 marks for correctness and efficiency if your solution simply uses one of the existing sorting algorithms to sort the scripts. Note also that you cannot use counting sort here since a student id can be represented with an arbitrarily large integer (but still fit in a long ). Hint: Allocate an output array and populate it with integers taken either from the front or from the back of the input array depending on which one is larger.","title":"Question 2: Scripts (10 marks)"},{"location":"as07.html#sample-run_1","text":"ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.1.in 5 1 3 5 4 2 ooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in 1 2 3 4 5 ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.2.in 3 1 20 300 ooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.2.in 1 20 300 ooiwt@pe119:~/as07-weitsang$ cat inputs/scripts.3.in 1 -100 ooiwt@pe119:~/as07-weitsang$ ./scripts < inputs/scripts.3.in -100","title":"Sample Run"},{"location":"as07.html#question-3-inversion-20-marks","text":"Professor Reese called John in the evening. \"Mr. Connor, I told you that the pile of scripts is almost sorted. But I do not know what it means by almost actually. Can you help me figured out how to quantify that?\" John is clueless as well. So he called you. \"Ah, I learned this in CS1010 Assignment 3,\" you boasted, \"we can count the number of inversions.\" You then go on to explain that an inversion is a pair of scripts that are out of order. A perfectly sorted pile of scripts would have zero inversion, and an inversely sorted pile of scripts would have n \\times (n-1)/2 n \\times (n-1)/2 inversions. \"Let me help you to do this, in O(n) O(n) time!\" Write a program inversion that reads, from the standard input, the following: An integer n n ( n \\ge 1 n \\ge 1 ), followed by n n integers, each representing the student ids. The student ids are unique, i.e., there is no duplicate in the inputs. The student ids from the inputs are arranged in such a way that, the first k k are in increasing order, the remaining n - k n - k are in decreasing order. k k is not given in the input, and 0 \\le k \\le n 0 \\le k \\le n . You program should then prints, to the standard output, the number of inversions in the input. You have already solved this problem in Assignment 3 in O(n^2) O(n^2) time, so, an O(n^2) O(n^2) solution would receive 0 marks. An O(n log n) O(n log n) solution will get 10 marks for correctness and efficiency at most (Hint for O(n log n) O(n log n) solution: binary search). To get full marks for correctness and efficiency, you need to produce an O(n) O(n) solution (Hint for O(n) O(n) : sort).","title":"Question 3: Inversion (20 marks)"},{"location":"as07.html#sample-run_2","text":"ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.1.in 5 1 3 5 4 2 ooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in 4 ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.2.in 3 1 20 300 ooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.2.in 0 ooiwt@pe119:~/as07-weitsang$ cat inputs/inversion.3.in 1 -100 ooiwt@pe119:~/as07-weitsang$ ./inversion < inputs/inversion.3.in 0 Bug in Sample Output If you retrieve the assignment before 8am Saturday morning, your sample output for inversion.1.out says 5 , but it should be 4 . The inversions are 5 4 , 3 2 , 5 2 , and 4 2 .","title":"Sample Run"},{"location":"as08.html","text":"Assignment 8: Maze, Fill Deadline 9 November 2018 (Friday), 23:59 pm Prerequisites You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. {++Be able to design and implement recursive search algorithms with correct pruning to prevent repetitive or redunant work. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work. Setup Accept the assignment Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as08 You should see the folder as08-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the C files to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make A minimal set of test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You should add more test cases or edit the given ones to extensively test your programs. Submission When you are ready, run the following command to submit: ~cs1010/submit-as08 The C files given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Fox Mulder Grading This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are five marking criteria: design, efficiency, correctness, documentation, and style. Design: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem. You should avoid repetitive code that can be factored out as a function. Writing everything in a single long function main or cutting-and-pasting code would likely cause you to lose marks for this criteria. Efficiency: See the question for the breakdown and marking criteria for efficiency. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Documentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly. Please refer to the documentation and follow the recommended format. We have added the compilation flag -Wdocumentation to help you identify documentation errors. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Question 1: Maze (15 marks) Agent Scully woke up and found herself in the dark. She figured out that she is in a maze. She has to find her way out, if there is one! The maze can be simplified as a m \\times n m \\times n cells. Each cell can be of the following: '#' denotes a segment of a wall. Noone can pass through the walls. '.' denotes an empty space '@' denotes where Scully is at currently. It is also an empty space Anytime Scully reaches a border cell (a cell in either the top-most or bottom-most row or left-most or right-most column), she escapes the maze and can go save her partner Agent Mulder. She can only move from one empty space to another adjacent cell in one step. Two cells are adjacent if they share a common edge. Scully took CS1010, and she got a concrete plan to seek a way out by trial and error. She follows strictly the following strategy to find a way through the maze starting from her initial position. At each time step, She looks for an empty adjacent cell that has never been visited yet, in the sequence of up/right/down/left to the current cell she is at. If there is an empty adjacent cell, she moves to that cell. The cell she moves to is now visited. If no empty, unvisited, adjacent cell exists, she backtracks on the path that she comes from, moving one step back, and repeat 1 again. In this way, Scully will explore the maze in a systematic manner, with no repetitive visit of any cell more than once except when she backtracks. She will stop when successfully escaped the maze, or finds that there is no way out after backtracking all the way back to the original position. She is completely trapped within the maze and now must wait for Agent Mulder to come and free her. Write a program maze.c , that reads from standard input. First, read two positive integers m m and n n , followed by m m lines of n n characters in each line that represents the maze setup. One and only one @ will be present in the maze setup. The program then prints, to standard output, an animation of k k iterations. The output should only contain m m rows with n n characters in each row, with an additional row at last. Similarly, you must use # to represent a wall, a . to represents an empty space, and @ to represent where Scully is at. After printing the maze, your program prints the number of steps that Scully has made. You should use recursion to explore the maze and look for a way out. Here is an example. The following is the starting position of Scully and the maze. ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #@#.#..#..# #...#.#.#.. ########### 0 Scully firstly moves five steps up: ########### #@#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 5 At this point, Scully is stuck since there is no more adjacent empty cell that has not been visited. Scully then backtracks: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #@#.#..#..# #...#.#.#.. ########### 10 Scully then moves down: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #@..#.#.#.. ########### 11 Then right: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #..@#.#.#.. ########### 13 Then up: ########### #.#.....#.# #.#####.#.# #.#@..#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 17 Then right (two steps) and then down (two steps) and then right (two step): ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#..@..# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 22 Then Scully moves up and left, and she is stuck again. ########### #.#@....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 29 At this point she backtracks: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#..@..# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 36 Moves right, and up, and stuck again! ########### #.#.....#@# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 41 She backtracks again, ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#...@.# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 45 This time she found her way out! ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.@ ########### 50 It took her a total of 50 steps to exit the maze. Animation on Screen We have provided a few lines of code in the skeleton file. You should insert this at appropriate places: char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H', '\\0'}; : cs1010_print_string(clear_screen); usleep(250*1000); // you can change the interval here without affecting the correctness of the program. Line 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal. Line 5 calls the system function usleep that takes in the number of microseconds. Calling usleep causes the program to pause for that amount of time. Sleeping time in input file is set to to 250ms (250000) and you can freely change the value if you wish. During grading, sleeping time in all inputs are 0. Hint: You need to strictly follow the described strategy and sequence of exploration. Do not forget to print the initial matrix, and final matrix Your solution must take no more than O(mn) O(mn) time. The grading criteria for this question is: Marks Design 2 Correctness 5 Efficiency 8 Sample Run maze.1.in maze.2.in We also included a larger maze maze.3.in for you to play with but there is no corresponding output file for this. This maze would take Scully 900 steps to find out that she is stuck in the maze! Question 2: Fill (15 marks) Scully is attending a drawing class today. She has already completed her work, but the teacher is not satisfied with her choice of colors and wants her to re-color some parts. She asks you, a programming genius, to help. Scully's drawing can be simplified as a 2D array of size m \\times n m \\times n , with colors '0' to '9'. The drawing consists of several objects. Each object can be viewed as connected areas of cells of the same color. Two cells are connected if they share a common edge, i.e. a cell will have at most 4 connected cells. Write a program, fill.c , to help Scully re-color her drawing according to her teacher's requirement. It reads from standard input two positive integers m m and n n in the first line, followed by m m lines of strings. Each string is of length n n , consisting of only characters '0' to '9'. The next line is a positive integer q q , which is the number of color changes the teacher requires. Following this, there are q q lines with three integers on each line: x_i x_i , y_i y_i , and c_i c_i . It means to color the object containing pixel ( x_i x_i , y_i y_i ) to the color c_i c_i . We denote the top left pixel to be (0,0) (0,0) and the indices increases towards the right and down. The program shall prints to standard output, the drawing after re-coloring the objects according to the teacher's commands according to the order of the input. Note that one object can be re-colored multiple times. You should use recursion to complete the coloring process. Your solution must take no more than O(mnq) O(mnq) time. The grading criteria for this question is: Marks Design 2 Correctness 5 Efficiency 8 Sample run ooiwt@pe119:~/as08-skeleton$ cat inputs/fill.1.in 5 5 00110 00110 00000 11040 01100 2 0 3 2 4 1 3 ooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.1.in 00220 00220 00000 33040 03300 ooiwt@pe119:~/as08-skeleton$ cat inputs/fill.2.in 5 5 11111 11111 11111 11111 11111 2 0 3 2 4 1 3 ooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.2.in 33333 33333 33333 33333 33333","title":"8. Maze, Fill"},{"location":"as08.html#assignment-8-maze-fill","text":"","title":"Assignment 8: Maze, Fill"},{"location":"as08.html#deadline","text":"9 November 2018 (Friday), 23:59 pm","title":"Deadline"},{"location":"as08.html#prerequisites","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 1 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisites"},{"location":"as08.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, and dynamic memory allocation. {++Be able to design and implement recursive search algorithms with correct pruning to prevent repetitive or redunant work. Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.","title":"Learning Outcomes"},{"location":"as08.html#setup","text":"Accept the assignment Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as08 You should see the folder as08-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as08.html#solving-the-assignments","text":"Edit the C files to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile and run tests with the sample inputs and outputs: make A minimal set of test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You should add more test cases or edit the given ones to extensively test your programs.","title":"Solving The Assignments"},{"location":"as08.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as08 The C files given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as08.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Fox Mulder","title":"Identifying Yourself"},{"location":"as08.html#grading","text":"This assignment contributes towards 3% of your final grade. The total mark for this assignment is 30 marks. There are five marking criteria: design, efficiency, correctness, documentation, and style. Design: 2 marks. You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem. You should avoid repetitive code that can be factored out as a function. Writing everything in a single long function main or cutting-and-pasting code would likely cause you to lose marks for this criteria. Efficiency: See the question for the breakdown and marking criteria for efficiency. Correctness: The rest of the marks are allocated to correctness. Note that passing the tests does not guarantee that your code is correct. Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style: Marks are no longer allocated for style, but we will deduct up to 2 marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Documentation: Marks are no longer allocated for documentation, but we will deduct up to 2 marks if you do not document the functions in your code properly. Please refer to the documentation and follow the recommended format. We have added the compilation flag -Wdocumentation to help you identify documentation errors. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as08.html#question-1-maze-15-marks","text":"Agent Scully woke up and found herself in the dark. She figured out that she is in a maze. She has to find her way out, if there is one! The maze can be simplified as a m \\times n m \\times n cells. Each cell can be of the following: '#' denotes a segment of a wall. Noone can pass through the walls. '.' denotes an empty space '@' denotes where Scully is at currently. It is also an empty space Anytime Scully reaches a border cell (a cell in either the top-most or bottom-most row or left-most or right-most column), she escapes the maze and can go save her partner Agent Mulder. She can only move from one empty space to another adjacent cell in one step. Two cells are adjacent if they share a common edge. Scully took CS1010, and she got a concrete plan to seek a way out by trial and error. She follows strictly the following strategy to find a way through the maze starting from her initial position. At each time step, She looks for an empty adjacent cell that has never been visited yet, in the sequence of up/right/down/left to the current cell she is at. If there is an empty adjacent cell, she moves to that cell. The cell she moves to is now visited. If no empty, unvisited, adjacent cell exists, she backtracks on the path that she comes from, moving one step back, and repeat 1 again. In this way, Scully will explore the maze in a systematic manner, with no repetitive visit of any cell more than once except when she backtracks. She will stop when successfully escaped the maze, or finds that there is no way out after backtracking all the way back to the original position. She is completely trapped within the maze and now must wait for Agent Mulder to come and free her. Write a program maze.c , that reads from standard input. First, read two positive integers m m and n n , followed by m m lines of n n characters in each line that represents the maze setup. One and only one @ will be present in the maze setup. The program then prints, to standard output, an animation of k k iterations. The output should only contain m m rows with n n characters in each row, with an additional row at last. Similarly, you must use # to represent a wall, a . to represents an empty space, and @ to represent where Scully is at. After printing the maze, your program prints the number of steps that Scully has made. You should use recursion to explore the maze and look for a way out. Here is an example. The following is the starting position of Scully and the maze. ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #@#.#..#..# #...#.#.#.. ########### 0 Scully firstly moves five steps up: ########### #@#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 5 At this point, Scully is stuck since there is no more adjacent empty cell that has not been visited. Scully then backtracks: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #@#.#..#..# #...#.#.#.. ########### 10 Scully then moves down: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #@..#.#.#.. ########### 11 Then right: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #..@#.#.#.. ########### 13 Then up: ########### #.#.....#.# #.#####.#.# #.#@..#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 17 Then right (two steps) and then down (two steps) and then right (two step): ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#..@..# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 22 Then Scully moves up and left, and she is stuck again. ########### #.#@....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 29 At this point she backtracks: ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#..@..# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 36 Moves right, and up, and stuck again! ########### #.#.....#@# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 41 She backtracks again, ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#...@.# #.#.##.#.## #.#.#..#..# #...#.#.#.. ########### 45 This time she found her way out! ########### #.#.....#.# #.#####.#.# #.#...#.#.# #.#.#.....# #.#.##.#.## #.#.#..#..# #...#.#.#.@ ########### 50 It took her a total of 50 steps to exit the maze.","title":"Question 1: Maze (15 marks)"},{"location":"as08.html#animation-on-screen","text":"We have provided a few lines of code in the skeleton file. You should insert this at appropriate places: char clear_screen[] = { 27, '[', '2', 'J',27, '[', ';', 'H', '\\0'}; : cs1010_print_string(clear_screen); usleep(250*1000); // you can change the interval here without affecting the correctness of the program. Line 1 in the code above defines a special string that, when printed, will clear the screen and place the cursor on the top left corner of the terminal. Line 5 calls the system function usleep that takes in the number of microseconds. Calling usleep causes the program to pause for that amount of time. Sleeping time in input file is set to to 250ms (250000) and you can freely change the value if you wish. During grading, sleeping time in all inputs are 0. Hint: You need to strictly follow the described strategy and sequence of exploration. Do not forget to print the initial matrix, and final matrix Your solution must take no more than O(mn) O(mn) time. The grading criteria for this question is: Marks Design 2 Correctness 5 Efficiency 8","title":"Animation on Screen"},{"location":"as08.html#sample-run","text":"maze.1.in maze.2.in We also included a larger maze maze.3.in for you to play with but there is no corresponding output file for this. This maze would take Scully 900 steps to find out that she is stuck in the maze!","title":"Sample Run"},{"location":"as08.html#question-2-fill-15-marks","text":"Scully is attending a drawing class today. She has already completed her work, but the teacher is not satisfied with her choice of colors and wants her to re-color some parts. She asks you, a programming genius, to help. Scully's drawing can be simplified as a 2D array of size m \\times n m \\times n , with colors '0' to '9'. The drawing consists of several objects. Each object can be viewed as connected areas of cells of the same color. Two cells are connected if they share a common edge, i.e. a cell will have at most 4 connected cells. Write a program, fill.c , to help Scully re-color her drawing according to her teacher's requirement. It reads from standard input two positive integers m m and n n in the first line, followed by m m lines of strings. Each string is of length n n , consisting of only characters '0' to '9'. The next line is a positive integer q q , which is the number of color changes the teacher requires. Following this, there are q q lines with three integers on each line: x_i x_i , y_i y_i , and c_i c_i . It means to color the object containing pixel ( x_i x_i , y_i y_i ) to the color c_i c_i . We denote the top left pixel to be (0,0) (0,0) and the indices increases towards the right and down. The program shall prints to standard output, the drawing after re-coloring the objects according to the teacher's commands according to the order of the input. Note that one object can be re-colored multiple times. You should use recursion to complete the coloring process. Your solution must take no more than O(mnq) O(mnq) time. The grading criteria for this question is: Marks Design 2 Correctness 5 Efficiency 8","title":"Question 2: Fill (15 marks)"},{"location":"as08.html#sample-run_1","text":"ooiwt@pe119:~/as08-skeleton$ cat inputs/fill.1.in 5 5 00110 00110 00000 11040 01100 2 0 3 2 4 1 3 ooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.1.in 00220 00220 00000 33040 03300 ooiwt@pe119:~/as08-skeleton$ cat inputs/fill.2.in 5 5 11111 11111 11111 11111 11111 2 0 3 2 4 1 3 ooiwt@pe119:~/as08-skeleton$ ./fill < inputs/fill.2.in 33333 33333 33333 33333 33333","title":"Sample run"},{"location":"as09.html","text":"Assignment 9: Digits Deadline 16 November 2018 (Friday), 23:59 pm Prerequisites You survived CS1010 until Week 13! Learning Outcomes Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, dynamic memory allocation, and struct . Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work. Setup Accept the assignment Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as09 You should see the folder as09-<github id> in your home directory with the assignment skeleton inside. Solving The Assignments Edit the C files to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile, run: make Submission When you are ready, run the following command to submit: ~cs1010/submit-as09 The C file given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Ellen Ripley (Group 10) Grading This assignment contributes towards 4% of your final grade. The total mark for this assignment is 40 marks. There are five marking criteria: design, efficiency, correctness, documentation, and style. Design (8 marks): You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem. You should avoid repetitive code that can be factored out as a function. Writing everything in a single long function main or cutting-and-pasting code would likely cause you to lose marks for this criteria. Efficiency (8 marks): Your code should run within the efficiency bound (given in big-O notation) and avoid redundant work or repetitive work. Correctness (8 marks): Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, struct , pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style (8 marks): 8 marks are given by default but we may deduct marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Documentation (8 marks): 8 marks are given by default, but we will deduct marks if you do not document the functions in your code properly. Please refer to the documentation and follow the recommended format. We have added the compilation flag -Wdocumentation to help you identify documentation errors. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. Note that the default marks on documentation and style are given on the condition that you have made a good attempt at solving the problem and your solution is reasonably close to correct. This is to prevent students from submitting an arbitrary program to claim 16 marks :) We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments). Digits (40 Marks) We started CS1010 with an assignment question on digits, so it is fitting that we end with one. In this assignment, your goal is to write a program that can recognize handwritten digits. This is a classic problem in pattern recognition and machine learning. The state of the art techniques can now achieve a recognition rate of over 99%. We, however, will implement a simple algorithm called k k -nearest neighbor algorithm, which has lower accuracy but is simple enough to be a freshmen intro to programming assignment! Here is how it works. Representation of a handwritten digit A handwritten digit is an image, represented as a 28x28 array of characters, consisting of . and # . An example is: ............................ ............................ ............................ ..........#######........... .........########........... ........##########.......... .......####....###.......... .......###....####.......... ..............####.......... .............####........... ............#####........... ............####............ ...........####............. ...........###.............. ..........####.............. .........####............... .........####............... ........####................ ........###................. ........###...........####.. ........###################. ........###################. .........###########........ ............................ ............................ ............................ ............................ ............................ The image above contains the digit 2. Training Data Our algorithm recognizes the patterns in a given image by comparing it against existing images where the digits contained within are known. These existing images are known as the training samples . They consist of a list of handwritten digits, together with the ground truth label, i.e., the information of which digit is contained in each image. Usually, the more training data we have, the more accurate our recognition program will be. For this assignment, we will use the data provided by the MNIST Handwritten Digit Database . The original data has been post-procesed into CSV file by Joseph Redmon, then post-processed again by yours truly into the format above. The dataset from above contains 60,000 training samples. I have created two smaller subsets for you to test your code. The first subset contains 10 samples for each digit -- this is given in the file train100.in . The second subset contains 6 samples for digits 0 and 1 -- this is given in the file train6.in . The full training set from MNIST is too big to be included on GitHub. You can read it from ~cs1010/as09/train60000.in if you want to play with it. Testing Samples The testing samples refer to the handwritten digits that we wish to recognize. Each of these handwritten digits is also labeled with its ground truth. We will use these ground truth to compare against the output from our algorithm so that we can check the accuracy of our algorithm. We provide two sets of testing samples. The first contains three testing samples per digit. The second contains only a single digit corresponding to the example below. The full training dataset from MNIST contains 10000 digits. It takes a long time to test every handwritten digit in this file, so you should do this only after you have made sure that your code is fast and is correct. Again, the file is too big to be posted on GitHub. You can read it directly from ~cs1010/as09/test10000.in . The Algorithm Let's define the distance between the two handwritten digits d(x_1, x_2) d(x_1, x_2) as the number of pixels that are different between them, i.e., how many pixels are # in one image but is . in the image. Given a test sample, q q , we find the distance between q q and all the available training samples and find the k k training samples with the smallest distance (i.e., k k nearest neighbors). k k is usually small -- we use k = 5 k = 5 in this assignment. The intuition is that q q must be \"close\" to the training data that has the same labels (i.e., the same digits). So we look at the these k k nearest neighbors and find the most common digit d d among them. We then recognize q q as containing the digit d d . If there are more than one most common digits or more than k nearest neighbors , then we break ties by returning the smaller digit (we should do something smarter than this, by return the closer digit, but let's do this for simplicity). Efficiency Suppose we have n n training samples, recognizing a digit should take no more than O(kn) O(kn) time (or O(n) O(n) since k k is a constant). There is also an opportunity to stop early the calculation of the distance between two handwritten digits if the distance is too large, pruning away redundant work. Example Consider the following simple example with six training samples and a test sample. 6 0 ............................ ............................ ............................ ............................ ...............#####........ ...............#####........ .............########....... ............##########...... ...........###########...... ..........########.###...... ..........####.##...###..... .........#####......###..... ........####........###..... .......####.........###..... .......###..........###..... ......####..........###..... ......###..........###...... ......###.........####...... ......###........###........ ......###......####......... ......####..#######......... ......###########........... .......########............. ........#####............... ............................ ............................ ............................ ............................ 0 ............................ ............................ ............................ ............................ .................####....... ................######...... ...............#######...... .............#########...... ...........###########...... ..........############...... .........#############...... ........#####.####.###...... .......#####..###...##...... .......####.........##...... .......##...........##...... ......###...........##...... .....####..........###...... .....####..........###...... .....####.........###....... .....####.......####........ .....##############......... ......############.......... ........########............ .........######............. ............................ ............................ ............................ ............................ 0 ............................ ............................ ............................ ............................ ............................ ..............######........ ..............########...... .............#########...... .............#########...... ............##########...... ..........######..####...... ..........#####...####...... ..........#####...####...... ..........#####..#####...... ..........####...#####...... .........####....####....... ........#####...#####....... ........#####...####........ ........#####..#####........ ........####..#####......... ........##########.......... ........#########........... ........#########........... .........######............. ..........#####............. ............................ ............................ ............................ 1 ............................ ............................ ............................ ............................ ............................ ..................####...... .................#####...... .................#####...... ................####........ ...............#####........ ...............####......... ...............####......... ..............####.......... .............####........... ............####............ ............####............ ...........####............. ...........####............. ..........####.............. ..........####.............. .........####............... .........####............... ........####................ ........####................ .........###................ ............................ ............................ ............................ 1 ............................ ............................ ............................ ............................ ............###............. ............####............ ............####............ ............####............ ............####............ ............####............ ............#####........... .............####........... .............####........... .............####........... .............####........... .............####........... .............####........... .............####........... .............#####.......... .............#####.......... ..............####.......... ..............####.......... ..............####.......... ...............###.......... ............................ ............................ ............................ ............................ 1 ............................ ............................ ............................ ............................ ............................ .............##............. .............##............. .............##............. .............##............. .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ ..............###........... ..............##............ ..............##............ ..............###........... ..............##............ ..............##............ ............................ ............................ ............................ The test sample is 1 0 ............................ ............................ ............................ ............................ ............................ ..............#####......... .............#######........ ...........##########....... ..........####.##.####...... .........####......####..... .........###........###..... ........####.........##..... ........###..........##..... .......###...........##..... .......###...........##..... .......###...........##..... ......####...........##..... ......####..........###..... .......###..........###..... .......###.........###...... ........###.......###....... ........####....#####....... .........##########......... ..........#########......... ............#####........... ............................ ............................ ............................ The distances between the test sample and each of the training sampes are 101, 120, 162, 174, 173, 162. The k k nearest neighbors belong to digits 0, 0, 0, 1, and 1. The most common digit among these neighbors is 0, so we conclude (correctly) that the test sample is digit 0. Using struct One of the objectives of this assignment is to see if you know how to use struct (refer to Unit 28 . Appropriate use of struct is critical for the design and correctness marks for this assignment. Input/Output Write a program digits that reads, from the standard input, the following: A positive integer n n , corresponding to the number of training samples, then repeatedly read n n handwritten digits, containing: a label corresponding to the digit in the next image (a number between 0 - 9) 28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit followed by another positive integer m m , corresponding to the number testing samples, then repeatedly read m m handwritten digits, containing: a label corresponding to the digit in the next image (a number between 0 - 9) 28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit Then prints, to the standard output, the following: For each testing sample, - print the digit it is labeled as, followed by a space, followed by the digit it is recognized as Finally, print a double value that corresponds to the accuracy, i.e, the percentage of training testing samples correctly recognized. We separated the training samples and testing samples into two files, so the usual way of redirecting a file into your program does not work anymore (since you need two files). The way to run your program is to do the following: cat <training samples> <testing samples> | ./digits We use cat which concatenate two files into one to pass both the training samples and testing samples into the program using the pipe | . If this sounds familiar, you have seen pipe before in Exercise 3 . The name convention for the output files is different for this assignment. The name is formatted as X-Y.out where X refers to the training samples trainX.in and Y refers to the testing samples testY.in . Sample Runs ooiwt@pe121:~/cs1010/as09$ cat inputs/train6.in inputs/test1.in | ./digits 0 0 100.0000 ooiwt@pe121:~/cs1010/as09$ cat inputs/train100.in inputs/test30.in | ./digits 0 0 0 0 0 6 1 1 1 1 1 1 2 2 2 5 2 2 3 3 3 3 3 3 4 9 4 4 4 9 5 5 5 3 5 3 6 2 6 6 6 6 7 7 7 7 7 7 8 8 8 1 8 8 9 9 9 9 9 9 73.3333 When you use the file ~cs1010/as09/train60000.in as the training samples, you should receive 100% accuracy with test30.in and about 96.5\\% accuracy with ~cs1010/as09/test10000.in","title":"9. Digits"},{"location":"as09.html#assignment-9-digits","text":"","title":"Assignment 9: Digits"},{"location":"as09.html#deadline","text":"16 November 2018 (Friday), 23:59 pm","title":"Deadline"},{"location":"as09.html#prerequisites","text":"You survived CS1010 until Week 13!","title":"Prerequisites"},{"location":"as09.html#learning-outcomes","text":"Be comfortable writing C programs that involve arithmetic operations, long , double , bool , and char types, conditional if / else statements, loops with while / for / do-while statements, arrays (including 2D arrays), strings, pointers, dynamic memory allocation, and struct . Be comfortable breaking down a problem into smaller subproblems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function be. Be able to analyze the problem and come up with solutions to problems that are efficient, through eliminating redundant and repetitive work.","title":"Learning Outcomes"},{"location":"as09.html#setup","text":"Accept the assignment Login to one of the hosts of CS1010 programming environment Run: ~cs1010/get-as09 You should see the folder as09-<github id> in your home directory with the assignment skeleton inside.","title":"Setup"},{"location":"as09.html#solving-the-assignments","text":"Edit the C files to solve the corresponding question as described below. You should break down the problem into smaller subproblems, and write one function for each of the subproblem to solve the problem. To compile, run: make","title":"Solving The Assignments"},{"location":"as09.html#submission","text":"When you are ready, run the following command to submit: ~cs1010/submit-as09 The C file given will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Editing Your Files in Multiple Locations You should edit your code only on the CS1010 PE hosts. If you choose to edit your code in other places, such as directly on Github or in a second location (such as your own laptop), you need to be comfortable with various git command to synchronize your code across the different locations, possibly needing to resolve synchronization conflicts. Only the C files listed above will be submitted. You can create additional C files for testing different solutions, but eventually, you must put your solution into the corresponding C file provided as the skeleton.","title":"Submission"},{"location":"as09.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Ellen Ripley (Group 10)","title":"Identifying Yourself"},{"location":"as09.html#grading","text":"This assignment contributes towards 4% of your final grade. The total mark for this assignment is 40 marks. There are five marking criteria: design, efficiency, correctness, documentation, and style. Design (8 marks): You should break down your program into smaller functions, each one performs a single coherent task or solves a well-defined subproblem. You should avoid repetitive code that can be factored out as a function. Writing everything in a single long function main or cutting-and-pasting code would likely cause you to lose marks for this criteria. Efficiency (8 marks): Your code should run within the efficiency bound (given in big-O notation) and avoid redundant work or repetitive work. Correctness (8 marks): Correctness here is defined in the broad sense of using the various programming constructs in C (type, function, variable, loops, arrays, struct , pointers, conditionals, arithmetic expressions, logical expressions) properly , not just producing the correct output and bug-free. Style (8 marks): 8 marks are given by default but we may deduct marks if you have a serious violation of the style guideline. Please refer to the CS1010 C Style Guide and follow the recommended guideline. Documentation (8 marks): 8 marks are given by default, but we will deduct marks if you do not document the functions in your code properly. Please refer to the documentation and follow the recommended format. We have added the compilation flag -Wdocumentation to help you identify documentation errors. You need to explain the purpose of every file, function, and parameter. Logic in your code that is not obvious should be explained as well. Note that the default marks on documentation and style are given on the condition that you have made a good attempt at solving the problem and your solution is reasonably close to correct. This is to prevent students from submitting an arbitrary program to claim 16 marks :) We reserve the right to penalize students for using banned C syntax in the assignments. In addition, each grader at his or her own discretion can penalize students for repeating mistakes / bad practices from the student's past assignments (even if it was just a warning with no marks deducted in the earlier assignments).","title":"Grading"},{"location":"as09.html#digits-40-marks","text":"We started CS1010 with an assignment question on digits, so it is fitting that we end with one. In this assignment, your goal is to write a program that can recognize handwritten digits. This is a classic problem in pattern recognition and machine learning. The state of the art techniques can now achieve a recognition rate of over 99%. We, however, will implement a simple algorithm called k k -nearest neighbor algorithm, which has lower accuracy but is simple enough to be a freshmen intro to programming assignment! Here is how it works.","title":"Digits (40 Marks)"},{"location":"as09.html#representation-of-a-handwritten-digit","text":"A handwritten digit is an image, represented as a 28x28 array of characters, consisting of . and # . An example is: ............................ ............................ ............................ ..........#######........... .........########........... ........##########.......... .......####....###.......... .......###....####.......... ..............####.......... .............####........... ............#####........... ............####............ ...........####............. ...........###.............. ..........####.............. .........####............... .........####............... ........####................ ........###................. ........###...........####.. ........###################. ........###################. .........###########........ ............................ ............................ ............................ ............................ ............................ The image above contains the digit 2.","title":"Representation of a handwritten digit"},{"location":"as09.html#training-data","text":"Our algorithm recognizes the patterns in a given image by comparing it against existing images where the digits contained within are known. These existing images are known as the training samples . They consist of a list of handwritten digits, together with the ground truth label, i.e., the information of which digit is contained in each image. Usually, the more training data we have, the more accurate our recognition program will be. For this assignment, we will use the data provided by the MNIST Handwritten Digit Database . The original data has been post-procesed into CSV file by Joseph Redmon, then post-processed again by yours truly into the format above. The dataset from above contains 60,000 training samples. I have created two smaller subsets for you to test your code. The first subset contains 10 samples for each digit -- this is given in the file train100.in . The second subset contains 6 samples for digits 0 and 1 -- this is given in the file train6.in . The full training set from MNIST is too big to be included on GitHub. You can read it from ~cs1010/as09/train60000.in if you want to play with it.","title":"Training Data"},{"location":"as09.html#testing-samples","text":"The testing samples refer to the handwritten digits that we wish to recognize. Each of these handwritten digits is also labeled with its ground truth. We will use these ground truth to compare against the output from our algorithm so that we can check the accuracy of our algorithm. We provide two sets of testing samples. The first contains three testing samples per digit. The second contains only a single digit corresponding to the example below. The full training dataset from MNIST contains 10000 digits. It takes a long time to test every handwritten digit in this file, so you should do this only after you have made sure that your code is fast and is correct. Again, the file is too big to be posted on GitHub. You can read it directly from ~cs1010/as09/test10000.in .","title":"Testing Samples"},{"location":"as09.html#the-algorithm","text":"Let's define the distance between the two handwritten digits d(x_1, x_2) d(x_1, x_2) as the number of pixels that are different between them, i.e., how many pixels are # in one image but is . in the image. Given a test sample, q q , we find the distance between q q and all the available training samples and find the k k training samples with the smallest distance (i.e., k k nearest neighbors). k k is usually small -- we use k = 5 k = 5 in this assignment. The intuition is that q q must be \"close\" to the training data that has the same labels (i.e., the same digits). So we look at the these k k nearest neighbors and find the most common digit d d among them. We then recognize q q as containing the digit d d . If there are more than one most common digits or more than k nearest neighbors , then we break ties by returning the smaller digit (we should do something smarter than this, by return the closer digit, but let's do this for simplicity).","title":"The Algorithm"},{"location":"as09.html#efficiency","text":"Suppose we have n n training samples, recognizing a digit should take no more than O(kn) O(kn) time (or O(n) O(n) since k k is a constant). There is also an opportunity to stop early the calculation of the distance between two handwritten digits if the distance is too large, pruning away redundant work.","title":"Efficiency"},{"location":"as09.html#example","text":"Consider the following simple example with six training samples and a test sample. 6 0 ............................ ............................ ............................ ............................ ...............#####........ ...............#####........ .............########....... ............##########...... ...........###########...... ..........########.###...... ..........####.##...###..... .........#####......###..... ........####........###..... .......####.........###..... .......###..........###..... ......####..........###..... ......###..........###...... ......###.........####...... ......###........###........ ......###......####......... ......####..#######......... ......###########........... .......########............. ........#####............... ............................ ............................ ............................ ............................ 0 ............................ ............................ ............................ ............................ .................####....... ................######...... ...............#######...... .............#########...... ...........###########...... ..........############...... .........#############...... ........#####.####.###...... .......#####..###...##...... .......####.........##...... .......##...........##...... ......###...........##...... .....####..........###...... .....####..........###...... .....####.........###....... .....####.......####........ .....##############......... ......############.......... ........########............ .........######............. ............................ ............................ ............................ ............................ 0 ............................ ............................ ............................ ............................ ............................ ..............######........ ..............########...... .............#########...... .............#########...... ............##########...... ..........######..####...... ..........#####...####...... ..........#####...####...... ..........#####..#####...... ..........####...#####...... .........####....####....... ........#####...#####....... ........#####...####........ ........#####..#####........ ........####..#####......... ........##########.......... ........#########........... ........#########........... .........######............. ..........#####............. ............................ ............................ ............................ 1 ............................ ............................ ............................ ............................ ............................ ..................####...... .................#####...... .................#####...... ................####........ ...............#####........ ...............####......... ...............####......... ..............####.......... .............####........... ............####............ ............####............ ...........####............. ...........####............. ..........####.............. ..........####.............. .........####............... .........####............... ........####................ ........####................ .........###................ ............................ ............................ ............................ 1 ............................ ............................ ............................ ............................ ............###............. ............####............ ............####............ ............####............ ............####............ ............####............ ............#####........... .............####........... .............####........... .............####........... .............####........... .............####........... .............####........... .............####........... .............#####.......... .............#####.......... ..............####.......... ..............####.......... ..............####.......... ...............###.......... ............................ ............................ ............................ ............................ 1 ............................ ............................ ............................ ............................ ............................ .............##............. .............##............. .............##............. .............##............. .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ .............###............ ..............###........... ..............##............ ..............##............ ..............###........... ..............##............ ..............##............ ............................ ............................ ............................ The test sample is 1 0 ............................ ............................ ............................ ............................ ............................ ..............#####......... .............#######........ ...........##########....... ..........####.##.####...... .........####......####..... .........###........###..... ........####.........##..... ........###..........##..... .......###...........##..... .......###...........##..... .......###...........##..... ......####...........##..... ......####..........###..... .......###..........###..... .......###.........###...... ........###.......###....... ........####....#####....... .........##########......... ..........#########......... ............#####........... ............................ ............................ ............................ The distances between the test sample and each of the training sampes are 101, 120, 162, 174, 173, 162. The k k nearest neighbors belong to digits 0, 0, 0, 1, and 1. The most common digit among these neighbors is 0, so we conclude (correctly) that the test sample is digit 0.","title":"Example"},{"location":"as09.html#using-struct","text":"One of the objectives of this assignment is to see if you know how to use struct (refer to Unit 28 . Appropriate use of struct is critical for the design and correctness marks for this assignment.","title":"Using struct"},{"location":"as09.html#inputoutput","text":"Write a program digits that reads, from the standard input, the following: A positive integer n n , corresponding to the number of training samples, then repeatedly read n n handwritten digits, containing: a label corresponding to the digit in the next image (a number between 0 - 9) 28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit followed by another positive integer m m , corresponding to the number testing samples, then repeatedly read m m handwritten digits, containing: a label corresponding to the digit in the next image (a number between 0 - 9) 28 lines of texts, consisting of '.' and '#' only, representing a handwritten digit Then prints, to the standard output, the following: For each testing sample, - print the digit it is labeled as, followed by a space, followed by the digit it is recognized as Finally, print a double value that corresponds to the accuracy, i.e, the percentage of training testing samples correctly recognized. We separated the training samples and testing samples into two files, so the usual way of redirecting a file into your program does not work anymore (since you need two files). The way to run your program is to do the following: cat <training samples> <testing samples> | ./digits We use cat which concatenate two files into one to pass both the training samples and testing samples into the program using the pipe | . If this sounds familiar, you have seen pipe before in Exercise 3 . The name convention for the output files is different for this assignment. The name is formatted as X-Y.out where X refers to the training samples trainX.in and Y refers to the testing samples testY.in .","title":"Input/Output"},{"location":"as09.html#sample-runs","text":"ooiwt@pe121:~/cs1010/as09$ cat inputs/train6.in inputs/test1.in | ./digits 0 0 100.0000 ooiwt@pe121:~/cs1010/as09$ cat inputs/train100.in inputs/test30.in | ./digits 0 0 0 0 0 6 1 1 1 1 1 1 2 2 2 5 2 2 3 3 3 3 3 3 4 9 4 4 4 9 5 5 5 3 5 3 6 2 6 6 6 6 7 7 7 7 7 7 8 8 8 1 8 8 9 9 9 9 9 9 73.3333 When you use the file ~cs1010/as09/train60000.in as the training samples, you should receive 100% accuracy with test30.in and about 96.5\\% accuracy with ~cs1010/as09/test10000.in","title":"Sample Runs"},{"location":"assignment.html","text":"Guide to Programming Assignments Timeline There will be weekly take-home programming assignments, each consisting of 2 to 4 questions. These programming assignments collectively contribute to 30% of your final grade. The programming assignment is released on the CS1010 website every Friday, with a deadline given. You must submit all questions for each particular programming assignment before the deadline. General Advice You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly. Remember to spend some time thinking about the algorithm for each question. Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your own test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire. Late Submission All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty). Method of Submission Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Gamora (Group 10) Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted. Grading Only the final submission of each exercise will be graded. For each exercise, we will provide you will a limited set of test data. During grading, we may grade your program with additional test data. Each programming assignment will be graded differently. Generally, marks are given for attempt, correctness, design, and style, and documentation. The weight of each one will be adjusted over the semester. A program that cannot compile will receive 0 marks for correctness. Feedback will be provided by the graders on GitHub. Use of Piazza If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site). Disallowed Syntax Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged. We also discourage the use of certain syntax for this module, (e.g., ++ ) you should not use them. The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification. Plagiarism You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See our policies page for details. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others. This guideline is adapted from Aaron Tan's CS1010 guideline.","title":"General Guide"},{"location":"assignment.html#guide-to-programming-assignments","text":"","title":"Guide to Programming Assignments"},{"location":"assignment.html#timeline","text":"There will be weekly take-home programming assignments, each consisting of 2 to 4 questions. These programming assignments collectively contribute to 30% of your final grade. The programming assignment is released on the CS1010 website every Friday, with a deadline given. You must submit all questions for each particular programming assignment before the deadline.","title":"Timeline"},{"location":"assignment.html#general-advice","text":"You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly. Remember to spend some time thinking about the algorithm for each question. Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your own test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.","title":"General Advice"},{"location":"assignment.html#late-submission","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).","title":"Late Submission"},{"location":"assignment.html#method-of-submission","text":"Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Method of Submission"},{"location":"assignment.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Gamora (Group 10) Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Identifying Yourself"},{"location":"assignment.html#grading","text":"Only the final submission of each exercise will be graded. For each exercise, we will provide you will a limited set of test data. During grading, we may grade your program with additional test data. Each programming assignment will be graded differently. Generally, marks are given for attempt, correctness, design, and style, and documentation. The weight of each one will be adjusted over the semester. A program that cannot compile will receive 0 marks for correctness. Feedback will be provided by the graders on GitHub.","title":"Grading"},{"location":"assignment.html#use-of-piazza","text":"If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).","title":"Use of Piazza"},{"location":"assignment.html#disallowed-syntax","text":"Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged. We also discourage the use of certain syntax for this module, (e.g., ++ ) you should not use them. The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification.","title":"Disallowed Syntax"},{"location":"assignment.html#plagiarism","text":"You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See our policies page for details. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others. This guideline is adapted from Aaron Tan's CS1010 guideline.","title":"Plagiarism"},{"location":"c-in-cs1010.html","text":"C in CS1010 C is a simple and flexible language, providing programmers with many different ways to achieve the same thing. Some of these features that C provides, however, could be bug prone. Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students. He feels that some of these features from C are not useful for beginners (or even seasoned programmers). Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon. Some would lead to insecure programs. As such, in CS1010, we ban and discourage the use of certain operators, functions, constructs, and features in C. This article summarizes this list. This is a work in progress article. As we learn more about C, we will amend this list. Banned in CS1010 The banned items should not be used in CS1010. Students should use the alternatives. The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used. 1. The ++ and -- operators. Why? These operators lead to potential undefined behavior. E.g., i = i++; The potential confusion caused by the difference between i++ and ++i . What should be used instead? Use i += 1 or i -= 1 instead of i++ or i-- 2. Skipping of curly braces for single statement conditional or loop body Why? Could lead to dangling else confusion Easy to forget to put back the {} pair if the body is modified beyond a single statements What should be used instead? Always use {} even if the conditional or loop body contains only a single statement. 3. Nested conditional operator ?: Why? Can get difficult to read, understand, and modify. Example: a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z); What should be used Use nested if-else loop 4. Global variables Why? It makes the code hard to reason about and trace, as you have no idea who will modify these variables. For instance, if x is not a global variable, we can safely assert that x is still 1 after calling f() . If x is a global variable, we can no longer assert anything about x . x = 1 ; f (); // { x == 1 } What should be used instead Declare the variables as local, automatic variables, and pass them around. 5. The type int and short Why? C standard guaratees that both short and int are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767. This is too small many purposes. We are not concerned about memory usage in CS1010. If we do want to have precise control over memory, we should be anyway using the types from stdint.h . What should be used instead long , which is guaranteed to be at least 32 bits. Exception If a function from C library calls for the use of int and offers no long alternative, then we have to use int . 6. The type float Why? Not enough precision and will cause floating point errors. What should be used instead double Exception If a function from C library calls for the use of float and offers no double alternative, then we have to use float . 7. Using integer values for true / false Why? Confusing and error prone What should be used instead Use the bool type, and the values true and false . 8. goto Why? makes the logical flow of the code hard to follow and trace What should be used instead combinations of conditionals and loops Discouraged in CS1010 These are things that are not strictly banned, but their usage is discouraged. Students should really use them only if they know very well what they are doing. Use at own perils. 1. printf and scanf Functions Why? Using the wrong format modifier for printf could lead to strange results Using the wrong format modifier for scanf could lead to memory corruption Need to look up what is the right format modifier to use Need to preallocate memory for scanf of strings scanf is not secure scanf is not a pure function. Prefers students to learn about the concept of pure functions first. etc. etc. What should be used instead The CS1010 I/O library 2. switch Statements Why? Bug prone (missing break would cause the case to fall through) Only works on ordinal types. What should be used instead if - else statements 3. break and continue Statements Why? Using break and continue complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone. What should be used instead Simple loops with a single entry and a single exit point. Use flag variables to indicate special conditions to exit or continue with the loop. 4. Skipping parenthesis Why? Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations. We should add parenthesis to make sure the intention of the code is clear. Why should be used instead Parenthesis","title":"C in CS1010"},{"location":"c-in-cs1010.html#c-in-cs1010","text":"C is a simple and flexible language, providing programmers with many different ways to achieve the same thing. Some of these features that C provides, however, could be bug prone. Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students. He feels that some of these features from C are not useful for beginners (or even seasoned programmers). Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon. Some would lead to insecure programs. As such, in CS1010, we ban and discourage the use of certain operators, functions, constructs, and features in C. This article summarizes this list. This is a work in progress article. As we learn more about C, we will amend this list.","title":"C in CS1010"},{"location":"c-in-cs1010.html#banned-in-cs1010","text":"The banned items should not be used in CS1010. Students should use the alternatives. The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.","title":"Banned in CS1010"},{"location":"c-in-cs1010.html#1-the-and-operators","text":"","title":"1. The ++ and -- operators."},{"location":"c-in-cs1010.html#why","text":"These operators lead to potential undefined behavior. E.g., i = i++; The potential confusion caused by the difference between i++ and ++i .","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead","text":"Use i += 1 or i -= 1 instead of i++ or i--","title":"What should be used instead?"},{"location":"c-in-cs1010.html#2-skipping-of-curly-braces-for-single-statement-conditional-or-loop-body","text":"","title":"2. Skipping of curly braces for single statement conditional or loop body"},{"location":"c-in-cs1010.html#why_1","text":"Could lead to dangling else confusion Easy to forget to put back the {} pair if the body is modified beyond a single statements","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_1","text":"Always use {} even if the conditional or loop body contains only a single statement.","title":"What should be used instead?"},{"location":"c-in-cs1010.html#3-nested-conditional-operator","text":"","title":"3. Nested conditional operator ?:"},{"location":"c-in-cs1010.html#why_2","text":"Can get difficult to read, understand, and modify. Example: a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used","text":"Use nested if-else loop","title":"What should be used"},{"location":"c-in-cs1010.html#4-global-variables","text":"","title":"4. Global variables"},{"location":"c-in-cs1010.html#why_3","text":"It makes the code hard to reason about and trace, as you have no idea who will modify these variables. For instance, if x is not a global variable, we can safely assert that x is still 1 after calling f() . If x is a global variable, we can no longer assert anything about x . x = 1 ; f (); // { x == 1 }","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_2","text":"Declare the variables as local, automatic variables, and pass them around.","title":"What should be used instead"},{"location":"c-in-cs1010.html#5-the-type-int-and-short","text":"","title":"5. The type int and short"},{"location":"c-in-cs1010.html#why_4","text":"C standard guaratees that both short and int are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767. This is too small many purposes. We are not concerned about memory usage in CS1010. If we do want to have precise control over memory, we should be anyway using the types from stdint.h .","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_3","text":"long , which is guaranteed to be at least 32 bits.","title":"What should be used instead"},{"location":"c-in-cs1010.html#exception","text":"If a function from C library calls for the use of int and offers no long alternative, then we have to use int .","title":"Exception"},{"location":"c-in-cs1010.html#6-the-type-float","text":"","title":"6. The type float"},{"location":"c-in-cs1010.html#why_5","text":"Not enough precision and will cause floating point errors.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_4","text":"double","title":"What should be used instead"},{"location":"c-in-cs1010.html#exception_1","text":"If a function from C library calls for the use of float and offers no double alternative, then we have to use float .","title":"Exception"},{"location":"c-in-cs1010.html#7-using-integer-values-for-true-false","text":"","title":"7. Using integer values for true / false"},{"location":"c-in-cs1010.html#why_6","text":"Confusing and error prone","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_5","text":"Use the bool type, and the values true and false .","title":"What should be used instead"},{"location":"c-in-cs1010.html#8-goto","text":"","title":"8. goto"},{"location":"c-in-cs1010.html#why_7","text":"makes the logical flow of the code hard to follow and trace","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_6","text":"combinations of conditionals and loops","title":"What should be used instead"},{"location":"c-in-cs1010.html#discouraged-in-cs1010","text":"These are things that are not strictly banned, but their usage is discouraged. Students should really use them only if they know very well what they are doing. Use at own perils.","title":"Discouraged in CS1010"},{"location":"c-in-cs1010.html#1-printf-and-scanf-functions","text":"","title":"1. printf and scanf Functions"},{"location":"c-in-cs1010.html#why_8","text":"Using the wrong format modifier for printf could lead to strange results Using the wrong format modifier for scanf could lead to memory corruption Need to look up what is the right format modifier to use Need to preallocate memory for scanf of strings scanf is not secure scanf is not a pure function. Prefers students to learn about the concept of pure functions first. etc. etc.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_7","text":"The CS1010 I/O library","title":"What should be used instead"},{"location":"c-in-cs1010.html#2-switch-statements","text":"","title":"2. switch Statements"},{"location":"c-in-cs1010.html#why_9","text":"Bug prone (missing break would cause the case to fall through) Only works on ordinal types.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_8","text":"if - else statements","title":"What should be used instead"},{"location":"c-in-cs1010.html#3-break-and-continue-statements","text":"","title":"3. break and continue Statements"},{"location":"c-in-cs1010.html#why_10","text":"Using break and continue complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_9","text":"Simple loops with a single entry and a single exit point. Use flag variables to indicate special conditions to exit or continue with the loop.","title":"What should be used instead"},{"location":"c-in-cs1010.html#4-skipping-parenthesis","text":"","title":"4. Skipping parenthesis"},{"location":"c-in-cs1010.html#why_11","text":"Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations. We should add parenthesis to make sure the intention of the code is clear.","title":"Why?"},{"location":"c-in-cs1010.html#why-should-be-used-instead","text":"Parenthesis","title":"Why should be used instead"},{"location":"clang.html","text":"CS1010 Compilation Guide 1. Compile a standalone C program Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: ooiwt@pe118:~$ ./a.out 2. Renaming executable file The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). ooiwt@pe118:~$ clang teh.c -o teh or ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!! 3. Warning for possible bugs. The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For simplicity, we will ask clang to warn us about everything, by enabling all warnings. The command to do so is: ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with -Wall flag. 4. Generating additional information for debugging. In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead. 5. Linking with standard library. To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated m ), you issue the command: ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm 6. Linking with 3 rd party library By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel","title":"CLang"},{"location":"clang.html#cs1010-compilation-guide","text":"","title":"CS1010 Compilation Guide"},{"location":"clang.html#1-compile-a-standalone-c-program","text":"Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: ooiwt@pe118:~$ ./a.out","title":"1. Compile a standalone C program"},{"location":"clang.html#2-renaming-executable-file","text":"The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). ooiwt@pe118:~$ clang teh.c -o teh or ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!!","title":"2. Renaming executable file"},{"location":"clang.html#3-warning-for-possible-bugs","text":"The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For simplicity, we will ask clang to warn us about everything, by enabling all warnings. The command to do so is: ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with -Wall flag.","title":"3. Warning for possible bugs."},{"location":"clang.html#4-generating-additional-information-for-debugging","text":"In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead.","title":"4. Generating additional information for debugging."},{"location":"clang.html#5-linking-with-standard-library","text":"To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated m ), you issue the command: ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm","title":"5. Linking with standard library."},{"location":"clang.html#6-linking-with-3rd-party-library","text":"By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel","title":"6. Linking with 3rd party library"},{"location":"documentation.html","text":"Code Documentation Code documentation is as important as the code itself. It helps readers of your code, including your future self, to understand the purpose of a piece of code what assumptions are being made, and the reasoning behind why certain things are done. C Syntax for Comments In C, you can write comments in two ways: Either prefix a one-line comment with two slashes // , or Write multiple-line comments between /* and */ For example: // assume the number of elements > 1 /* This function reads in the radius of a sphere and returns the volume of the sphere. We assume the radius is normalized between 0.0 and 1.0. */ The Doxygen Format In CS1010, we will adopt the Doxygen format for C comments. Doxygen is a tool that automatically generates HTML documents from comments in C code and is widely used in the industry. We write a Doxygen comment with an additional * after /* : /** */ The comments can be free-form text. However, to help with creating a more structured document, we can add what Doxygen calls special \"commands\". I view these commands as keys to certain information. Useful commands are: @author : the name the author @file : the name of a file @pre : the precondition of a function @post : the postcondition of a function @param[<dir>] <name> : describe a parameter of a function. <name> is the name of the parameter, <dir> can be in , out , in,out corresponding to whether the parameter is used as input, output, or both. @return : describe the return value of a function The comments should be placed before a file, a function, or a variable that you want the comment to apply to. Example Here is an example: /** * @file: cs1010.c * @author: Ooi Wei Tsang * * This file contains implementation of the CS1010 I/O library to * simplify the reading and writing of integer, real numbers, and text * from the standard input and output respectively. */ /** * Raed k white-space-separated words from the standard input in an array. * The notion of \"word\" is the same to cs1010_read_word(). The caller is * responsible for freeing the memory allocated for the array by calling * free(). * * @param[in] k The number of words to read. * @return Returns NULL if there is a memory allocation error, otherwise, * return an array of char* containing the words. */ char ** cs1010_read_word_array ( int k ) { : } You can also see additional examples in the solution posted for Assignment 1","title":"Documentation Guide"},{"location":"documentation.html#code-documentation","text":"Code documentation is as important as the code itself. It helps readers of your code, including your future self, to understand the purpose of a piece of code what assumptions are being made, and the reasoning behind why certain things are done.","title":"Code Documentation"},{"location":"documentation.html#c-syntax-for-comments","text":"In C, you can write comments in two ways: Either prefix a one-line comment with two slashes // , or Write multiple-line comments between /* and */ For example: // assume the number of elements > 1 /* This function reads in the radius of a sphere and returns the volume of the sphere. We assume the radius is normalized between 0.0 and 1.0. */","title":"C Syntax for Comments"},{"location":"documentation.html#the-doxygen-format","text":"In CS1010, we will adopt the Doxygen format for C comments. Doxygen is a tool that automatically generates HTML documents from comments in C code and is widely used in the industry. We write a Doxygen comment with an additional * after /* : /** */ The comments can be free-form text. However, to help with creating a more structured document, we can add what Doxygen calls special \"commands\". I view these commands as keys to certain information. Useful commands are: @author : the name the author @file : the name of a file @pre : the precondition of a function @post : the postcondition of a function @param[<dir>] <name> : describe a parameter of a function. <name> is the name of the parameter, <dir> can be in , out , in,out corresponding to whether the parameter is used as input, output, or both. @return : describe the return value of a function The comments should be placed before a file, a function, or a variable that you want the comment to apply to.","title":"The Doxygen Format"},{"location":"documentation.html#example","text":"Here is an example: /** * @file: cs1010.c * @author: Ooi Wei Tsang * * This file contains implementation of the CS1010 I/O library to * simplify the reading and writing of integer, real numbers, and text * from the standard input and output respectively. */ /** * Raed k white-space-separated words from the standard input in an array. * The notion of \"word\" is the same to cs1010_read_word(). The caller is * responsible for freeing the memory allocated for the array by calling * free(). * * @param[in] k The number of words to read. * @return Returns NULL if there is a memory allocation error, otherwise, * return an array of char* containing the words. */ char ** cs1010_read_word_array ( int k ) { : } You can also see additional examples in the solution posted for Assignment 1","title":"Example"},{"location":"environments.html","text":"The CS1010 Programming Environment C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 16.04 (or later) using the clang compiler ( version 3.4.2 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ..., pe120 . ( pe stands for \"programming environment\"). You can choose which of the 10 hosts to use. You share the same home directory across all 10 hosts (this home directory, however, is different from that of sunfire ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs. It is therefore advisable for you to familiarize with accessing remote computing servers via ssh and edit your program with either vim or macro . Basic Requirements You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters. You need an ssh client. MacOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply. The Command to SSH Run: ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password. Accessing The PE Hosts from Outside SoC The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, there are two ways. Using SoC VPN One way is to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. Tunneling through Sunfire The alternative is to use ssh tunnels. SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See more details here .) Since sunfire is situated within the School of Computing network, sunfire is able to access the VM. This opens the possibility of connecting from your device (using an Internet connection from a local telco) to sunfire , and then from sunfire to the VM. There are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client. SSH Using Sunfire's Terminal Connect to Sunfire at sunfire.comp.nus.edu.sg via your favorite SSH client. After logging in, run the command ssh pe111 to connect to the programming environment. This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire. Refer to instructions below on how to connect via SSH. SSH Port Forwarding SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments. Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g., pe111 ). This method causes the host to seem as if it is hosted on a local port, e.g. localhost:1010 , allowing you to use your favorite SCP program (e.g. FileZilla ) to access the PE host. To use local port forwarding (from local port 1010 ), connect to sunfire using ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg This command opens an SSH tunnel from port 1010 of your machine to port 22 (the default SSH port) of pe111.comp.nus.edu.sg via sunfire . After successful login, open a separate SSH (or SCP) connection from your machine to localhost at port 1010 to access the PE host: ssh <username>@localhost -p 1000 PuTTY supports SSH port forwarding, so this setup can also be used on Windows. Setting up SSH Keys Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on local machine and on PE is set to 700 and the files id_rsa on local machine and authorized_keys on remote machine is set to 600 . Once setup, you need not enter your password every time you run ssh or scp .","title":"Programming Environments"},{"location":"environments.html#the-cs1010-programming-environment","text":"C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating system, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 16.04 (or later) using the clang compiler ( version 3.4.2 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ..., pe120 . ( pe stands for \"programming environment\"). You can choose which of the 10 hosts to use. You share the same home directory across all 10 hosts (this home directory, however, is different from that of sunfire ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs. It is therefore advisable for you to familiarize with accessing remote computing servers via ssh and edit your program with either vim or macro .","title":"The CS1010 Programming Environment"},{"location":"environments.html#basic-requirements","text":"You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters. You need an ssh client. MacOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply.","title":"Basic Requirements"},{"location":"environments.html#the-command-to-ssh","text":"Run: ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password.","title":"The Command to SSH"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","text":"The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, there are two ways.","title":"Accessing The PE Hosts from Outside SoC"},{"location":"environments.html#using-soc-vpn","text":"One way is to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.","title":"Using SoC VPN"},{"location":"environments.html#tunneling-through-sunfire","text":"The alternative is to use ssh tunnels. SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See more details here .) Since sunfire is situated within the School of Computing network, sunfire is able to access the VM. This opens the possibility of connecting from your device (using an Internet connection from a local telco) to sunfire , and then from sunfire to the VM. There are two ways to achieve this, and in both ways it appears to the PE hosts that Sunfire is the client.","title":"Tunneling through Sunfire"},{"location":"environments.html#ssh-using-sunfires-terminal","text":"Connect to Sunfire at sunfire.comp.nus.edu.sg via your favorite SSH client. After logging in, run the command ssh pe111 to connect to the programming environment. This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire. Refer to instructions below on how to connect via SSH.","title":"SSH Using Sunfire's Terminal"},{"location":"environments.html#ssh-port-forwarding","text":"SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments. Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g., pe111 ). This method causes the host to seem as if it is hosted on a local port, e.g. localhost:1010 , allowing you to use your favorite SCP program (e.g. FileZilla ) to access the PE host. To use local port forwarding (from local port 1010 ), connect to sunfire using ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg This command opens an SSH tunnel from port 1010 of your machine to port 22 (the default SSH port) of pe111.comp.nus.edu.sg via sunfire . After successful login, open a separate SSH (or SCP) connection from your machine to localhost at port 1010 to access the PE host: ssh <username>@localhost -p 1000 PuTTY supports SSH port forwarding, so this setup can also be used on Windows.","title":"SSH Port Forwarding"},{"location":"environments.html#setting-up-ssh-keys","text":"Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on local machine and on PE is set to 700 and the files id_rsa on local machine and authorized_keys on remote machine is set to 600 . Once setup, you need not enter your password every time you run ssh or scp .","title":"Setting up SSH Keys"},{"location":"ex01.html","text":"Exercise 1: Freezer This is your first programming exercise. An exercise is something that you do on your own. You can submit them but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. This is in contrast to an assignment, where you need to submit for grading and for credits. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . Learning Outcomes Be comfortable writing simple C programs that involves arithmetic operations, long and double types. One-Time Setup Before going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called .gitconfig in your home directory and with the following content: [user] name = Your Name email = Your Email [github] user = Your GitHub ID Your email should be whatever you used to sign up Github. For example, a sample .gitconfig looks like this: [user] name = Jon Snow email = king@north.gov [github] user = jonsnow After saving this file, run: git config --get github.user It should return your GitHub user id. It should print your GitHub user id as set. If there is a typo, you need to edit .gitconfig again and reload it by repeating the command above. Setup Click on this link to accept the exercise. Login to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex01 You should see a new subdirectory ex01-<githubid> in your current working directory, where githubid is your GitHub ID. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: freezer1.c and freezer2.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are sub directories that contain test inputs and test outputs. We use the convention problem-name . test-id .in for input test data, and problem-name . test-id .out for output test data. So, you will see freezer1.1.in , freezer1.1.out , etc. The expected output for freezer1.1.in is in freezer1.1.out . You can look at the content of these files if you wish (which UNIX command should you use to do this?). You can edit these files to change the test input and output. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : This is a bash script for testing your code. You do not have to edit this file nor call it directly. It is called by make . If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Jon Snow (Group 10) Solving The Assignments Edit the files freezer1.c and freezer2.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile both C files and if there is no error, run the test scripts. Submission When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex01 The files freezer1.c and freezer2.c will be uploaded to GitHub. You can submit multiple times. Grading This assignment is not graded. Question 1: Freezer (a) Write a program freezer1 (source file freezer1.c ) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure. Assume this temperature T T is given by 1 : T = \\frac{4t^2}{t + 2} - 20; T = \\frac{4t^2}{t + 2} - 20; where t t is the time (in hours) since the power failure. Your program reads in an integer: the number of hours since the start of the power failure. Sample run: ooiwt@pe111:~/ex01-ooiwt$ ./freezer1 0 -20.0000 ooiwt@pe111:~/ex01-ooiwt$ ./freezer1 1 -18.6667 The text ooiwt@pe111:~/ex01-ooiwt$ is the command prompt. Yours will look different, of course. freezer1 is the executable you created. The next line, 0 , is the input you provide. Press enter after the input. -20.0000 is the output printed by freezer1 . (b) freezer1 is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc. The equation given above works for fractional hours as well. Modify your program, call it freezer2 (source file freezer2.c ), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure. For example, to calculate the temperature after 2 hours and 45 minutes of power failure: ooiwt@pe111:~/ex01-ooiwt$ ./freezer2 2 45 -13.6316 I do not know where this formula comes from or if it is correct. Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius! \u21a9","title":"1. Freezer"},{"location":"ex01.html#exercise-1-freezer","text":"This is your first programming exercise. An exercise is something that you do on your own. You can submit them but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. This is in contrast to an assignment, where you need to submit for grading and for credits.","title":"Exercise 1: Freezer"},{"location":"ex01.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim .","title":"Prerequisite"},{"location":"ex01.html#learning-outcomes","text":"Be comfortable writing simple C programs that involves arithmetic operations, long and double types.","title":"Learning Outcomes"},{"location":"ex01.html#one-time-setup","text":"Before going into their first programming exercise, you need to do a one time setup of your account on PE. You need to create a file called .gitconfig in your home directory and with the following content: [user] name = Your Name email = Your Email [github] user = Your GitHub ID Your email should be whatever you used to sign up Github. For example, a sample .gitconfig looks like this: [user] name = Jon Snow email = king@north.gov [github] user = jonsnow After saving this file, run: git config --get github.user It should return your GitHub user id. It should print your GitHub user id as set. If there is a typo, you need to edit .gitconfig again and reload it by repeating the command above.","title":"One-Time Setup"},{"location":"ex01.html#setup","text":"Click on this link to accept the exercise. Login to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex01 You should see a new subdirectory ex01-<githubid> in your current working directory, where githubid is your GitHub ID. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: freezer1.c and freezer2.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are sub directories that contain test inputs and test outputs. We use the convention problem-name . test-id .in for input test data, and problem-name . test-id .out for output test data. So, you will see freezer1.1.in , freezer1.1.out , etc. The expected output for freezer1.1.in is in freezer1.1.out . You can look at the content of these files if you wish (which UNIX command should you use to do this?). You can edit these files to change the test input and output. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : This is a bash script for testing your code. You do not have to edit this file nor call it directly. It is called by make . If you are interested to learn how to write bash script, talk to either Wei Tsang or Google.","title":"Setup"},{"location":"ex01.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: @author XXXX (Group YYYY) and change it to something like: @author Jon Snow (Group 10)","title":"Identifying Yourself"},{"location":"ex01.html#solving-the-assignments","text":"Edit the files freezer1.c and freezer2.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile both C files and if there is no error, run the test scripts.","title":"Solving The Assignments"},{"location":"ex01.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex01 The files freezer1.c and freezer2.c will be uploaded to GitHub. You can submit multiple times.","title":"Submission"},{"location":"ex01.html#grading","text":"This assignment is not graded.","title":"Grading"},{"location":"ex01.html#question-1-freezer","text":"","title":"Question 1: Freezer"},{"location":"ex01.html#a","text":"Write a program freezer1 (source file freezer1.c ) that estimates the temperature (in degree Celsius) in a freezer given the elapsed time (in hours) since a power failure. Assume this temperature T T is given by 1 : T = \\frac{4t^2}{t + 2} - 20; T = \\frac{4t^2}{t + 2} - 20; where t t is the time (in hours) since the power failure. Your program reads in an integer: the number of hours since the start of the power failure.","title":"(a)"},{"location":"ex01.html#sample-run","text":"ooiwt@pe111:~/ex01-ooiwt$ ./freezer1 0 -20.0000 ooiwt@pe111:~/ex01-ooiwt$ ./freezer1 1 -18.6667 The text ooiwt@pe111:~/ex01-ooiwt$ is the command prompt. Yours will look different, of course. freezer1 is the executable you created. The next line, 0 , is the input you provide. Press enter after the input. -20.0000 is the output printed by freezer1 .","title":"Sample run:"},{"location":"ex01.html#b","text":"freezer1 is rather restrictive, as we can only calculate the temperature after one hour, two hours, etc. The equation given above works for fractional hours as well. Modify your program, call it freezer2 (source file freezer2.c ), so that it now reads in two integers: the number of hours and the number of additional minutes since the start of the power failure. For example, to calculate the temperature after 2 hours and 45 minutes of power failure: ooiwt@pe111:~/ex01-ooiwt$ ./freezer2 2 45 -13.6316 I do not know where this formula comes from or if it is correct. Please ignore the fact that, according to this formula, 32 hours after the power is turned off, the freezer will reach the boiling point of 100 Celsius! \u21a9","title":"(b)"},{"location":"ex02.html","text":"Exercise 2: Leap, Suffix, Days This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ). Learning Outcomes Be comfortable writing correct C programs that involve if , else , and logical statements. Setup Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex02 You should see a new subdirectory ex02-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: leap.c , suffix.c , and days.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. Solving The Assignments Edit the .c files to solve the corresponding question as described below You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts. Submission When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex02 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes. Question 1: Leap Year A leap year is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events. In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years. Write a program that reads in an integer representing a year from the standard input and prints out \" is a leap year\" if the input is a leap year. Otherwise, print \" is not a leap year\" to the standard output. Your program should include a bool function is_leap_year that takes in the input year and returns true if the input is a leap year and returns false otherwise. Sample run: ooiwt@pe112:~/ex02-ooiwt$ ./leap 1995 1995 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1996 1996 is a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1900 1900 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 2000 2000 is a leap year Question 2: Ordinal Suffix In English, an ordinal number is written with numerals, followed by its letter suffixes. For instance: 1 st , 2 nd , 3 rd , 4 th , 11 th , 31 st , etc. The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13). All other numbers should end with \"th\". Write a program suffix that reads in an integer number from the standard input and prints out the number with its ordinal suffix. Your program should include a void function print_with_suffix(long n) that takes in the input and prints out the number followed by its suffix. ooiwt@pe112:~/ex02-ooiwt$ ./suffix 2 2nd ooiwt@pe112:~/ex02-ooiwt$ ./suffix 13 13th ooiwt@pe112:~/ex02-ooiwt$ ./suffix 412 412th ooiwt@pe112:~/ex02-ooiwt$ ./suffix 3 3rd Question 3: Days Since 1 January Write a program called days that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive). The program should print to the standard output which day of the year it is. Assume that the year is not a leap year . You can reuse the method print_suffix from the previous question. ooiwt@pe112:~/ex02-ooiwt$ ./days 1 1 1st ooiwt@pe112:~/ex02-ooiwt$ ./days 8 15 227th ooiwt@pe112:~/ex02-ooiwt$ ./days 12 31 365th","title":"2. Leap, Suffix, Days"},{"location":"ex02.html#exercise-2-leap-suffix-days","text":"This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs.","title":"Exercise 2: Leap, Suffix, Days"},{"location":"ex02.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ).","title":"Prerequisite"},{"location":"ex02.html#learning-outcomes","text":"Be comfortable writing correct C programs that involve if , else , and logical statements.","title":"Learning Outcomes"},{"location":"ex02.html#setup","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex02 You should see a new subdirectory ex02-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: leap.c , suffix.c , and days.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code.","title":"Setup"},{"location":"ex02.html#solving-the-assignments","text":"Edit the .c files to solve the corresponding question as described below You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts.","title":"Solving The Assignments"},{"location":"ex02.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex02 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.","title":"Submission"},{"location":"ex02.html#question-1-leap-year","text":"A leap year is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events. In the Gregorian calendar, years that are multiples of four (with the exception of years divisible by 100 but not by 400) are leap years. Write a program that reads in an integer representing a year from the standard input and prints out \" is a leap year\" if the input is a leap year. Otherwise, print \" is not a leap year\" to the standard output. Your program should include a bool function is_leap_year that takes in the input year and returns true if the input is a leap year and returns false otherwise.","title":"Question 1: Leap Year"},{"location":"ex02.html#sample-run","text":"ooiwt@pe112:~/ex02-ooiwt$ ./leap 1995 1995 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1996 1996 is a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1900 1900 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 2000 2000 is a leap year","title":"Sample run:"},{"location":"ex02.html#question-2-ordinal-suffix","text":"In English, an ordinal number is written with numerals, followed by its letter suffixes. For instance: 1 st , 2 nd , 3 rd , 4 th , 11 th , 31 st , etc. The rule is that, a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13). All other numbers should end with \"th\". Write a program suffix that reads in an integer number from the standard input and prints out the number with its ordinal suffix. Your program should include a void function print_with_suffix(long n) that takes in the input and prints out the number followed by its suffix. ooiwt@pe112:~/ex02-ooiwt$ ./suffix 2 2nd ooiwt@pe112:~/ex02-ooiwt$ ./suffix 13 13th ooiwt@pe112:~/ex02-ooiwt$ ./suffix 412 412th ooiwt@pe112:~/ex02-ooiwt$ ./suffix 3 3rd","title":"Question 2: Ordinal Suffix"},{"location":"ex02.html#question-3-days-since-1-january","text":"Write a program called days that reads in two integers from the standard input, the first is the month (ranged 1 to 12, inclusive) and the second is the day (ranged 1 to 31, inclusive). The program should print to the standard output which day of the year it is. Assume that the year is not a leap year . You can reuse the method print_suffix from the previous question. ooiwt@pe112:~/ex02-ooiwt$ ./days 1 1 1st ooiwt@pe112:~/ex02-ooiwt$ ./days 8 15 227th ooiwt@pe112:~/ex02-ooiwt$ ./days 12 31 365th","title":"Question 3: Days Since 1 January"},{"location":"ex03.html","text":"Exercise 3: Binary, Rectangle, Fibonacci, Prime This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ). Learning Outcomes Be comfortable writing correct C programs that involve if , else , loops, and logical statements. Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems. Setup Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex03 You should see a new subdirectory ex03-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: binary.c , rectangle.c , prime.c and fibonacci.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. Solving The Assignments Edit the .c files on the PE hosts to solve the corresponding question as described below. You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts. Submission When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex03 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes. Question 1: Binary In this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9). A number in decimal format is represented with based 10. The last digit (rightmost) corresponds to the unit of 10^0 = 1 10^0 = 1 , the next digit (second last) corresponds to the unit of 10^1 = 10 10^1 = 10 , and so on. So, one can write the decimal number, for instance, 7146 as 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 . A number represented in binary uses base 2 instead of base 10. The last digit corresponds to 2^0 = 1 2^0 = 1 . The second last digit correponds to 2^1 = 2 2^1 = 2 , the third last digit corresponds to 2^2 = 4 2^2 = 4 , and so on. So, the binary number 1101, for instance, corresponds to 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 . Write a program called binary that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output. Sample run: ooiwt@pe113:~/ex03-ooiwt$ ./binary 1101 13 ooiwt@pe113:~/ex03-ooiwt$ ./binary 111 7 ooiwt@pe113:~/ex03-ooiwt$ ./binary 10110100 180 Question 2: Rectangle Write a program called rectangle that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle. The width and height must be at least 2. Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively. Strings consisting of these special characters have been given to you in rectangle.c and we have defined them as constants. For instance, \"\u2554\" is called TOP_LEFT , and to print this out, you can write cs1010_print_string ( TOP_LEFT ); ooiwt@pe113:~/ex03-ooiwt$ ./rectangle 2 2 \u2554\u2557 \u255a\u255d ooiwt@pe113:~/ex03-ooiwt$ ./rectangle 2 10 \u2554\u2557 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u255a\u255d ooiwt@pe113:~/ex03-ooiwt$ ./rectangle 10 10 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d Question 3: Fibonacci The Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have many fascinating properties . The Fibonacci sequence can be constructed as follows. The first Fibonacci number is 1. The second Fibonacci number is also 1. Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th. Write a program called fibonacci that reads a positive integer number n from the standard input, and print the n -th Fibonacci number to the standard output. Your program must not use recursion. ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci 1 1 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci 10 55 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci 83 99194853094755497 Question 4: Prime Write a program called prime that reads a positive integer n from the standard input and either prints prime if n is a prime number, or prints not prime if n is not a prime number. ooiwt@pe113:~/ex03-ooiwt$ ./prime 2 prime ooiwt@pe113:~/ex03-ooiwt$ ./prime 14000605 not prime ooiwt@pe113:~/ex03-ooiwt$ ./prime 99194853094755497 prime Bonus: UNIX Pipe If you look at the output from the last fibonacci example and the input to the last prime example, you will see that they are the same number. This means that the 83 rd Fibonacci number is prime! Suppose now you want to ask, is the 13 th Fibonacci number a prime? How can we use the programs that we have wrote to do this? There are several ways You can merge the two C files to create a new program that, given n , calculate the n -th Fibonacci number, then check if it is prime. You can reuse the two programs you have already written. First, run fibonacci with input 13, then cut-and-paste the output as input to prime . A better alternative is to use a | in a UNIX-based system. A | , called a pipe , basically interconnects the standard output of one command to the standard input of the second command. Consider the following: ooiwt@pe113:~/ex03-ooiwt$ a | b Whatever the program a prints to the standard output, will be read by the program b when it reads from the standard input. You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program! Back to the original problem: how to check if the 83 rd Fibonnacci number is prime? You can run: ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime 83 prime","title":"3. Binary, Rectangle, Fibonacci, Prime"},{"location":"ex03.html#exercise-3-binary-rectangle-fibonacci-prime","text":"This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs.","title":"Exercise 3: Binary, Rectangle, Fibonacci, Prime"},{"location":"ex03.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ).","title":"Prerequisite"},{"location":"ex03.html#learning-outcomes","text":"Be comfortable writing correct C programs that involve if , else , loops, and logical statements. Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.","title":"Learning Outcomes"},{"location":"ex03.html#setup","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex03 You should see a new subdirectory ex03-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: binary.c , rectangle.c , prime.c and fibonacci.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code.","title":"Setup"},{"location":"ex03.html#solving-the-assignments","text":"Edit the .c files on the PE hosts to solve the corresponding question as described below. You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts.","title":"Solving The Assignments"},{"location":"ex03.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex03 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.","title":"Submission"},{"location":"ex03.html#question-1-binary","text":"In this question, you are asked to convert a number represented in binary format (using digits 0 and 1) into the decimal format (using digits 0 and 9). A number in decimal format is represented with based 10. The last digit (rightmost) corresponds to the unit of 10^0 = 1 10^0 = 1 , the next digit (second last) corresponds to the unit of 10^1 = 10 10^1 = 10 , and so on. So, one can write the decimal number, for instance, 7146 as 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 7 \\times 10^3 + 1 \\times 10^2 + 4 \\times 10^1 + 6 \\times 10^0 . A number represented in binary uses base 2 instead of base 10. The last digit corresponds to 2^0 = 1 2^0 = 1 . The second last digit correponds to 2^1 = 2 2^1 = 2 , the third last digit corresponds to 2^2 = 4 2^2 = 4 , and so on. So, the binary number 1101, for instance, corresponds to 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^0 = 13 . Write a program called binary that reads in a positive integer consists of only 0s and 1s from the standard input, treats it as a binary number, and prints the corresponding decimal number to the standard output.","title":"Question 1: Binary"},{"location":"ex03.html#sample-run","text":"ooiwt@pe113:~/ex03-ooiwt$ ./binary 1101 13 ooiwt@pe113:~/ex03-ooiwt$ ./binary 111 7 ooiwt@pe113:~/ex03-ooiwt$ ./binary 10110100 180","title":"Sample run:"},{"location":"ex03.html#question-2-rectangle","text":"Write a program called rectangle that reads two positive integers from the standard input, corresponding to the width and the height of the rectangle. The width and height must be at least 2. Draw a rectangle on the screen using the special ASCII characters #define \"\u2554\" \"\u2557\" \"\u255d\" \"\u255a\" \"\u2550\" \"\u2551\", which corresponds to the top left, top right, bottom right, bottom left, top/bottom edge, and left/right edge of the rectangle respectively. Strings consisting of these special characters have been given to you in rectangle.c and we have defined them as constants. For instance, \"\u2554\" is called TOP_LEFT , and to print this out, you can write cs1010_print_string ( TOP_LEFT ); ooiwt@pe113:~/ex03-ooiwt$ ./rectangle 2 2 \u2554\u2557 \u255a\u255d ooiwt@pe113:~/ex03-ooiwt$ ./rectangle 2 10 \u2554\u2557 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u2551\u2551 \u255a\u255d ooiwt@pe113:~/ex03-ooiwt$ ./rectangle 10 10 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d","title":"Question 2: Rectangle"},{"location":"ex03.html#question-3-fibonacci","text":"The Fibonacci sequence is a sequence of numbers 1, 1, 2, 3, 5, 8, 13, ... Fibonacci numbers often appear in mathematics as well as in nature and have many fascinating properties . The Fibonacci sequence can be constructed as follows. The first Fibonacci number is 1. The second Fibonacci number is also 1. Subsequently, the i-th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the (i-2)-th, and the (i-1)-th. Write a program called fibonacci that reads a positive integer number n from the standard input, and print the n -th Fibonacci number to the standard output. Your program must not use recursion. ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci 1 1 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci 10 55 ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci 83 99194853094755497","title":"Question 3: Fibonacci"},{"location":"ex03.html#question-4-prime","text":"Write a program called prime that reads a positive integer n from the standard input and either prints prime if n is a prime number, or prints not prime if n is not a prime number. ooiwt@pe113:~/ex03-ooiwt$ ./prime 2 prime ooiwt@pe113:~/ex03-ooiwt$ ./prime 14000605 not prime ooiwt@pe113:~/ex03-ooiwt$ ./prime 99194853094755497 prime","title":"Question 4: Prime"},{"location":"ex03.html#bonus-unix-pipe","text":"If you look at the output from the last fibonacci example and the input to the last prime example, you will see that they are the same number. This means that the 83 rd Fibonacci number is prime! Suppose now you want to ask, is the 13 th Fibonacci number a prime? How can we use the programs that we have wrote to do this? There are several ways You can merge the two C files to create a new program that, given n , calculate the n -th Fibonacci number, then check if it is prime. You can reuse the two programs you have already written. First, run fibonacci with input 13, then cut-and-paste the output as input to prime . A better alternative is to use a | in a UNIX-based system. A | , called a pipe , basically interconnects the standard output of one command to the standard input of the second command. Consider the following: ooiwt@pe113:~/ex03-ooiwt$ a | b Whatever the program a prints to the standard output, will be read by the program b when it reads from the standard input. You have seen how the standard input can refer to a keyboard or a file, now you have seen how the standard input can also be another program! Back to the original problem: how to check if the 83 rd Fibonnacci number is prime? You can run: ooiwt@pe113:~/ex03-ooiwt$ ./fibonacci | ./prime 83 prime","title":"Bonus: UNIX Pipe"},{"location":"ex04.html","text":"Exercise 4: ID, Grade, Index, Max This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ). Learning Outcomes Be comfortable writing correct C programs that involve if , else , loops, logical statements, and arrays. Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems. Setup Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex04 You should see a new subdirectory ex04-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: id.c , grade.c , index.c and max.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. Solving The Assignments Edit the .c files on the PE hosts to solve the corresponding question as described below. You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts. Submission When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex04 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes. Question 1: ID Your NUS student id has a letter at the end. This letter is called a check code and is a form of redundancy check used for detecting errors, especially when your student id is manually entered into a software application. Your check code is calculated by: Sum up the digits in your student id. Let the sum be N N . Divide N N by 13, and take the remainder. Let the remainder be R R Look up the table below: Remainder Check Code 0 Y 1 X 2 W 3 U 4 R 5 N 6 M 7 L 8 J 9 H 10 E 11 A 12 B Write a program that reads in an integer containing the digits of a student's id from the standard input. Print out the check code to the standard output. You should practice using an array to solve this problem instead of using a long if-else statement. ooiwt@pe116:~/ex04-ooiwt$ ./studentid 1933091 Y ooiwt@pe116:~/ex04-ooiwt$ ./studentid 3364497 E ooiwt@pe116:~/ex04-ooiwt$ ./studentid 0123456 J Addendum: Some students choose to store the check code in an array of char values instead of an array of strings. Storing the check code as char is indeed more appropriate, but I have not mentioned how to print a char to the standard output. There is no cs1010_print_char in the CS1010 I/O library. One way to print a char variable is to use putchar() function. The example below print A . #include <stdio.h> int main () { char c = 'A' ; putchar ( c ); } Question 2: Grade In a mirror universe, there is an evil version of your professor who is especially tough on his CS1010 students. He uses the following grading scheme to decide the letter grade to give out. Marks Letter Grade 100 A+ 99 A 98 A- 96-97 B+ 91-95 B 86-90 B- 81-85 C+ 71-80 C 61-70 D+ 51-60 D 0 -50 F Write a program called grade that reads in an integer corresponding to the marks given to a student. Print out the letter grade given by the evil professor. You should practice using an array to solve this problem instead of using a long if-else statement as done in Unit 8 . ooiwt@pe116:~/ex04-ooiwt$ ./grade 100 A+ ooiwt@pe116:~/ex04-ooiwt$ ./grade 99 A ooiwt@pe116:~/ex04-ooiwt$ ./grade 50 F ooiwt@pe116:~/ex04-ooiwt$ ./grade 87 B- Question 3: Index Write a program index that finds a given number from a list of n n integers L L . The program should read the following from the standard inputs in order: The first number is a positive integer n n The next n n numbers corresponds to the list of integers l_0, l_1, ... l_{n-1} l_0, l_1, ... l_{n-1} in L L . The next number is a positive integer k k The next k k numbers are integers corresponds to a list of queries q_0, q_1, .. q_k q_0, q_1, .. q_k For each query, the program should print (on a new line) the position of the integer in the list, or \"not found\" if the query cannot be found. To be more precise, for each i i , if q_i == l_j q_i == l_j for some j j , print j j . If q_i q_i appears multiple times in L L , print the smallest j j . If q_i q_i is not in L L , then print \"not found\". ooiwt@pe116:~/ex04-ooiwt$ cat input 5 -5 3 1 8 -5 3 1 4 -5 ooiwt@pe116:~/ex04-ooiwt$ ./index < input 2 not found 0 Line 1 of the input file input tells the program that there are five integers to read. The next five integers should be read in as the list. The next integer (Line 3) is 3. The next three integers should be read in as queries. The first query is 1, which can be found at position 2 (we start counting from 0). The next query is 4, which is not found in the list. Finally, the last query is -5, which can be found at position 0 and 4, but we return only the one at position 0. Question 4: Max Write a program max that finds the maximum value from a list of n n integers L L . Instead of doing this with a loop, you should solve this question with recursion. Write a function long max(const long list[], long start, long end) { } that calls itself and return the maximum value among the array elements list[start] .. list[end - 1] . It should split the input list into two halves (roughly), find the maximum of the left half, find the maximum of the right half, and return the larger of these two maximums. In the function definition above, the keyword const (short for constant) is used to annotate that the array list is meant to remain unchanged. The program should read the following from the standard inputs: The first number is a positive integer n n The next n n numbers correspond to the list of integers L L . and print to the largest value among the inputs to the standard output. ooiwt@pe116:~/ex04-ooiwt$ cat input 5 -5 3 1 8 2 ooiwt@pe116:~/ex04-ooiwt$ ./max < input 8","title":"4. ID, Grade, Index, Max"},{"location":"ex04.html#exercise-4-id-grade-index-max","text":"This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs.","title":"Exercise 4: ID, Grade, Index, Max"},{"location":"ex04.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ).","title":"Prerequisite"},{"location":"ex04.html#learning-outcomes","text":"Be comfortable writing correct C programs that involve if , else , loops, logical statements, and arrays. Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems.","title":"Learning Outcomes"},{"location":"ex04.html#setup","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex04 You should see a new subdirectory ex04-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: id.c , grade.c , index.c and max.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code.","title":"Setup"},{"location":"ex04.html#solving-the-assignments","text":"Edit the .c files on the PE hosts to solve the corresponding question as described below. You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts.","title":"Solving The Assignments"},{"location":"ex04.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex04 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.","title":"Submission"},{"location":"ex04.html#question-1-id","text":"Your NUS student id has a letter at the end. This letter is called a check code and is a form of redundancy check used for detecting errors, especially when your student id is manually entered into a software application. Your check code is calculated by: Sum up the digits in your student id. Let the sum be N N . Divide N N by 13, and take the remainder. Let the remainder be R R Look up the table below: Remainder Check Code 0 Y 1 X 2 W 3 U 4 R 5 N 6 M 7 L 8 J 9 H 10 E 11 A 12 B Write a program that reads in an integer containing the digits of a student's id from the standard input. Print out the check code to the standard output. You should practice using an array to solve this problem instead of using a long if-else statement. ooiwt@pe116:~/ex04-ooiwt$ ./studentid 1933091 Y ooiwt@pe116:~/ex04-ooiwt$ ./studentid 3364497 E ooiwt@pe116:~/ex04-ooiwt$ ./studentid 0123456 J Addendum: Some students choose to store the check code in an array of char values instead of an array of strings. Storing the check code as char is indeed more appropriate, but I have not mentioned how to print a char to the standard output. There is no cs1010_print_char in the CS1010 I/O library. One way to print a char variable is to use putchar() function. The example below print A . #include <stdio.h> int main () { char c = 'A' ; putchar ( c ); }","title":"Question 1: ID"},{"location":"ex04.html#question-2-grade","text":"In a mirror universe, there is an evil version of your professor who is especially tough on his CS1010 students. He uses the following grading scheme to decide the letter grade to give out. Marks Letter Grade 100 A+ 99 A 98 A- 96-97 B+ 91-95 B 86-90 B- 81-85 C+ 71-80 C 61-70 D+ 51-60 D 0 -50 F Write a program called grade that reads in an integer corresponding to the marks given to a student. Print out the letter grade given by the evil professor. You should practice using an array to solve this problem instead of using a long if-else statement as done in Unit 8 . ooiwt@pe116:~/ex04-ooiwt$ ./grade 100 A+ ooiwt@pe116:~/ex04-ooiwt$ ./grade 99 A ooiwt@pe116:~/ex04-ooiwt$ ./grade 50 F ooiwt@pe116:~/ex04-ooiwt$ ./grade 87 B-","title":"Question 2: Grade"},{"location":"ex04.html#question-3-index","text":"Write a program index that finds a given number from a list of n n integers L L . The program should read the following from the standard inputs in order: The first number is a positive integer n n The next n n numbers corresponds to the list of integers l_0, l_1, ... l_{n-1} l_0, l_1, ... l_{n-1} in L L . The next number is a positive integer k k The next k k numbers are integers corresponds to a list of queries q_0, q_1, .. q_k q_0, q_1, .. q_k For each query, the program should print (on a new line) the position of the integer in the list, or \"not found\" if the query cannot be found. To be more precise, for each i i , if q_i == l_j q_i == l_j for some j j , print j j . If q_i q_i appears multiple times in L L , print the smallest j j . If q_i q_i is not in L L , then print \"not found\". ooiwt@pe116:~/ex04-ooiwt$ cat input 5 -5 3 1 8 -5 3 1 4 -5 ooiwt@pe116:~/ex04-ooiwt$ ./index < input 2 not found 0 Line 1 of the input file input tells the program that there are five integers to read. The next five integers should be read in as the list. The next integer (Line 3) is 3. The next three integers should be read in as queries. The first query is 1, which can be found at position 2 (we start counting from 0). The next query is 4, which is not found in the list. Finally, the last query is -5, which can be found at position 0 and 4, but we return only the one at position 0.","title":"Question 3: Index"},{"location":"ex04.html#question-4-max","text":"Write a program max that finds the maximum value from a list of n n integers L L . Instead of doing this with a loop, you should solve this question with recursion. Write a function long max(const long list[], long start, long end) { } that calls itself and return the maximum value among the array elements list[start] .. list[end - 1] . It should split the input list into two halves (roughly), find the maximum of the left half, find the maximum of the right half, and return the larger of these two maximums. In the function definition above, the keyword const (short for constant) is used to annotate that the array list is meant to remain unchanged. The program should read the following from the standard inputs: The first number is a positive integer n n The next n n numbers correspond to the list of integers L L . and print to the largest value among the inputs to the standard output. ooiwt@pe116:~/ex04-ooiwt$ cat input 5 -5 3 1 8 2 ooiwt@pe116:~/ex04-ooiwt$ ./max < input 8","title":"Question 4: Max"},{"location":"ex05.html","text":"Exercise 5: Square, Escape, MagicSquare This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ). Learning Outcomes Be comfortable writing correct C programs that involve if , else , loops, logical statements, memory management, and arrays. Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems. Be able to use nD arrays to solve problems Setup Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex05 You should see a new subdirectory ex05-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: square.c , escape.c , and magicsquare.c are the most important files. They are the C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. Solving The Assignments Edit the .c files on the PE hosts to solve the corresponding question as described below. You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts. Submission When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex05 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes. Question 1: Square Recall Question 5 from PE1, where you are asked to draw patterns of squares using recursion. In this problem, you are to solve the same problem using loops and arrays, instead of recursion. Write a program square that reads, from the standard input, an integer n n and prints, to the standard output, a set of squares with width n n , n - 4 n - 4 , n - 8 n - 8 , .. until we reach either the width of 3, 2, 1, or 0. The smaller square is contained in the larger squares. The squares do not touch each other. A square has exactly one space between itself and the next larger square (if exists), in each direction. Here is how we can use loops and a 2D array to solve this problem. Suppose we have a 2D char array of size $n \\times $n. We can \"draw\" in this array by filling it with ' ' or '#' . We can then print this array to the standard output to display the pattern on the screen. Write a program square , that reads from standard inputs, an integer n , and prints to standard output the expected pattern of squares. Sample Run 1 ooiwt@pe119:~ex05-weitsang$ ./square 1 # ooiwt@pe119:~ex05-weitsang$ ./square 2 ## ## ooiwt@pe119:~ex05-weitsang$ ./square 3 ### # # ### ooiwt@pe119:~ex05-weitsang$ ./square 4 #### # # # # #### ooiwt@pe119:~ex05-weitsang$ ./square 5 ##### # # # # # # # ##### ooiwt@pe119:~ex05-weitsang$ ./square 6 ###### # # # ## # # ## # # # ###### ooiwt@pe119:~ex05-weitsang$ ./square 7 ####### # # # ### # # # # # # ### # # # ####### ooiwt@pe119:~ex05-weitsang$ ./square 10 ########## # # # ###### # # # # # # # ## # # # # ## # # # # # # # ###### # # # ########## Question 2: Escape Ackbar is lost in a maze that contains traps. You are his only hope! Send him instructions remotely to help him escape. The maze is represented as a m \\times n m \\times n grid of cells, where each cell can be of the following: A wall, denoted by character '#' An empty space, denoted by character '.' A trap, denoted by character '*' To help Ackbar, you give Ackbar a series of instructions denoted by U , D , L , or R . U instructs Ackbar to move to the cell one row above. D instructors Ackbar to go to the cell one row below. L instructs Ackbar to move to the cell one column to the left, and R instructs Ackbar to move to the cell one column to the right. Ackbar follows the instructions in the order they are given, and it only moves one cell adjacent by following each instruction, with the following exceptions: If an instruction leads Ackbar to a wall, Ackbar's path is blocked and he stays in position. He continues with the next instruction if there is one. if an instruction leads Ackbar to a trap, he is trapped and is unable to move anymore. All subsequent instructions have no effect on Ackbar. Poor Ackbar! If the instruction leads Ackbar to anywhere outside the maze, Ackbar escapes happily and any instruction after that is ignored. For convenience, we index the row as 0 to m m -1 from top to bottom, and column as 0 to n n -1 from left to right. Write a program escape , that reads (from the standard input) two positive integers m m and n n , followed by m m rows with n n characters in each row. These characters denote the maze of size m \\times n m \\times n . Each character can only be # , . , * or A , where A denotes the initial position of Ackbar on an empty space. It is guaranteed only one A exists in the input. Your program then reads a string denoting the order you give to Ackbar. Each character can only be U , D , L , or R . Finally, your program prints, to the standard output, one of the following: If Ackbar escaped from the maze after following some instructions, print \"ESCAPED!\" If Ackbar is trapped due to your unwise instruction, print \"IT'S A TRAP!\" If Ackbar is still stuck in the maze but not trapped after following all the instructions, print the position of Ackbar as x y where x and y denotes the row and column of Ackbar's position after following all your instructions. Sample Run ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### RLU 1 1 ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### RLUUU ESCAPED! ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### LURLUUUDLR ESCAPED! ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### UDDLUUUUU IT'S A TRAP! Question 3: Magic A magic square is a grid of n \\times n n \\times n with each cell filled with a distinct number from 1 to n^2 n^2 , such that, the sum of each row, column, or diagonal are the same. Write a program, magicsquare , that constructs a magic square of size n \\times n n \\times n , where n n is odd. There are multiple ways we can construct such as magic square. For this question, you shall follow the following algorithm: Put 1 at center column of the top row Each of the remaining numbers is placed one row up and one column to the right of the previous number. This may not always work when we reach the edge of the square or when the cell one row up and one column to the right is occupied. In such a case, you should follow the rules below: A. If a number's cell is already taken, put it one row below the position of the previous number; B. If a number's cell is above the top row, stay in that column and put it in the bottom row; C. If a number's cell is outside of the rightmost column, stay in that row and put it in the leftmost column; D. If a number's cell is outside both the topmost row and the rightmost column put it one row below the previous number. The following example shows how we fill up a 5\\times 5 5\\times 5 magic square. The number 2 is filled above the top row, so we apply Rule B. The number 4 is filled outside the rightmost column, so we apply Rule C. The cell for number 6 is already taken (by 1), so we apply Rule A. The number 16 goes outside both the topmost row and the rightmost column, so we apply Rule D. Write a program magicsquare , that reads (from the standard input) an odd integer n n and prints (to the standard output) n n rows with n n numbers in each row, denoting the constructed magic square using above described method. Sample Run ooiwt@pe119:~/ex05-weitsang$ ./magicsquare 3 8 1 6 3 5 7 4 9 2 ooiwt@pe119:~/ex05-weitsang$ ./magicsquare 7 30 39 48 1 10 19 28 38 47 7 9 18 27 29 46 6 8 17 26 35 37 5 14 16 25 34 36 45 13 15 24 33 42 44 4 21 23 32 41 43 3 12 22 31 40 49 2 11 20","title":"5. Square, Escape, Magic"},{"location":"ex05.html#exercise-5-square-escape-magicsquare","text":"This is a programming exercise for you to solve on your own. You can submit but it will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. Feel free to discuss your solution with your peers or your TAs.","title":"Exercise 5: Square, Escape, MagicSquare"},{"location":"ex05.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have a GitHub account and have setup .gitconfig (see Exercise 1 ).","title":"Prerequisite"},{"location":"ex05.html#learning-outcomes","text":"Be comfortable writing correct C programs that involve if , else , loops, logical statements, memory management, and arrays. Be able to decompose a more complex problem into smaller subproblems and write functions to solve the sub-problems. Be able to use nD arrays to solve problems","title":"Learning Outcomes"},{"location":"ex05.html#setup","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: ~cs1010/get-ex05 You should see a new subdirectory ex05-<githubid> in your current working directory, where githubid is your GitHub ID. Inside that directory, you should see a bunch of files: square.c , escape.c , and magicsquare.c are the most important files. They are the C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 1 so you should be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code.","title":"Setup"},{"location":"ex05.html#solving-the-assignments","text":"Edit the .c files on the PE hosts to solve the corresponding question as described below. You can assume that all test inputs are valid inputs. To compile and run the given tests with the sample inputs and outputs, run on the command line, make This will compile all your C files and if there is no error, run the test scripts.","title":"Solving The Assignments"},{"location":"ex05.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: ~cs1010/submit-ex05 The .c files will be uploaded to GitHub. You can submit multiple times. As an exercise is not graded, submitting your code only serves the purpose of archiving your work for backup purposes.","title":"Submission"},{"location":"ex05.html#question-1-square","text":"Recall Question 5 from PE1, where you are asked to draw patterns of squares using recursion. In this problem, you are to solve the same problem using loops and arrays, instead of recursion. Write a program square that reads, from the standard input, an integer n n and prints, to the standard output, a set of squares with width n n , n - 4 n - 4 , n - 8 n - 8 , .. until we reach either the width of 3, 2, 1, or 0. The smaller square is contained in the larger squares. The squares do not touch each other. A square has exactly one space between itself and the next larger square (if exists), in each direction. Here is how we can use loops and a 2D array to solve this problem. Suppose we have a 2D char array of size $n \\times $n. We can \"draw\" in this array by filling it with ' ' or '#' . We can then print this array to the standard output to display the pattern on the screen. Write a program square , that reads from standard inputs, an integer n , and prints to standard output the expected pattern of squares.","title":"Question 1: Square"},{"location":"ex05.html#sample-run-1","text":"ooiwt@pe119:~ex05-weitsang$ ./square 1 # ooiwt@pe119:~ex05-weitsang$ ./square 2 ## ## ooiwt@pe119:~ex05-weitsang$ ./square 3 ### # # ### ooiwt@pe119:~ex05-weitsang$ ./square 4 #### # # # # #### ooiwt@pe119:~ex05-weitsang$ ./square 5 ##### # # # # # # # ##### ooiwt@pe119:~ex05-weitsang$ ./square 6 ###### # # # ## # # ## # # # ###### ooiwt@pe119:~ex05-weitsang$ ./square 7 ####### # # # ### # # # # # # ### # # # ####### ooiwt@pe119:~ex05-weitsang$ ./square 10 ########## # # # ###### # # # # # # # ## # # # # ## # # # # # # # ###### # # # ##########","title":"Sample Run 1"},{"location":"ex05.html#question-2-escape","text":"Ackbar is lost in a maze that contains traps. You are his only hope! Send him instructions remotely to help him escape. The maze is represented as a m \\times n m \\times n grid of cells, where each cell can be of the following: A wall, denoted by character '#' An empty space, denoted by character '.' A trap, denoted by character '*' To help Ackbar, you give Ackbar a series of instructions denoted by U , D , L , or R . U instructs Ackbar to move to the cell one row above. D instructors Ackbar to go to the cell one row below. L instructs Ackbar to move to the cell one column to the left, and R instructs Ackbar to move to the cell one column to the right. Ackbar follows the instructions in the order they are given, and it only moves one cell adjacent by following each instruction, with the following exceptions: If an instruction leads Ackbar to a wall, Ackbar's path is blocked and he stays in position. He continues with the next instruction if there is one. if an instruction leads Ackbar to a trap, he is trapped and is unable to move anymore. All subsequent instructions have no effect on Ackbar. Poor Ackbar! If the instruction leads Ackbar to anywhere outside the maze, Ackbar escapes happily and any instruction after that is ignored. For convenience, we index the row as 0 to m m -1 from top to bottom, and column as 0 to n n -1 from left to right. Write a program escape , that reads (from the standard input) two positive integers m m and n n , followed by m m rows with n n characters in each row. These characters denote the maze of size m \\times n m \\times n . Each character can only be # , . , * or A , where A denotes the initial position of Ackbar on an empty space. It is guaranteed only one A exists in the input. Your program then reads a string denoting the order you give to Ackbar. Each character can only be U , D , L , or R . Finally, your program prints, to the standard output, one of the following: If Ackbar escaped from the maze after following some instructions, print \"ESCAPED!\" If Ackbar is trapped due to your unwise instruction, print \"IT'S A TRAP!\" If Ackbar is still stuck in the maze but not trapped after following all the instructions, print the position of Ackbar as x y where x and y denotes the row and column of Ackbar's position after following all your instructions.","title":"Question 2: Escape"},{"location":"ex05.html#sample-run","text":"ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### RLU 1 1 ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### RLUUU ESCAPED! ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### LURLUUUDLR ESCAPED! ooiwt@pe119:~/ex05-weitsang$ ./escape 5 5 #.### #...# #.A## #.*.# ##### UDDLUUUUU IT'S A TRAP!","title":"Sample Run"},{"location":"ex05.html#question-3-magic","text":"A magic square is a grid of n \\times n n \\times n with each cell filled with a distinct number from 1 to n^2 n^2 , such that, the sum of each row, column, or diagonal are the same. Write a program, magicsquare , that constructs a magic square of size n \\times n n \\times n , where n n is odd. There are multiple ways we can construct such as magic square. For this question, you shall follow the following algorithm: Put 1 at center column of the top row Each of the remaining numbers is placed one row up and one column to the right of the previous number. This may not always work when we reach the edge of the square or when the cell one row up and one column to the right is occupied. In such a case, you should follow the rules below: A. If a number's cell is already taken, put it one row below the position of the previous number; B. If a number's cell is above the top row, stay in that column and put it in the bottom row; C. If a number's cell is outside of the rightmost column, stay in that row and put it in the leftmost column; D. If a number's cell is outside both the topmost row and the rightmost column put it one row below the previous number. The following example shows how we fill up a 5\\times 5 5\\times 5 magic square. The number 2 is filled above the top row, so we apply Rule B. The number 4 is filled outside the rightmost column, so we apply Rule C. The cell for number 6 is already taken (by 1), so we apply Rule A. The number 16 goes outside both the topmost row and the rightmost column, so we apply Rule D. Write a program magicsquare , that reads (from the standard input) an odd integer n n and prints (to the standard output) n n rows with n n numbers in each row, denoting the constructed magic square using above described method.","title":"Question 3: Magic"},{"location":"ex05.html#sample-run_1","text":"ooiwt@pe119:~/ex05-weitsang$ ./magicsquare 3 8 1 6 3 5 7 4 9 2 ooiwt@pe119:~/ex05-weitsang$ ./magicsquare 7 30 39 48 1 10 19 28 38 47 7 9 18 27 29 46 6 8 17 26 35 37 5 14 16 25 34 36 45 13 15 24 33 42 44 4 21 23 32 41 43 3 12 22 31 40 49 2 11 20","title":"Sample Run"},{"location":"idments.html","text":"d255c540-b2fe-49dc-b07a-f9a4c364d7cf","title":"Idments"},{"location":"kahoot01.html","text":"Kahoot Quiz 1 3 September 2018 (Week 4) Question 1 What is the output of the algorithm in the flowchart below if the input L is 10, 7, 1? A. 18 B. 27 C. 8 D. 17 (Answer: B) Question 2 What is the output of the algorithm in the flowchart below if the input L is 5, 6, 10? A. 5 B. 6 C. 10 D. No output (Answer: B) Question 3 Refer to the flowchart in Question 2. What is the output of the algorithm if L is 1, 2, 3, 4? A. 2 B. 3 C. 4 D. No output (Answer: D)","title":"Flow Charts"},{"location":"kahoot01.html#kahoot-quiz-1","text":"3 September 2018 (Week 4)","title":"Kahoot Quiz 1"},{"location":"kahoot01.html#question-1","text":"What is the output of the algorithm in the flowchart below if the input L is 10, 7, 1? A. 18 B. 27 C. 8 D. 17 (Answer: B)","title":"Question 1"},{"location":"kahoot01.html#question-2","text":"What is the output of the algorithm in the flowchart below if the input L is 5, 6, 10? A. 5 B. 6 C. 10 D. No output (Answer: B)","title":"Question 2"},{"location":"kahoot01.html#question-3","text":"Refer to the flowchart in Question 2. What is the output of the algorithm if L is 1, 2, 3, 4? A. 2 B. 3 C. 4 D. No output (Answer: D)","title":"Question 3"},{"location":"library.html","text":"The CS1010 I/O Library To help students get started with C programming without worrying too much about the details and pitfalls of using printf and scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings. The libraries are pre-installed in CS1010 programming environments , with cs1010.h located under ~cs1010/include and libcs1010.a located under ~cs1010/lib . Installing the Library If you want to install the libraries on your own version of Ubuntu, do the following: To get an updated copy of the library, clone it from its git repo on GitHub with the command: git clone https://github.com/nus-cs1010-1819-s1/libcs1010.git It is recommended you do this in your home directory. You should see an output similar to: Cloning into 'libcs1010'... remote: Counting objects: 6, done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. After that, you should see a subdirectory libcs1010 created in your current directory. Inside, there should be a file called Makefile , and two subdirectories called include and src . To compile the library, run make This should compile the file src/cs1010.c and create a static C library named libcs1010.a under the lib directory. Using the Library Header To use the CS1010 I/O library, you should #include the file cs1010.h , like this: #include \"cs1010.h\" at the top of your C program. Linking The CS1010 I/O library is provided as the file libcs1010.a . To link to the library, you need to compile with -lcs1010 . Usually, you need to specify where you can find cs1010.h with the -I flag, and libcs1010.a with the -L flag. Assuming that you are compiling in another subdirectory under your home and libcs1010 are located under your home directory, the header file and the library file are in ../libcs1010/include and ../libcs1010/lib respectively. So you compile using the command line: clang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010 Of course if your header and library files are located in another directory that is not ../libcs1010/include and ../libcs1010/lib , you should change the command above accordingly. Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again. For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program. We have also automate this for you for your assignments and exercises using the make command. Reading of a Single Value The CS1010 library supports reading of long value, double value, and strings (both space-separated words and newline-separated lines) from the standard input. For long and double . The relevant methods are: long cs1010_read_long() Returns a long value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid long value -- in which case the value LONG_MAX will be returned. Example: long year = cs1010_read_long (); double cs1010_read_double() Returns a double value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid double value -- in which case the value DBL_MAX will be returned. Example: double cap = cs1010_read_double (); char* cs1010_read_word() Returns a char * pointing to the next white-space-separated string from the standard input. A white-space character is defined based on the standard C function isspace() and includes the space , tab \\t , and newline \\n character. Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . char * word = cs1010_read_word (); // use word to do something : : free ( word ); char* cs1010_read_line() Returns a char * pointing to the next new-line-separated string from the standard input. The string returns from cs1010_read_line() includes the newline character (if one is found). Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . char * line = cs1010_read_line (); // use line to do something : : free ( line ); Reading of Multiple Values The CS1010 library also supports reading of multiple values. long* cs1010_read_long_array(int k) Returns k numbers of long values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid long value -- in which case the value LONG_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . long * values = cs1010_read_long_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } double* cs1010_read_double_array(int k) Returns k numbers of double values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid double value -- in which case the value DBL_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . double * values = cs1010_read_double_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } char** cs1010_read_word_array(int k) Returns k white-space-separated words read from the standard input stored in an array. The notion of \"word\" is the same to cs1010_read_word() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling free . char ** words = cs1010_read_word_array ( 10 ); if ( words != NULL ) { // Do something with array words : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( words [ i ]); } free ( words ); } char** cs1010_read_line_array(int k) Returns k new-line-separated words read from the standard input stored in an array. The notion of line is the same to cs1010_read_line() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling free . char ** lines = cs1010_read_line_array ( 10 ); if ( lines != NULL ) { // Do something with array lines : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( lines [ i ]); } free ( lines ); } Printing of a Single Value The CS1010 library provides a few convenince functions to format and print long and double values to the standard output. void cs1010_print_long(long value) and void cs1010_println_long(long value) Print value to the standard output (with printf format %ld ). The cs1010_println_long version prints a newline after the value. long x ; : cs1010_print_long ( x ); void cs1010_print_double(double value) and void cs1010_println_double(double value) Print value to the standard output (with printf format %.4f ). The cs1010_println_double version prints a newline after the value. double x ; : cs1010_println_double ( x ); void cs1010_print_string(char *str) and void cs1010_println_string(char *str) Print a given string str to the standard output. These functions are provided for completeness and is a simple wrapper around printf(str) and printf(\"%s\\n\", str) repsectively. cs1010_println_string ( \"hello world!\" );","title":"CS1010 I/O"},{"location":"library.html#the-cs1010-io-library","text":"To help students get started with C programming without worrying too much about the details and pitfalls of using printf and scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings. The libraries are pre-installed in CS1010 programming environments , with cs1010.h located under ~cs1010/include and libcs1010.a located under ~cs1010/lib .","title":"The CS1010 I/O Library"},{"location":"library.html#installing-the-library","text":"If you want to install the libraries on your own version of Ubuntu, do the following: To get an updated copy of the library, clone it from its git repo on GitHub with the command: git clone https://github.com/nus-cs1010-1819-s1/libcs1010.git It is recommended you do this in your home directory. You should see an output similar to: Cloning into 'libcs1010'... remote: Counting objects: 6, done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. After that, you should see a subdirectory libcs1010 created in your current directory. Inside, there should be a file called Makefile , and two subdirectories called include and src . To compile the library, run make This should compile the file src/cs1010.c and create a static C library named libcs1010.a under the lib directory.","title":"Installing the Library"},{"location":"library.html#using-the-library","text":"","title":"Using the Library"},{"location":"library.html#header","text":"To use the CS1010 I/O library, you should #include the file cs1010.h , like this: #include \"cs1010.h\" at the top of your C program.","title":"Header"},{"location":"library.html#linking","text":"The CS1010 I/O library is provided as the file libcs1010.a . To link to the library, you need to compile with -lcs1010 . Usually, you need to specify where you can find cs1010.h with the -I flag, and libcs1010.a with the -L flag. Assuming that you are compiling in another subdirectory under your home and libcs1010 are located under your home directory, the header file and the library file are in ../libcs1010/include and ../libcs1010/lib respectively. So you compile using the command line: clang -I../libcs1010/include -L../libcs1010/lib hello.c -lcs1010 Of course if your header and library files are located in another directory that is not ../libcs1010/include and ../libcs1010/lib , you should change the command above accordingly. Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again. For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program. We have also automate this for you for your assignments and exercises using the make command.","title":"Linking"},{"location":"library.html#reading-of-a-single-value","text":"The CS1010 library supports reading of long value, double value, and strings (both space-separated words and newline-separated lines) from the standard input. For long and double . The relevant methods are: long cs1010_read_long() Returns a long value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid long value -- in which case the value LONG_MAX will be returned. Example: long year = cs1010_read_long (); double cs1010_read_double() Returns a double value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid double value -- in which case the value DBL_MAX will be returned. Example: double cap = cs1010_read_double (); char* cs1010_read_word() Returns a char * pointing to the next white-space-separated string from the standard input. A white-space character is defined based on the standard C function isspace() and includes the space , tab \\t , and newline \\n character. Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . char * word = cs1010_read_word (); // use word to do something : : free ( word ); char* cs1010_read_line() Returns a char * pointing to the next new-line-separated string from the standard input. The string returns from cs1010_read_line() includes the newline character (if one is found). Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . char * line = cs1010_read_line (); // use line to do something : : free ( line );","title":"Reading of a Single Value"},{"location":"library.html#reading-of-multiple-values","text":"The CS1010 library also supports reading of multiple values. long* cs1010_read_long_array(int k) Returns k numbers of long values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid long value -- in which case the value LONG_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . long * values = cs1010_read_long_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } double* cs1010_read_double_array(int k) Returns k numbers of double values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid double value -- in which case the value DBL_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . double * values = cs1010_read_double_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } char** cs1010_read_word_array(int k) Returns k white-space-separated words read from the standard input stored in an array. The notion of \"word\" is the same to cs1010_read_word() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling free . char ** words = cs1010_read_word_array ( 10 ); if ( words != NULL ) { // Do something with array words : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( words [ i ]); } free ( words ); } char** cs1010_read_line_array(int k) Returns k new-line-separated words read from the standard input stored in an array. The notion of line is the same to cs1010_read_line() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling free . char ** lines = cs1010_read_line_array ( 10 ); if ( lines != NULL ) { // Do something with array lines : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( lines [ i ]); } free ( lines ); }","title":"Reading of Multiple Values"},{"location":"library.html#printing-of-a-single-value","text":"The CS1010 library provides a few convenince functions to format and print long and double values to the standard output. void cs1010_print_long(long value) and void cs1010_println_long(long value) Print value to the standard output (with printf format %ld ). The cs1010_println_long version prints a newline after the value. long x ; : cs1010_print_long ( x ); void cs1010_print_double(double value) and void cs1010_println_double(double value) Print value to the standard output (with printf format %.4f ). The cs1010_println_double version prints a newline after the value. double x ; : cs1010_println_double ( x ); void cs1010_print_string(char *str) and void cs1010_println_string(char *str) Print a given string str to the standard output. These functions are provided for completeness and is a simple wrapper around printf(str) and printf(\"%s\\n\", str) repsectively. cs1010_println_string ( \"hello world!\" );","title":"Printing of a Single Value"},{"location":"lldb.html","text":"Using LLDB Debugger What is a debugger? A debugger is a tool that allows a programmer to examine the states of the execution of the program, while the program is executing. It allows a programmer to trace through the program step-by-step, examine the flow of the execution and the values of the variables. It is a tremendously valuable and powerful tool to help us trace through our code to understand the behavior and find bugs. In CS1010, we will use lldb , a debugger that comes from the same project as clang . Starting Up LLDB To use lldb , you first make sure that your code is compiled with clang using the flag -g . This should be done for you already if you use the Makefile that we provide you for the assignments and exercises. Then, you invoke lldb with the name of your executable as an argument. For instance, ooiwt@pe113:~$ lldb social (lldb) target create \"social\" Current executable set to 'social' (x86_64). (lldb) You should see the following message, showing the social is loaded as the current executable, and you will be brought to a prompt that says (lldb) . At any time, you can type help on the prompt to see the list of commands, or type help <command-name> to get help for a particular command. As we use lldb , we are going to be bombarded with a lot of information about the internals of the program, so things might seem scary and you might be overwhelmed. But, not too worry. We only need to look for information that is useful to help you debug your program. We can ignore other unnecessary details that lldb provide us. Running the Executable To run the executable, you need to launch the process 1 (lldb) process launch Save on Typing This is too long to type. There are multiple ways to save typing. Using to repeat previous commands is one. The other is to use to autocomplete. You can also just type the prefix -- if it is unique enough, lldb can figure out what you want to do. For instance, the following is the same as process launch since no other commands have the same prefix. (lldb) pr la Launching the process is the same as running the executable on the command line. If the program is reading from standard inputs, you should type in your inputs, after that the executable will run as per normal. If you want to redirect the input from a file (like ./social < inputs/social.1.in ), you will need to pass in the -i flag to process launch : (lldb) process launch -i inputs/social.1.in This will cause the executable to read directly from the given input file. An example output is as follows: (lldb) process launch -i inputs/social.1.in Process 29181 launched: '/home/o/ooiwt/as05-weitsang/social' (x86_64) 1 11 011 NO Process 29181 exited with status = 0 (0x00000000) So far, nothing interesting happens. Running the executable from lldb is the same as running it from bash command line. Setting Breakpoint and Examining States Let's do something more interesting. Suppose that my program is giving us the wrong answer, and I suspect that there is a bug in the function is_friend . I can set a breakpoint . A breakpoint is a particular point in the code where you want to execution to pause. Once the program pauses, you can then examine the state of the program. You can set a breakpoint by specifying the line number or by the function name. To set a breakpoint a function is_friend , I can do the following: ( lldb ) breakpoint set - n is_friend Breakpoint 1 : where = social ` is_friend + 14 at social . c : 13 , address = 0x0000000000400a6e A short form is b is_friend : ( lldb ) b is_friend Breakpoint 1 : where = social ` is_friend + 14 at social . c : 13 , address = 0x0000000000400a6e After setting the breakpoint, if I run the program again, I get (lldb) b is_friend Breakpoint 1: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e (lldb) process launch -i inputs/social.2.in Process 29596 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64) Process 29596 stopped * thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1 frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 10 } 11 12 bool is_friend(char **socnet, int i, int j) { -> 13 if (i >= j) { 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; At this point, the execution has paused, on Line 13 above. We can now examine the state of the program. The line frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 shows the value of the parameters passed into is_friend . socnet is a pointer to a memory location (shown in hexadecimal format). i and j are both zeros. Checking the Value of A Variable (lldb) print i (int) $0 = 0 (lldb) print j (int) $1 = 0 (lldb) print socnet (char **) $2 = 0x0000000000605070 We can use the print (or p ) command to display the value of a variable. In the examples above, I print out the value for i , j , socnet . The type, a temp variable name ( $0 , $1 , etc), and the value of the variable are shown as output. In my program, socnet is the social network. Suppose I want to know what is the value stored in different locations of this matrix, I can do the following: (lldb) p socnet[0][0] (char) $3 = '1' (lldb) p socnet[0][1] (char) $4 = '\\0' (lldb) p socnet[1][1] (char) $5 = '1' (lldb) p socnet[1] (char *) $8 = 0x0000000000605150 \"01\" (lldb) p socnet[3] (char *) $10 = 0x0000000000605210 \"1011\" Checking the Content of the Stack (lldb) bt (lldb) bt * thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1 * frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 frame #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22 frame #2: 0x0000000000400e7d social`main + 301 at social.c:79 frame #3: 0x00007ffff7724830 libc.so.6`__libc_start_main(main=(social`main at social.c:60), argc=1, argv=0x00007fffffffe578, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffe568) + 240 at libc-start.c:291 frame #4: 0x0000000000400949 social`_start + 41 The bt , or backtrace command shows all the call frames on the call stack. frame #0 is the current frame, where the breakpoint is. frame #1 is the function that calls is_friend . You can ignore frame #3 and frame #4 in the example above, as they are relevant to how the OS invokes your executable. So you can see the calls above: main calls expand, which then calls is_friend`. In the example above, we can see that the function expand takes in four parameters. What if I want to example what are these four parameters? Now, I am at the frame is_friend . If I try to print k or degree_k , I will get an error: (lldb) p degree_k error: use of undeclared identifier 'degree_k' error: 1 errors parsing expression To examine the variables of another frame, we can use the up command, to move up the call frame (but, actually, we are moving down the stack). (lldb) up frame #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22 19 void expand(long n, char **socnet, char **degree_k, char **result) { 20 for (int i = 0; i < n; i += 1) { 21 for (int j = 0; j <= i; j += 1) { -> 22 if (is_friend(degree_k, i, j)) { 23 result[i][j] = '1'; 24 } else { 25 bool find_connection = false; This shows us where exactly is is_friend called. And now we can examine the content of socnet in this frame. (lldb) p socnet[0][0] (char) $11 = '1' To easily see what are the variables in the current frame, you can also run the commend (lldb) frame variable (long) n = 4 (char **) socnet = 0x0000000000605040 (char **) degree_k = 0x0000000000605070 (char **) result = 0x00000000006050a0 (int) i = 0 (int) j = 0 To move back to the earlier call frame, you can run down : (lldb) down frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 10 } 11 12 bool is_friend(char **socnet, int i, int j) { -> 13 if (i >= j) { 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; And now we are back in is_friend . Executing the Program Line-by-Line To continue the execution of the program, we can run next (or n ), which cause the execution to continue, in one line: (lldb) n Process 29596 stopped * thread #1: tid = 29596, 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14, name = 'social', stop reason = step over frame #0: 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14 11 12 bool is_friend(char **socnet, int i, int j) { 13 if (i >= j) { -> 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; 17 } So now we see that the control flow actually cause the execution of Line 14 -- that is, it enters the true-block of the if statement. We can keep typing n to continue to trace through the code, line-by-line. If the next command, encounters a function, it will go into the function. Suppose you are not interested in tracing through the code in a particular function, line-by-line, you can use the step command (or s ) to step over a function. The continue command, or c , would cause lldb to continue (unpause) the execution. The execution continues until the next breakpoint is encountered. Pausing with Conditions Conditional Breakpoint Suppose that I now suspect there is a problem with is_friend with j is 2. Setting the breakpoint at is_friend is not going to help much, as it pauses the program every time is_friend is called. Since this is inside a double for loop, it is going to take multiple stops at this breakpoint before I read that state that I am interested in. To get around this, we can set a conditional breakpoint -- a breakpoint that will pause the program, only if the condition is true. The command to do so is as follows: (lldb) b -n is_friend -c 'j == 2' Breakpoint 15: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e This command sets a breakpoint at the function is_friend , but only when the condition j == 2 is true. (lldb) process launch -i inputs/social.2.in Process 30796 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64) Process 30796 stopped * thread #1: tid = 30796, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13, name = 'social', stop reason = breakpoint 15.1 frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13 10 } 11 12 bool is_friend(char **socnet, int i, int j) { -> 13 if (i >= j) { 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; Now, when we run the program, the breakpoint is_friend is triggered only when the value of j is 2. A process is the technical term for a running application -- it is more complicated than this, but this intuition will do for now. You will learn what a process is in your OS module. \u21a9","title":"LLDB"},{"location":"lldb.html#using-lldb-debugger","text":"","title":"Using LLDB Debugger"},{"location":"lldb.html#what-is-a-debugger","text":"A debugger is a tool that allows a programmer to examine the states of the execution of the program, while the program is executing. It allows a programmer to trace through the program step-by-step, examine the flow of the execution and the values of the variables. It is a tremendously valuable and powerful tool to help us trace through our code to understand the behavior and find bugs. In CS1010, we will use lldb , a debugger that comes from the same project as clang .","title":"What is a debugger?"},{"location":"lldb.html#starting-up-lldb","text":"To use lldb , you first make sure that your code is compiled with clang using the flag -g . This should be done for you already if you use the Makefile that we provide you for the assignments and exercises. Then, you invoke lldb with the name of your executable as an argument. For instance, ooiwt@pe113:~$ lldb social (lldb) target create \"social\" Current executable set to 'social' (x86_64). (lldb) You should see the following message, showing the social is loaded as the current executable, and you will be brought to a prompt that says (lldb) . At any time, you can type help on the prompt to see the list of commands, or type help <command-name> to get help for a particular command. As we use lldb , we are going to be bombarded with a lot of information about the internals of the program, so things might seem scary and you might be overwhelmed. But, not too worry. We only need to look for information that is useful to help you debug your program. We can ignore other unnecessary details that lldb provide us.","title":"Starting Up LLDB"},{"location":"lldb.html#running-the-executable","text":"To run the executable, you need to launch the process 1 (lldb) process launch Save on Typing This is too long to type. There are multiple ways to save typing. Using to repeat previous commands is one. The other is to use to autocomplete. You can also just type the prefix -- if it is unique enough, lldb can figure out what you want to do. For instance, the following is the same as process launch since no other commands have the same prefix. (lldb) pr la Launching the process is the same as running the executable on the command line. If the program is reading from standard inputs, you should type in your inputs, after that the executable will run as per normal. If you want to redirect the input from a file (like ./social < inputs/social.1.in ), you will need to pass in the -i flag to process launch : (lldb) process launch -i inputs/social.1.in This will cause the executable to read directly from the given input file. An example output is as follows: (lldb) process launch -i inputs/social.1.in Process 29181 launched: '/home/o/ooiwt/as05-weitsang/social' (x86_64) 1 11 011 NO Process 29181 exited with status = 0 (0x00000000) So far, nothing interesting happens. Running the executable from lldb is the same as running it from bash command line.","title":"Running the Executable"},{"location":"lldb.html#setting-breakpoint-and-examining-states","text":"Let's do something more interesting. Suppose that my program is giving us the wrong answer, and I suspect that there is a bug in the function is_friend . I can set a breakpoint . A breakpoint is a particular point in the code where you want to execution to pause. Once the program pauses, you can then examine the state of the program. You can set a breakpoint by specifying the line number or by the function name. To set a breakpoint a function is_friend , I can do the following: ( lldb ) breakpoint set - n is_friend Breakpoint 1 : where = social ` is_friend + 14 at social . c : 13 , address = 0x0000000000400a6e A short form is b is_friend : ( lldb ) b is_friend Breakpoint 1 : where = social ` is_friend + 14 at social . c : 13 , address = 0x0000000000400a6e After setting the breakpoint, if I run the program again, I get (lldb) b is_friend Breakpoint 1: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e (lldb) process launch -i inputs/social.2.in Process 29596 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64) Process 29596 stopped * thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1 frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 10 } 11 12 bool is_friend(char **socnet, int i, int j) { -> 13 if (i >= j) { 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; At this point, the execution has paused, on Line 13 above. We can now examine the state of the program. The line frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 shows the value of the parameters passed into is_friend . socnet is a pointer to a memory location (shown in hexadecimal format). i and j are both zeros.","title":"Setting Breakpoint and Examining States"},{"location":"lldb.html#checking-the-value-of-a-variable","text":"(lldb) print i (int) $0 = 0 (lldb) print j (int) $1 = 0 (lldb) print socnet (char **) $2 = 0x0000000000605070 We can use the print (or p ) command to display the value of a variable. In the examples above, I print out the value for i , j , socnet . The type, a temp variable name ( $0 , $1 , etc), and the value of the variable are shown as output. In my program, socnet is the social network. Suppose I want to know what is the value stored in different locations of this matrix, I can do the following: (lldb) p socnet[0][0] (char) $3 = '1' (lldb) p socnet[0][1] (char) $4 = '\\0' (lldb) p socnet[1][1] (char) $5 = '1' (lldb) p socnet[1] (char *) $8 = 0x0000000000605150 \"01\" (lldb) p socnet[3] (char *) $10 = 0x0000000000605210 \"1011\"","title":"Checking the Value of A Variable"},{"location":"lldb.html#checking-the-content-of-the-stack","text":"(lldb) bt (lldb) bt * thread #1: tid = 29596, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13, name = 'social', stop reason = breakpoint 1.1 * frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 frame #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22 frame #2: 0x0000000000400e7d social`main + 301 at social.c:79 frame #3: 0x00007ffff7724830 libc.so.6`__libc_start_main(main=(social`main at social.c:60), argc=1, argv=0x00007fffffffe578, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffe568) + 240 at libc-start.c:291 frame #4: 0x0000000000400949 social`_start + 41 The bt , or backtrace command shows all the call frames on the call stack. frame #0 is the current frame, where the breakpoint is. frame #1 is the function that calls is_friend . You can ignore frame #3 and frame #4 in the example above, as they are relevant to how the OS invokes your executable. So you can see the calls above: main calls expand, which then calls is_friend`. In the example above, we can see that the function expand takes in four parameters. What if I want to example what are these four parameters? Now, I am at the frame is_friend . If I try to print k or degree_k , I will get an error: (lldb) p degree_k error: use of undeclared identifier 'degree_k' error: 1 errors parsing expression To examine the variables of another frame, we can use the up command, to move up the call frame (but, actually, we are moving down the stack). (lldb) up frame #1: 0x0000000000400b1f social`expand(n=4, socnet=0x0000000000605040, degree_k=0x0000000000605070, result=0x00000000006050a0) + 79 at social.c:22 19 void expand(long n, char **socnet, char **degree_k, char **result) { 20 for (int i = 0; i < n; i += 1) { 21 for (int j = 0; j <= i; j += 1) { -> 22 if (is_friend(degree_k, i, j)) { 23 result[i][j] = '1'; 24 } else { 25 bool find_connection = false; This shows us where exactly is is_friend called. And now we can examine the content of socnet in this frame. (lldb) p socnet[0][0] (char) $11 = '1' To easily see what are the variables in the current frame, you can also run the commend (lldb) frame variable (long) n = 4 (char **) socnet = 0x0000000000605040 (char **) degree_k = 0x0000000000605070 (char **) result = 0x00000000006050a0 (int) i = 0 (int) j = 0 To move back to the earlier call frame, you can run down : (lldb) down frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 14 at social.c:13 10 } 11 12 bool is_friend(char **socnet, int i, int j) { -> 13 if (i >= j) { 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; And now we are back in is_friend .","title":"Checking the Content of the Stack"},{"location":"lldb.html#executing-the-program-line-by-line","text":"To continue the execution of the program, we can run next (or n ), which cause the execution to continue, in one line: (lldb) n Process 29596 stopped * thread #1: tid = 29596, 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14, name = 'social', stop reason = step over frame #0: 0x0000000000400a7a social`is_friend(socnet=0x0000000000605070, i=0, j=0) + 26 at social.c:14 11 12 bool is_friend(char **socnet, int i, int j) { 13 if (i >= j) { -> 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; 17 } So now we see that the control flow actually cause the execution of Line 14 -- that is, it enters the true-block of the if statement. We can keep typing n to continue to trace through the code, line-by-line. If the next command, encounters a function, it will go into the function. Suppose you are not interested in tracing through the code in a particular function, line-by-line, you can use the step command (or s ) to step over a function. The continue command, or c , would cause lldb to continue (unpause) the execution. The execution continues until the next breakpoint is encountered.","title":"Executing the Program Line-by-Line"},{"location":"lldb.html#pausing-with-conditions","text":"","title":"Pausing with Conditions"},{"location":"lldb.html#conditional-breakpoint","text":"Suppose that I now suspect there is a problem with is_friend with j is 2. Setting the breakpoint at is_friend is not going to help much, as it pauses the program every time is_friend is called. Since this is inside a double for loop, it is going to take multiple stops at this breakpoint before I read that state that I am interested in. To get around this, we can set a conditional breakpoint -- a breakpoint that will pause the program, only if the condition is true. The command to do so is as follows: (lldb) b -n is_friend -c 'j == 2' Breakpoint 15: where = social`is_friend + 14 at social.c:13, address = 0x0000000000400a6e This command sets a breakpoint at the function is_friend , but only when the condition j == 2 is true. (lldb) process launch -i inputs/social.2.in Process 30796 launched: '/home/vagrant/cs1010/as05-solution/social' (x86_64) Process 30796 stopped * thread #1: tid = 30796, 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13, name = 'social', stop reason = breakpoint 15.1 frame #0: 0x0000000000400a6e social`is_friend(socnet=0x0000000000605040, i=1, j=2) + 14 at social.c:13 10 } 11 12 bool is_friend(char **socnet, int i, int j) { -> 13 if (i >= j) { 14 return socnet[i][j] == '1'; 15 } 16 return socnet[j][i] == '1'; Now, when we run the program, the breakpoint is_friend is triggered only when the value of j is 2. A process is the technical term for a running application -- it is more complicated than this, but this intuition will do for now. You will learn what a process is in your OS module. \u21a9","title":"Conditional Breakpoint"},{"location":"midterm.html","text":"Midterm Question, Solution, Marking Scheme Important Information Date: 2 October, 2018 (Tuesday) Time: 4pm to 6pm Venue: MPSH 1 (Section B) Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 MCQs and Short Structured Questions Duration: 90 minutes Open Book (You can bring analog references) Calculator is allowed (although you do not need it) Seating Arrangement Name Seat Number AARUSHI SINGH 76 AHMAD MUDAAFI' B ZAINUDDIN 77 AI ZHENGWEI 78 ALEX TEO KANG JIE 79 AMIR AZHAR B AZIZAN 80 ANDREW LAU JIA JUN 81 ANG KENG SIANG 82 ANG KIANG YANG 83 AW CHIAN HAO 84 BALAM SAI ROHIT REDDY 85 BEATRICE CHAN TONG 86 BENEDICT YU CHENG EN 87 BENJAMIN CHIA SHAN HONG 88 BRANSON LEE JUN XIAN 89 CAI RONG 90 CHAN EE ZHENG, BENJAMIN 91 CHAN HIN, SEAN 92 CHAN WEI FONG, MAX 93 CHAN YEE CHONG PHILIP 94 CHAN YEW CHUN DANIEL 95 CHAN ZHI ZHENG, AMOS 96 CHANG HUI ZHEN 97 CHANG ZHONG KAI 98 CHEN CHAO 99 CHEN TONG 100 CHENG LE DA, CLEMENT 101 CHENG WANYIN 102 CHENG WEIXUAN 103 CHERYL NG YUN LIN 104 CHEW JUN KONG 105 CHIA BIING HANN 106 CHNG XIAN YI 107 CHOI WONJAE 108 CHU JUI HUNG @JEFFERSON CHU 109 CHUA MAI FENG, CARL 110 CHUA WEN XUAN 111 CHUA ZONG WEI 112 CLAIRE CHAN YEN HWA 113 CYNTHIA LEE WENG YAN 114 DANIEL TAN WEE LIANG 115 DANISH B EDDIE 116 DARREN ONG 117 DEBBIE TAN JIA MIN 118 DING NING 119 DIVAKARAN HARITHA 120 EDMUND TEO WEI XIN 121 EU JING SEN 122 EVELYN YI-WEN CHEN 123 FATIN NABILAH BTE SUHAIMI 124 FOO CHI HEN 125 GINA QUAH JIE XI 126 GLEN WONG SHU ZE 127 GOH RUI PING SAMANTHA 128 GOH ZHEN HAO JOEY 129 GONDHALEKAR SUKRUT YOGESH 130 GREGORY TAN WEI YUAN 131 GUI XIXIAN 132 GUO HAOREN 133 HANS KURNIA WIDJAJA 134 HAO YUN 135 HASHIR ZAHIR 136 HENG HONG CHUAN 137 HO JING YANG DANIEL 138 HO SI SHI ANNETTE 139 HO WEI BIN, JERRY 140 HU XINYING 141 HUANG XUANKUN 142 IAN CHUA 143 ISABELLA CHEONG XIAO XUAN 144 IVAN ANDIKA LIE 145 JANEL ANG YEE HUEY 146 JASON SATHYA CITRO 147 JASPER ONG SHAO YONG 148 JAZHTEN LOW YONGSHEN 149 JERRY ZHANG ZHUORAN 150 JESS TEO XI ZHI 151 JOEL CHANG ZHI KAI 152 JOHN CUTHBERT KHOO TENG FONG 153 JOSEPH WONG YEFENG 154 JUSTIN CHIA JIA JIN 155 K ALAGES 156 KARAN SARAT 157 KARNATI SAI ABHISHEK 158 KEE KAH LOK 159 KEITH CHAN JUN KAI 160 KELVIN HARRIS 161 KEVIN PUTERA 162 KEZIA KEW KAI YUN 163 KHAIRUL IMAN NASRI B AZHARIE 164 KHOO TZE YANG RAYSON 165 KISHORE R 166 KWOK KUIN EK JEREMY 167 KYAWT KYAWT SAN 168 LAI WEN XUAN JEREMY 169 LAM TIAN WEI JUSTIN 170 LE HONG LONG 171 LEE HONG CHIEN, KENNETH 172 LEE LI XIN 173 LEE RAIYAN BIN ZULKIFLI 174 LEE WEI HERN, JASON 175 LEE YUEYU 176 LEE ZHEN YU 177 LEOW YONG HENG 178 LEOW YONG KANG ANDREW 179 LI JIAYU 180 LI ZIHAN 181 LIAO LIXIN 182 LIAO TIANCHANG 183 LIM CHEE SENG BRIAN 184 LIM CHEK JUN 185 LIM CHENG YIN, RYAN 186 LIM HAO XIANG, SEAN 187 LIM JIA WEI 188 LIM JIAYI, TAMELLY 189 LIM JUN KUANG, LIONEL 190 LIM LI LINCOLN 191 LIM SI YING 192 LIM TING WEI 193 LIM WEN HAN, EUGENE 194 LIM YAN TING 195 LIN JIAYUE 196 LING WEN JIAN 197 LIU JINGXUAN 198 LIU PEIZE 199 LIU SHIRU 200 LIU SONGTAO 201 LIU WEI JIE NICHOLAS 202 LOH CHING WEI, JOSHUA 203 LOH YONG ZEE 204 LOW EE TER 205 LOW JIA YEE 206 LOW SIU YUAN, FRANCIS 207 LUCAS FOO SOO QUAN 208 LYE JUN WEI ANANDA 209 MARC PHUA HSIAO MENG 210 MATTHEW NATHANAEL SUGIRI 211 MERVIN WEE MINGWEN 212 MICHELLE TOH HUI PING 213 MODAK SHANTANU BHARAT 214 MOHAMED RIYAS 215 MOHAMMAD YOUSUF MINHAJ ZIA 216 MUHAMMAD FAIRUZ B AMIRHAMZAH 217 MUHAMMAD HOZEFA ZUMKHAWALA 218 MUHAMMAD SHOLIHIN BIN KAMARUDIN 219 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN 220 Name 221 NATHAN YEO KEE HERN 222 NEO WEN HUI 223 NG JIE WU 224 NG JING KANG 225 NG JING KIAT 226 NG SHI QI, CARRIE 227 NG SIU HIAN 228 NG WEE KIAT 229 NG WEI JIE, BRANDON 230 NG ZI HUI 231 NGAN JI CHENG 232 NGUYEN THANH DUC 233 NGUYEN TIEN DAT 234 NIGEL TAN 235 NIGELLE LEO YUWEN 236 NISHANTH ELANGO 237 NYAN WUN PAING 238 OEI CHIU YAN REBECCA 239 ONG YU XUAN 240 OUNG YONG SHENG KENNEDY 241 OW ZHENG KUAN 242 P PRADEEP 243 PANG JIA JUN VERNON 244 PARK SO HYUN 245 PARMAR VARUN SAMIR 246 PARVATHI RANJITH MENON 247 PATWARI RISHAB 248 PEI YAN BO 249 PHOON JIA JUIN 250 POH CHOO LEONG, LINSTON 251 PONG LOONG BOB 252 POON KAH ONN, BENJAMIN 253 POW JING YONG 254 QIAN JIE 255 QUAH YOU JING KANE 256 QUEK AIK PENG 257 RAGHAV BHARDWAJ 258 RAJAMOHAN B PRIYAN 259 RAVEENDRAN AJEY ASHOK 260 RISHI MAHADEVAN 261 RUSDI HAIZIM B RAHIM 262 RYAN TAN YU 263 SAI GANESH SURESH 264 SCOTT FLOYD ZHEN-YAN SMAHON 265 SEE SHENG CHAO 266 SENTHIL ARAAVIND 267 SHA LONG 268 SHANNON LEE 269 SHAWN WONG JUN KIT 270 SHRIYA SAXENA 271 SIM YU JIE 272 SITI NADIAH BINTE MOHAMED RAMLI 273 SUTHER DAVID SAMUEL 274 TALAGADADIVI DURGA RUKMINI MANASWINI 275 TAM WEI IAN JOSHUA 276 TAN GUAN YEW 277 TAN KAI LI CATHERINE 278 TAN KOK JOON 279 TAN LI ANN PETER 280 TAN YEH HAN, JOHN 281 TAN YI XIANG 282 TAN ZHENG FU JUSTIN 283 TAN ZHENG WEN 284 TAY JIN WEN 285 TAY JING XUAN 286 TAY TZE-WEI, CALEB 287 TAY YEE EN, RYAN 288 TEH ZI HUAI 289 TEO WEI JIE, SHAUN 290 TOH YING YING JANICE 291 TONG QI WEI 292 TRAN MINH DUONG 293 TRAN QUANG THANH 294 TSHIN QI REN 295 UMAR BIN MOIZ 296 VASAVADA TEJAS SUDHIR 297 VIDHYABHARATHI SOMASUNDARAM 298 VIVIAN LEE BOON GEOK 299 WANG ZICONG 300 WEI FENG 301 WENG KEXIN 302 WONG JIN EN, SHANNON 303 WONG REN-WEI, RYAN 304 XUE ZHENGQING 305 YANG AN QI 306 YANG CHENGLONG 307 YANG KAI ZE 308 YANG ZI YUN 309 YAP JIN FA 310 YAP KESIN 311 YE GUOQUAN 312 YE TONG 313 YEN PEI CHIH 314 YEW JING HUI 315 YU XIAOXUE 316 YUAN JIAYI 317 YUE JUN YI 318 ZHANG SHIYU 319 ZHANG YIHAN 320 ZHANG YIPING 321 ZHANG YUE HAN 322 ZHAO PENGFEI 323 ZHAO TIANQI 324 ZHENG KAINING 325 ZHU BO 326 ZHU YIJIE 327 ZOE WONG XIN LEI 328","title":"Midterm"},{"location":"midterm.html#midterm","text":"","title":"Midterm"},{"location":"midterm.html#question-solution-marking-scheme","text":"","title":"Question, Solution, Marking Scheme"},{"location":"midterm.html#important-information","text":"Date: 2 October, 2018 (Tuesday) Time: 4pm to 6pm Venue: MPSH 1 (Section B) Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 MCQs and Short Structured Questions Duration: 90 minutes Open Book (You can bring analog references) Calculator is allowed (although you do not need it)","title":"Important Information"},{"location":"midterm.html#seating-arrangement","text":"Name Seat Number AARUSHI SINGH 76 AHMAD MUDAAFI' B ZAINUDDIN 77 AI ZHENGWEI 78 ALEX TEO KANG JIE 79 AMIR AZHAR B AZIZAN 80 ANDREW LAU JIA JUN 81 ANG KENG SIANG 82 ANG KIANG YANG 83 AW CHIAN HAO 84 BALAM SAI ROHIT REDDY 85 BEATRICE CHAN TONG 86 BENEDICT YU CHENG EN 87 BENJAMIN CHIA SHAN HONG 88 BRANSON LEE JUN XIAN 89 CAI RONG 90 CHAN EE ZHENG, BENJAMIN 91 CHAN HIN, SEAN 92 CHAN WEI FONG, MAX 93 CHAN YEE CHONG PHILIP 94 CHAN YEW CHUN DANIEL 95 CHAN ZHI ZHENG, AMOS 96 CHANG HUI ZHEN 97 CHANG ZHONG KAI 98 CHEN CHAO 99 CHEN TONG 100 CHENG LE DA, CLEMENT 101 CHENG WANYIN 102 CHENG WEIXUAN 103 CHERYL NG YUN LIN 104 CHEW JUN KONG 105 CHIA BIING HANN 106 CHNG XIAN YI 107 CHOI WONJAE 108 CHU JUI HUNG @JEFFERSON CHU 109 CHUA MAI FENG, CARL 110 CHUA WEN XUAN 111 CHUA ZONG WEI 112 CLAIRE CHAN YEN HWA 113 CYNTHIA LEE WENG YAN 114 DANIEL TAN WEE LIANG 115 DANISH B EDDIE 116 DARREN ONG 117 DEBBIE TAN JIA MIN 118 DING NING 119 DIVAKARAN HARITHA 120 EDMUND TEO WEI XIN 121 EU JING SEN 122 EVELYN YI-WEN CHEN 123 FATIN NABILAH BTE SUHAIMI 124 FOO CHI HEN 125 GINA QUAH JIE XI 126 GLEN WONG SHU ZE 127 GOH RUI PING SAMANTHA 128 GOH ZHEN HAO JOEY 129 GONDHALEKAR SUKRUT YOGESH 130 GREGORY TAN WEI YUAN 131 GUI XIXIAN 132 GUO HAOREN 133 HANS KURNIA WIDJAJA 134 HAO YUN 135 HASHIR ZAHIR 136 HENG HONG CHUAN 137 HO JING YANG DANIEL 138 HO SI SHI ANNETTE 139 HO WEI BIN, JERRY 140 HU XINYING 141 HUANG XUANKUN 142 IAN CHUA 143 ISABELLA CHEONG XIAO XUAN 144 IVAN ANDIKA LIE 145 JANEL ANG YEE HUEY 146 JASON SATHYA CITRO 147 JASPER ONG SHAO YONG 148 JAZHTEN LOW YONGSHEN 149 JERRY ZHANG ZHUORAN 150 JESS TEO XI ZHI 151 JOEL CHANG ZHI KAI 152 JOHN CUTHBERT KHOO TENG FONG 153 JOSEPH WONG YEFENG 154 JUSTIN CHIA JIA JIN 155 K ALAGES 156 KARAN SARAT 157 KARNATI SAI ABHISHEK 158 KEE KAH LOK 159 KEITH CHAN JUN KAI 160 KELVIN HARRIS 161 KEVIN PUTERA 162 KEZIA KEW KAI YUN 163 KHAIRUL IMAN NASRI B AZHARIE 164 KHOO TZE YANG RAYSON 165 KISHORE R 166 KWOK KUIN EK JEREMY 167 KYAWT KYAWT SAN 168 LAI WEN XUAN JEREMY 169 LAM TIAN WEI JUSTIN 170 LE HONG LONG 171 LEE HONG CHIEN, KENNETH 172 LEE LI XIN 173 LEE RAIYAN BIN ZULKIFLI 174 LEE WEI HERN, JASON 175 LEE YUEYU 176 LEE ZHEN YU 177 LEOW YONG HENG 178 LEOW YONG KANG ANDREW 179 LI JIAYU 180 LI ZIHAN 181 LIAO LIXIN 182 LIAO TIANCHANG 183 LIM CHEE SENG BRIAN 184 LIM CHEK JUN 185 LIM CHENG YIN, RYAN 186 LIM HAO XIANG, SEAN 187 LIM JIA WEI 188 LIM JIAYI, TAMELLY 189 LIM JUN KUANG, LIONEL 190 LIM LI LINCOLN 191 LIM SI YING 192 LIM TING WEI 193 LIM WEN HAN, EUGENE 194 LIM YAN TING 195 LIN JIAYUE 196 LING WEN JIAN 197 LIU JINGXUAN 198 LIU PEIZE 199 LIU SHIRU 200 LIU SONGTAO 201 LIU WEI JIE NICHOLAS 202 LOH CHING WEI, JOSHUA 203 LOH YONG ZEE 204 LOW EE TER 205 LOW JIA YEE 206 LOW SIU YUAN, FRANCIS 207 LUCAS FOO SOO QUAN 208 LYE JUN WEI ANANDA 209 MARC PHUA HSIAO MENG 210 MATTHEW NATHANAEL SUGIRI 211 MERVIN WEE MINGWEN 212 MICHELLE TOH HUI PING 213 MODAK SHANTANU BHARAT 214 MOHAMED RIYAS 215 MOHAMMAD YOUSUF MINHAJ ZIA 216 MUHAMMAD FAIRUZ B AMIRHAMZAH 217 MUHAMMAD HOZEFA ZUMKHAWALA 218 MUHAMMAD SHOLIHIN BIN KAMARUDIN 219 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN 220 Name 221 NATHAN YEO KEE HERN 222 NEO WEN HUI 223 NG JIE WU 224 NG JING KANG 225 NG JING KIAT 226 NG SHI QI, CARRIE 227 NG SIU HIAN 228 NG WEE KIAT 229 NG WEI JIE, BRANDON 230 NG ZI HUI 231 NGAN JI CHENG 232 NGUYEN THANH DUC 233 NGUYEN TIEN DAT 234 NIGEL TAN 235 NIGELLE LEO YUWEN 236 NISHANTH ELANGO 237 NYAN WUN PAING 238 OEI CHIU YAN REBECCA 239 ONG YU XUAN 240 OUNG YONG SHENG KENNEDY 241 OW ZHENG KUAN 242 P PRADEEP 243 PANG JIA JUN VERNON 244 PARK SO HYUN 245 PARMAR VARUN SAMIR 246 PARVATHI RANJITH MENON 247 PATWARI RISHAB 248 PEI YAN BO 249 PHOON JIA JUIN 250 POH CHOO LEONG, LINSTON 251 PONG LOONG BOB 252 POON KAH ONN, BENJAMIN 253 POW JING YONG 254 QIAN JIE 255 QUAH YOU JING KANE 256 QUEK AIK PENG 257 RAGHAV BHARDWAJ 258 RAJAMOHAN B PRIYAN 259 RAVEENDRAN AJEY ASHOK 260 RISHI MAHADEVAN 261 RUSDI HAIZIM B RAHIM 262 RYAN TAN YU 263 SAI GANESH SURESH 264 SCOTT FLOYD ZHEN-YAN SMAHON 265 SEE SHENG CHAO 266 SENTHIL ARAAVIND 267 SHA LONG 268 SHANNON LEE 269 SHAWN WONG JUN KIT 270 SHRIYA SAXENA 271 SIM YU JIE 272 SITI NADIAH BINTE MOHAMED RAMLI 273 SUTHER DAVID SAMUEL 274 TALAGADADIVI DURGA RUKMINI MANASWINI 275 TAM WEI IAN JOSHUA 276 TAN GUAN YEW 277 TAN KAI LI CATHERINE 278 TAN KOK JOON 279 TAN LI ANN PETER 280 TAN YEH HAN, JOHN 281 TAN YI XIANG 282 TAN ZHENG FU JUSTIN 283 TAN ZHENG WEN 284 TAY JIN WEN 285 TAY JING XUAN 286 TAY TZE-WEI, CALEB 287 TAY YEE EN, RYAN 288 TEH ZI HUAI 289 TEO WEI JIE, SHAUN 290 TOH YING YING JANICE 291 TONG QI WEI 292 TRAN MINH DUONG 293 TRAN QUANG THANH 294 TSHIN QI REN 295 UMAR BIN MOIZ 296 VASAVADA TEJAS SUDHIR 297 VIDHYABHARATHI SOMASUNDARAM 298 VIVIAN LEE BOON GEOK 299 WANG ZICONG 300 WEI FENG 301 WENG KEXIN 302 WONG JIN EN, SHANNON 303 WONG REN-WEI, RYAN 304 XUE ZHENGQING 305 YANG AN QI 306 YANG CHENGLONG 307 YANG KAI ZE 308 YANG ZI YUN 309 YAP JIN FA 310 YAP KESIN 311 YE GUOQUAN 312 YE TONG 313 YEN PEI CHIH 314 YEW JING HUI 315 YU XIAOXUE 316 YUAN JIAYI 317 YUE JUN YI 318 ZHANG SHIYU 319 ZHANG YIHAN 320 ZHANG YIPING 321 ZHANG YUE HAN 322 ZHAO PENGFEI 323 ZHAO TIANQI 324 ZHENG KAINING 325 ZHU BO 326 ZHU YIJIE 327 ZOE WONG XIN LEI 328","title":"Seating Arrangement"},{"location":"outcomes.html","text":"After taking CS1010, students should be familiar with fundamental programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures); be familiar with and appreciate good programming practice, and apply it to follow-up courses; be able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs; be able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course; know the responsibilities of an ethical programmer; be able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs; be able to manually trace through a program to identify logical errors; be able to differentiate between logical errors, syntax errors, and run-time errors; be exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions; know about what are some insecure functions to avoid; be able to generate test cases on their own, with a focus on boundary/special cases; be able to debug with printf or equivalent functions; be aware of common strategies and good practices of debugging with printf or equivalent functions; be able to identify opportunities to, and write, modularized code; be exposed to a debugger; be able to write code following good programming style (clear comments, naming convention, indentation, etc.); understand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits; develop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc). For interpreted language, understand the role of virtual machine/interpreter; be able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable; understand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties); be able to implement bubble sort and insertion sort; be able to implement linear search and binary search (both iterative and recursive versions);","title":"Learning Outcomes"},{"location":"pe1-comments.html","text":"PE1: Comments and Answer Keys vote Comments This is supposed to be a very easy, \"give-away\" question, but only 60% of students get full marks for this question. Common mistakes include: Using the wrong type . Some students read integer values as double or read long as long long . These do not affect the correctness but it does not demonstrate that the students understand the differences between the different types. There is a -0.5 penalty for each one. A more serious error involves using int for the number of votes (-1) or long for the percentage (-1). Integer division . Some students used integer division when calculating the percentage. For instance: double percentage = ( m / ( m + n )) * 100.0 ; The computation of m/(m+n) is done entirely as long integer. You need to either cast m or n to double, or multiple 100.0 (a double) earlier: double percentage = ( m * 100.0 / ( m + n )); Redundant Cast . Some studnets do not understand the needs for casting and simply cast everything: double percentage = (( double ) m * ( double ) 100.0 / (( double ) m + ( double ) n )); I decided not to deduct marks for this, but this is not the right way to write an arithmetic expression! Redundant Functions . Some students wrote something like this: double percentage_of_nixon ( long nixon , long total ) { return nixon * 100.0 / total ; } double percentage_of_mcneal ( long mcneal , long total ) { return mcneal * 100.0 / total ; } This shows that students do not understand that functions are supposed to be reusable that there is only one function needed. There is a -1 penalty for that. Misc. Some students made simple mistakes like printing the numbers without a space in between or print the two numbers on different lines (-0.5), or didn't include the right headers (-1). Solution #include \"cs1010.h\" int main () { long mcneal = cs1010_read_long (); long nixon = cs1010_read_long (); long total = mcneal + nixon ; cs1010_print_double ( mcneal * 100.0 / total ); cs1010_print_string ( \" \" ); cs1010_println_double ( nixon * 100.0 / total ); } newton Comments Newton is another easy question that surprisingly many students are struggling with. Needless Careless Mistakes Many students wrote down the wrong formula for f(x) f(x) or f'(x) f'(x) , which I deduct 1 marks after a facepalm. Wrong Type Quite a few students read the inputs as long instead of double . There is a 1 mark deduction for this. A few students used float instead of double . As I have mentioned, you should never touch float at all, since its precision is lame low. If you use float , you would not get the correct answer for some of the test cases due to floating point errors. There is a 0.5 mark deduction for using float instead of double . Uninitialized Variable There are also a number of students who got the following bugs: double root ; while ( fabs ( f ( a , b , c , d , x )) >= 0.000000001 ) { : } return root ; Suppose that the initial guess x is already close enough to the root, the loop is never entered, and the function returns root uninitialized. The lesson here is that always make sure you cover all possible cases. Also, please think about what variables do you really need to solve a problem. In this question, you do not any extra variable -- so root is completely unnecessary. The more variable you used, the more complex your code get, the more likely you introduce bugs into your code, as shown in the example above. Terminating Conditions Another common mistake is the terminating conditions. A handful of you wrote something like this: while ( fabs ( f ( a , b , c , d , x ) >= 0.000000001 )) { Here, the code tries to pass a true or false expression to fabs , which the compiler warns. A few of you, instead of fixing the parenthesis, change fabs to abs instead to silence the compiler >.< Other mistakes include not setting the right threshold (some uses 0.001, or 0.00001 -- why oh why?) or use the wrong comparison: while ( fabs ( f ( a , b , c , d , x ) < 0.000000001 )) { Some did not use fabs at all: while ( f ( a , b , c , d , x ) >= 0.000000001 ) { Some checked if the root is small enough, instead of the value of function is small enough: while ( fabs ( x ) >= 0.000000001 ) { A small number of students hardcoded the number of steps (e.g., always loop 4 times), which works for the sample but not for the general cases. There is a one mark deduction for all errors related to terminating conditions. One strange thing some of you do is to use a for loop for this question: for ( long i = 0 ; fabs ( x ) >= 0.000000001 ; i += 1 ) The loop still terminates correctly, but the variable i is entirely useless. No marks are deducted but I should have for not demonstrating that you know which loop to use. Use of pow() I did not deduct marks for this -- but using pow for squaring and cubing is an overkill. pow is a general function that works even for floating point exponentiation. So it is slower. Some of you even wrote pow(x, 1) and pow(x, 0) . Marks would have been deducted if efficiency is a criterion. Answer #include \"cs1010.h\" #include <math.h> double f ( double a , double b , double c , double d , double x ) { return a * x * x * x + b * x * x + c * x + d ; } double fp ( double a , double b , double c , double x ) { return 3 * a * x * x + 2 * b * x + c ; } double find_root ( double a , double b , double c , double d , double x ) { double fx = f ( a , b , c , d , x ); while ( fabs ( fx ) >= 0.000000001 ) { double fpx = fp ( a , b , c , x ); x -= fx / fpx ; fx = f ( a , b , c , d , x ); } return x ; } int main () { double a = cs1010_read_double (); double b = cs1010_read_double (); double c = cs1010_read_double (); double d = cs1010_read_double (); double x = cs1010_read_double (); x = find_root ( a , b , c , d , x ); cs1010_println_double ( x ); } Goldbach Comments This question is a little bit more tricky than newton , but not much. Checking For Prime The disappointing thing is that, even though you have gone through an exercise and an assignment that involves checking if a number is prime, with the solution given comparing different approaches, many of you still wrote the wrong function for checking prime, uses the wrong type, or wrote the slow version. Since I deducted one mark for each bug, an incorrect is_prime might cost you 1-3 marks. This is entirely unnecessary >.< Try to see if you can spot the bugs and why it fails in each of the following. This is a good exam question that I might ask in a future semester -- don't tell your junior shush . bool is_prime ( long n ) { for ( long i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } bool is_prime ( long n ) { for ( long i = 2 ; i < sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } bool is_prime ( long n ) { for ( long i = 2 ; i <= ceil ( sqrt ( n )); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } else { return true ; } } } Another common mistake related to checking of prime is that the function should return a bool (since a number is either a prime or not). Some students returned an integer from this function. I deducted one mark for not demonstrating an understanding of boolean functions. Unnecessary Loops This is another strange but common code that you have written. I did not deduct marks since efficiency is not a criterion for PE1 -- but I am puzzled why you write code like this. Let's say I ask you this question: 31 plus what equals to 100? Any primary school students can tell you, take 100, subtract 31, you get 69. So 31 + 69 = 100. This is not many of you do to find the answer. What you do is equivalent to: for ( j = 1 ; j <= 100 ; j += 1 ) { if ( 31 + j == 100 ) { cs1010_println_long ( j ); } } Essentially, checking is 31 + 1 equal to 100? is 31 + 2 equals to 100? etc. until you find an answer. After that, you continue to check, is 31 + 70 equals to 100? is 31 + 71 equal to 100? and so on. This is just silly >.< In the context of goldbach , the code you wrote is: for ( long i = 0 ; i <= n / 2 ; i += 1 ) { if ( is_prime ( i )) { for ( long j = 0 ; j < n ; j += 1 ) { if ( i + j == n ) { if ( is_prime ( j )) { count += 1 ; } } } } } Can you see where the silly loop appears above? Short Circuiting I have shown an example of short-circuiting in class, using exactly checking of prime as an example. However, some of you still wrote code like the following. This is another disappointment and I am tempted to deduct marks (but didn't). The improper use of short-circuiting often occurs with the silly loop to solve n - i above. for ( long i = 0 ; i <= n / 2 ; i += 1 ) { if ( is_prime ( i )) { for ( long j = 0 ; j < n ; j += 1 ) { if ( is_prime ( j ) && i + j == n ) { count += 1 ; } } } } Here, the code is spending lots of time checking if j is a prime. After that, if i + j is not n, (which is likely since there is only one such j), we do nothing. The effort in checking if j is prime is wasted. Remember: do not do redundant work. for ( long i = 0 ; i <= n / 2 ; i += 1 ) { for ( long j = 0 ; j < n ; j += 1 ) { if ( is_prime ( i ) && is_prime ( j ) && i + j == n ) { count += 1 ; } } } This is even worse -- note that the code above checks if i is prime, repeatedly, even if i does not change between Lines 3-5. Remember: do not do repetitive work. Double Counting Another common bug is to double count the number of pairs, as follows (e.g., count the pair (3,5) and (5,3) once each for input 8.). Some students do realize that they are double counting and try to solve this by setting count = count/2 . This does not work since not every pair gets double counted. Example, (3, 3) is counted once if the input is 6. for ( long i = 0 ; i < n ; i += 1 ) { if ( is_prime ( i ) && is_prime ( n - i )) { count += 1 ; } } Answer #include \"cs1010.h\" #include <math.h> #include <stdbool.h> bool is_prime ( long n ) { for ( int i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } long count_prime_pairs ( long n ) { long count = 0 ; for ( int i = 2 ; i <= n / 2 ; i += 1 ) { if ( is_prime ( i ) && is_prime ( n - i )) { count += 1 ; } } return count ; } int main () { long n = cs1010_read_long (); cs1010_println_long ( count_prime_pairs ( n )); } Digits Answer long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { // Increase the counter if we see the same digit. // Otherwise reset counter to 1. if ( n % 10 == current_digit ) { current_count += 1 ; } else { current_count = 1 ; } // Checks if we find a longer (or equally long) // consecutive sequence. Update longest_digit // and longest_count if so. if ( current_count > longest_count ) { longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } // Update the current digit to the last digit of n // and shorten n by one digit. current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } Comments Updated Overall, more students solved this problem than expected. 63 students receive either 7 or 8 marks for this question. clap clap . Marking scheme: I deduct one mark for each bug, and try to find the minimum number of fixes to make the code works correctly. A few common mistakes that I saw for this question are as follows. Wrong initialization A common error is to reset current_count to 0 if a different digit is encountered. It should be reset to 1 (since this different digit is already encountered once ). long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { if ( n % 10 == current_digit ) { current_count += 1 ; } else { current_count = 0 ; // <-- bug } if ( current_count > longest_count ) { longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } Checking if Longer The longest_digit didn't get updated sometimes. The mistake is to check if we have a longer sequence only when the same digit is encountered, or only when a different digit is encountered. This would cause the code to fail if the input only contains different digits (e.g., 123) or only the same digits (e.g., 111). To handle such cases, we need to check if we found a new longest sequence regardless of the digit encountered. long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { if ( n % 10 == current_digit ) { current_count += 1 ; if ( current_count > longest_count ) { // bug longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } } else { current_count = 1 ; } current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { if ( n % 10 == current_digit ) { current_count += 1 ; } else { if ( current_count > longest_count ) { // bug longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } current_count = 1 ; } current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } Breaking Ties. Checking if current_count is larger and breaking ties is also commonly written wrongly. Here are two common buggy versions: if ( current_count >= longest_count ) { longest_count = current_count ; if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } if ( current_count >= longest_count && current_digit < longest_digit ) { longest_digit = current_digit ; longest_count = current_count ; } Finally, students who used a while loop might missed out the first (most significant digit) digit, if the code is structured as follows: while ( n > 0 ) { long current_digit = n % 10 ; long next_digit = ( n / 10 ) % 10 ; if ( next_digit == current_digit ) { current_count += 1 ; } else { current_count = 1 ; } if ( current_count > longest_count ) { longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } current_digit = next_digit ; n = n / 10 ; } return longest_digit ; Square Comments This is the hardest problem I set to differentiate the A+ from the As, and I did not expect many students to solve this. About 10% of students, however, managed to get at least 7 marks for this question! Well done. For the rest of the students, who didn't get the right approach to the solution, I still give some marks: If you try to draw the square in some way, without recursion, you get 1 marks (for style) only. Some students uses recursion as a replacement of loops to draw the border, this does not get to the \"heart\" of the problem, so still 1 mark. If you attempted to use recursion to draw the inner squares, you get either 2 or 3 marks, depending on how close you are. 4 - 5 marks are given to those who get the overall idea of how to use recursion in this context, but didn't quite get it right. 6-7 are for those who get the correct answer, but has 1-2 bugs. Solving this problem requires some pattern recognition skill from computational thinking I mentinoed in the final lecture. You should recognize that there are three regions to the square: The first and last rows ( row == 1 || row == width ) where we have to draw ##..# . The second and penultimate rows ( row == 2 || row == width - 1 ) where we have to draw # .. # . The rest ( row >= 3 && row <= width - 2 ), where we have to draw # .. # , but with an inner square in between. The next question is how to draw the inner square? At row == 3 , we have to draw the top row of the inner square. The inner square is also smaller (width is smaller by 4). So the recursion to draw the inner square is: print_square(row - 2, width - 4); Once you get the above, everything should fall into place. Answer #include \"cs1010.h\" /** * Print a line of given width consisting of # only. * * @param[in] width The width of the line. */ void print_line ( long width ) { for ( long i = 0 ; i < width ; i += 1 ) { cs1010_print_string ( \"#\" ); } } /** * Print a line of given width, consisting of \" \" except * the first and last characters, which is #. * * @param[in] width The width of the line. */ void print_border ( long width ) { cs1010_print_string ( \"#\" ); for ( long i = 0 ; i < width - 2 ; i += 1 ) { cs1010_print_string ( \" \" ); } cs1010_print_string ( \"#\" ); } /** * Print one row of a concentric square, recursively. * * @param[in] row Which row of the square to draw. * @param[in] width The width of the square. */ void print_square ( long row , long width ) { if ( width == 1 ) { cs1010_print_string ( \"#\" ); } else if ( row == 0 || row == width - 1 ) { print_line ( width ); } else if ( row == 1 || row == width - 2 ) { print_border ( width ); } else { cs1010_print_string ( \"# \" ); print_square ( row - 2 , width - 4 ); cs1010_print_string ( \" #\" ); } } int main () { long width = cs1010_read_long (); for ( long row = 0 ; row < width ; row += 1 ) { print_square ( row , width ); cs1010_println_string ( \"\" ); } }","title":"PE1 Comments and Answers"},{"location":"pe1-comments.html#pe1-comments-and-answer-keys","text":"","title":"PE1: Comments and Answer Keys"},{"location":"pe1-comments.html#vote","text":"","title":"vote"},{"location":"pe1-comments.html#comments","text":"This is supposed to be a very easy, \"give-away\" question, but only 60% of students get full marks for this question. Common mistakes include: Using the wrong type . Some students read integer values as double or read long as long long . These do not affect the correctness but it does not demonstrate that the students understand the differences between the different types. There is a -0.5 penalty for each one. A more serious error involves using int for the number of votes (-1) or long for the percentage (-1). Integer division . Some students used integer division when calculating the percentage. For instance: double percentage = ( m / ( m + n )) * 100.0 ; The computation of m/(m+n) is done entirely as long integer. You need to either cast m or n to double, or multiple 100.0 (a double) earlier: double percentage = ( m * 100.0 / ( m + n )); Redundant Cast . Some studnets do not understand the needs for casting and simply cast everything: double percentage = (( double ) m * ( double ) 100.0 / (( double ) m + ( double ) n )); I decided not to deduct marks for this, but this is not the right way to write an arithmetic expression! Redundant Functions . Some students wrote something like this: double percentage_of_nixon ( long nixon , long total ) { return nixon * 100.0 / total ; } double percentage_of_mcneal ( long mcneal , long total ) { return mcneal * 100.0 / total ; } This shows that students do not understand that functions are supposed to be reusable that there is only one function needed. There is a -1 penalty for that. Misc. Some students made simple mistakes like printing the numbers without a space in between or print the two numbers on different lines (-0.5), or didn't include the right headers (-1).","title":"Comments"},{"location":"pe1-comments.html#solution","text":"#include \"cs1010.h\" int main () { long mcneal = cs1010_read_long (); long nixon = cs1010_read_long (); long total = mcneal + nixon ; cs1010_print_double ( mcneal * 100.0 / total ); cs1010_print_string ( \" \" ); cs1010_println_double ( nixon * 100.0 / total ); }","title":"Solution"},{"location":"pe1-comments.html#newton","text":"","title":"newton"},{"location":"pe1-comments.html#comments_1","text":"Newton is another easy question that surprisingly many students are struggling with. Needless Careless Mistakes Many students wrote down the wrong formula for f(x) f(x) or f'(x) f'(x) , which I deduct 1 marks after a facepalm. Wrong Type Quite a few students read the inputs as long instead of double . There is a 1 mark deduction for this. A few students used float instead of double . As I have mentioned, you should never touch float at all, since its precision is lame low. If you use float , you would not get the correct answer for some of the test cases due to floating point errors. There is a 0.5 mark deduction for using float instead of double . Uninitialized Variable There are also a number of students who got the following bugs: double root ; while ( fabs ( f ( a , b , c , d , x )) >= 0.000000001 ) { : } return root ; Suppose that the initial guess x is already close enough to the root, the loop is never entered, and the function returns root uninitialized. The lesson here is that always make sure you cover all possible cases. Also, please think about what variables do you really need to solve a problem. In this question, you do not any extra variable -- so root is completely unnecessary. The more variable you used, the more complex your code get, the more likely you introduce bugs into your code, as shown in the example above. Terminating Conditions Another common mistake is the terminating conditions. A handful of you wrote something like this: while ( fabs ( f ( a , b , c , d , x ) >= 0.000000001 )) { Here, the code tries to pass a true or false expression to fabs , which the compiler warns. A few of you, instead of fixing the parenthesis, change fabs to abs instead to silence the compiler >.< Other mistakes include not setting the right threshold (some uses 0.001, or 0.00001 -- why oh why?) or use the wrong comparison: while ( fabs ( f ( a , b , c , d , x ) < 0.000000001 )) { Some did not use fabs at all: while ( f ( a , b , c , d , x ) >= 0.000000001 ) { Some checked if the root is small enough, instead of the value of function is small enough: while ( fabs ( x ) >= 0.000000001 ) { A small number of students hardcoded the number of steps (e.g., always loop 4 times), which works for the sample but not for the general cases. There is a one mark deduction for all errors related to terminating conditions. One strange thing some of you do is to use a for loop for this question: for ( long i = 0 ; fabs ( x ) >= 0.000000001 ; i += 1 ) The loop still terminates correctly, but the variable i is entirely useless. No marks are deducted but I should have for not demonstrating that you know which loop to use. Use of pow() I did not deduct marks for this -- but using pow for squaring and cubing is an overkill. pow is a general function that works even for floating point exponentiation. So it is slower. Some of you even wrote pow(x, 1) and pow(x, 0) . Marks would have been deducted if efficiency is a criterion.","title":"Comments"},{"location":"pe1-comments.html#answer","text":"#include \"cs1010.h\" #include <math.h> double f ( double a , double b , double c , double d , double x ) { return a * x * x * x + b * x * x + c * x + d ; } double fp ( double a , double b , double c , double x ) { return 3 * a * x * x + 2 * b * x + c ; } double find_root ( double a , double b , double c , double d , double x ) { double fx = f ( a , b , c , d , x ); while ( fabs ( fx ) >= 0.000000001 ) { double fpx = fp ( a , b , c , x ); x -= fx / fpx ; fx = f ( a , b , c , d , x ); } return x ; } int main () { double a = cs1010_read_double (); double b = cs1010_read_double (); double c = cs1010_read_double (); double d = cs1010_read_double (); double x = cs1010_read_double (); x = find_root ( a , b , c , d , x ); cs1010_println_double ( x ); }","title":"Answer"},{"location":"pe1-comments.html#goldbach","text":"","title":"Goldbach"},{"location":"pe1-comments.html#comments_2","text":"This question is a little bit more tricky than newton , but not much. Checking For Prime The disappointing thing is that, even though you have gone through an exercise and an assignment that involves checking if a number is prime, with the solution given comparing different approaches, many of you still wrote the wrong function for checking prime, uses the wrong type, or wrote the slow version. Since I deducted one mark for each bug, an incorrect is_prime might cost you 1-3 marks. This is entirely unnecessary >.< Try to see if you can spot the bugs and why it fails in each of the following. This is a good exam question that I might ask in a future semester -- don't tell your junior shush . bool is_prime ( long n ) { for ( long i = 1 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } bool is_prime ( long n ) { for ( long i = 2 ; i < sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } bool is_prime ( long n ) { for ( long i = 2 ; i <= ceil ( sqrt ( n )); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } else { return true ; } } } Another common mistake related to checking of prime is that the function should return a bool (since a number is either a prime or not). Some students returned an integer from this function. I deducted one mark for not demonstrating an understanding of boolean functions. Unnecessary Loops This is another strange but common code that you have written. I did not deduct marks since efficiency is not a criterion for PE1 -- but I am puzzled why you write code like this. Let's say I ask you this question: 31 plus what equals to 100? Any primary school students can tell you, take 100, subtract 31, you get 69. So 31 + 69 = 100. This is not many of you do to find the answer. What you do is equivalent to: for ( j = 1 ; j <= 100 ; j += 1 ) { if ( 31 + j == 100 ) { cs1010_println_long ( j ); } } Essentially, checking is 31 + 1 equal to 100? is 31 + 2 equals to 100? etc. until you find an answer. After that, you continue to check, is 31 + 70 equals to 100? is 31 + 71 equal to 100? and so on. This is just silly >.< In the context of goldbach , the code you wrote is: for ( long i = 0 ; i <= n / 2 ; i += 1 ) { if ( is_prime ( i )) { for ( long j = 0 ; j < n ; j += 1 ) { if ( i + j == n ) { if ( is_prime ( j )) { count += 1 ; } } } } } Can you see where the silly loop appears above? Short Circuiting I have shown an example of short-circuiting in class, using exactly checking of prime as an example. However, some of you still wrote code like the following. This is another disappointment and I am tempted to deduct marks (but didn't). The improper use of short-circuiting often occurs with the silly loop to solve n - i above. for ( long i = 0 ; i <= n / 2 ; i += 1 ) { if ( is_prime ( i )) { for ( long j = 0 ; j < n ; j += 1 ) { if ( is_prime ( j ) && i + j == n ) { count += 1 ; } } } } Here, the code is spending lots of time checking if j is a prime. After that, if i + j is not n, (which is likely since there is only one such j), we do nothing. The effort in checking if j is prime is wasted. Remember: do not do redundant work. for ( long i = 0 ; i <= n / 2 ; i += 1 ) { for ( long j = 0 ; j < n ; j += 1 ) { if ( is_prime ( i ) && is_prime ( j ) && i + j == n ) { count += 1 ; } } } This is even worse -- note that the code above checks if i is prime, repeatedly, even if i does not change between Lines 3-5. Remember: do not do repetitive work. Double Counting Another common bug is to double count the number of pairs, as follows (e.g., count the pair (3,5) and (5,3) once each for input 8.). Some students do realize that they are double counting and try to solve this by setting count = count/2 . This does not work since not every pair gets double counted. Example, (3, 3) is counted once if the input is 6. for ( long i = 0 ; i < n ; i += 1 ) { if ( is_prime ( i ) && is_prime ( n - i )) { count += 1 ; } }","title":"Comments"},{"location":"pe1-comments.html#answer_1","text":"#include \"cs1010.h\" #include <math.h> #include <stdbool.h> bool is_prime ( long n ) { for ( int i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } long count_prime_pairs ( long n ) { long count = 0 ; for ( int i = 2 ; i <= n / 2 ; i += 1 ) { if ( is_prime ( i ) && is_prime ( n - i )) { count += 1 ; } } return count ; } int main () { long n = cs1010_read_long (); cs1010_println_long ( count_prime_pairs ( n )); }","title":"Answer"},{"location":"pe1-comments.html#digits","text":"","title":"Digits"},{"location":"pe1-comments.html#answer_2","text":"long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { // Increase the counter if we see the same digit. // Otherwise reset counter to 1. if ( n % 10 == current_digit ) { current_count += 1 ; } else { current_count = 1 ; } // Checks if we find a longer (or equally long) // consecutive sequence. Update longest_digit // and longest_count if so. if ( current_count > longest_count ) { longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } // Update the current digit to the last digit of n // and shorten n by one digit. current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; }","title":"Answer"},{"location":"pe1-comments.html#comments-czjqqkd2-updated-czjqqkd3","text":"Overall, more students solved this problem than expected. 63 students receive either 7 or 8 marks for this question. clap clap . Marking scheme: I deduct one mark for each bug, and try to find the minimum number of fixes to make the code works correctly. A few common mistakes that I saw for this question are as follows. Wrong initialization A common error is to reset current_count to 0 if a different digit is encountered. It should be reset to 1 (since this different digit is already encountered once ). long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { if ( n % 10 == current_digit ) { current_count += 1 ; } else { current_count = 0 ; // <-- bug } if ( current_count > longest_count ) { longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } Checking if Longer The longest_digit didn't get updated sometimes. The mistake is to check if we have a longer sequence only when the same digit is encountered, or only when a different digit is encountered. This would cause the code to fail if the input only contains different digits (e.g., 123) or only the same digits (e.g., 111). To handle such cases, we need to check if we found a new longest sequence regardless of the digit encountered. long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { if ( n % 10 == current_digit ) { current_count += 1 ; if ( current_count > longest_count ) { // bug longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } } else { current_count = 1 ; } current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } long longest_consecutive_digits ( long n ) { long longest_count = - 1 ; long longest_digit ; long current_count = 0 ; long current_digit = n % 10 ; do { if ( n % 10 == current_digit ) { current_count += 1 ; } else { if ( current_count > longest_count ) { // bug longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } current_count = 1 ; } current_digit = n % 10 ; n = n / 10 ; } while ( n > 0 ); return longest_digit ; } Breaking Ties. Checking if current_count is larger and breaking ties is also commonly written wrongly. Here are two common buggy versions: if ( current_count >= longest_count ) { longest_count = current_count ; if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } if ( current_count >= longest_count && current_digit < longest_digit ) { longest_digit = current_digit ; longest_count = current_count ; } Finally, students who used a while loop might missed out the first (most significant digit) digit, if the code is structured as follows: while ( n > 0 ) { long current_digit = n % 10 ; long next_digit = ( n / 10 ) % 10 ; if ( next_digit == current_digit ) { current_count += 1 ; } else { current_count = 1 ; } if ( current_count > longest_count ) { longest_digit = current_digit ; longest_count = current_count ; } else if ( current_count == longest_count ) { if ( current_digit < longest_digit ) { longest_digit = current_digit ; } } current_digit = next_digit ; n = n / 10 ; } return longest_digit ;","title":"Comments \u0002czjqqkd:2\u0003 Updated \u0002czjqqkd:3\u0003"},{"location":"pe1-comments.html#square","text":"","title":"Square"},{"location":"pe1-comments.html#comments_3","text":"This is the hardest problem I set to differentiate the A+ from the As, and I did not expect many students to solve this. About 10% of students, however, managed to get at least 7 marks for this question! Well done. For the rest of the students, who didn't get the right approach to the solution, I still give some marks: If you try to draw the square in some way, without recursion, you get 1 marks (for style) only. Some students uses recursion as a replacement of loops to draw the border, this does not get to the \"heart\" of the problem, so still 1 mark. If you attempted to use recursion to draw the inner squares, you get either 2 or 3 marks, depending on how close you are. 4 - 5 marks are given to those who get the overall idea of how to use recursion in this context, but didn't quite get it right. 6-7 are for those who get the correct answer, but has 1-2 bugs. Solving this problem requires some pattern recognition skill from computational thinking I mentinoed in the final lecture. You should recognize that there are three regions to the square: The first and last rows ( row == 1 || row == width ) where we have to draw ##..# . The second and penultimate rows ( row == 2 || row == width - 1 ) where we have to draw # .. # . The rest ( row >= 3 && row <= width - 2 ), where we have to draw # .. # , but with an inner square in between. The next question is how to draw the inner square? At row == 3 , we have to draw the top row of the inner square. The inner square is also smaller (width is smaller by 4). So the recursion to draw the inner square is: print_square(row - 2, width - 4); Once you get the above, everything should fall into place.","title":"Comments"},{"location":"pe1-comments.html#answer_3","text":"#include \"cs1010.h\" /** * Print a line of given width consisting of # only. * * @param[in] width The width of the line. */ void print_line ( long width ) { for ( long i = 0 ; i < width ; i += 1 ) { cs1010_print_string ( \"#\" ); } } /** * Print a line of given width, consisting of \" \" except * the first and last characters, which is #. * * @param[in] width The width of the line. */ void print_border ( long width ) { cs1010_print_string ( \"#\" ); for ( long i = 0 ; i < width - 2 ; i += 1 ) { cs1010_print_string ( \" \" ); } cs1010_print_string ( \"#\" ); } /** * Print one row of a concentric square, recursively. * * @param[in] row Which row of the square to draw. * @param[in] width The width of the square. */ void print_square ( long row , long width ) { if ( width == 1 ) { cs1010_print_string ( \"#\" ); } else if ( row == 0 || row == width - 1 ) { print_line ( width ); } else if ( row == 1 || row == width - 2 ) { print_border ( width ); } else { cs1010_print_string ( \"# \" ); print_square ( row - 2 , width - 4 ); cs1010_print_string ( \" #\" ); } } int main () { long width = cs1010_read_long (); for ( long row = 0 ; row < width ; row += 1 ) { print_square ( row , width ); cs1010_println_string ( \"\" ); } }","title":"Answer"},{"location":"pe1-venue.html","text":"Practical Exam 1: Lab Allocation NAME PE1 Venue AARUSHI SINGH PL1 ADELYN KOH JING YING PL1 AHMAD MUDAAFI' B ZAINUDDIN PL1 AI ZHENGWEI PL1 ALEX TEO KANG JIE PL1 AMIR AZHAR B AZIZAN PL1 ANDREW LAU JIA JUN PL1 ANG KENG SIANG PL1 ANG KIANG YANG PL1 AW CHIAN HAO PL1 BALAM SAI ROHIT REDDY PL1 BEATRICE CHAN TONG PL1 BENEDICT YU CHENG EN PL1 BENJAMIN CHIA SHAN HONG PL1 BRANSON LEE JUN XIAN PL1 CAI RONG PL1 CHAN EE ZHENG, BENJAMIN PL1 CHAN HIN, SEAN PL1 CHAN WEI FONG, MAX PL1 CHAN YEE CHONG PHILIP PL1 CHAN YEW CHUN DANIEL PL1 CHAN ZHI ZHENG, AMOS PL1 CHANG HUI ZHEN PL1 CHANG ZHONG KAI PL1 CHEN CHAO PL1 CHEN TONG PL1 CHENG LE DA, CLEMENT PL1 CHENG WANYIN PL1 CHENG WEIXUAN PL1 CHERYL NG YUN LIN PL1 CHEW JUN KONG PL1 CHIA BIING HANN PL1 CHNG XIAN YI PL1 CHOI WONJAE PL1 CHU JUI HUNG @JEFFERSON CHU PL1 CHUA MAI FENG, CARL PL1 CHUA WEN XUAN PL1 CHUA ZONG WEI PL1 CLAIRE CHAN YEN HWA PL1 CYNTHIA LEE WENG YAN PL1 DANIEL TAN WEE LIANG PL2 DANISH B EDDIE PL2 DARREN ONG PL2 DEBBIE TAN JIA MIN PL2 DING NING PL2 DIVAKARAN HARITHA PL2 EDMUND TEO WEI XIN PL2 EU JING SEN PL2 EVELYN YI-WEN CHEN PL2 FATIN NABILAH BTE SUHAIMI PL2 FOO CHI HEN PL2 GINA QUAH JIE XI PL2 GLEN WONG SHU ZE PL2 GOH RUI PING SAMANTHA PL2 GOH ZHEN HAO JOEY PL2 GONDHALEKAR SUKRUT YOGESH PL2 GREGORY TAN WEI YUAN PL2 GUI XIXIAN PL2 GUO HAOREN PL2 HANS KURNIA WIDJAJA PL2 HAO YUN PL2 HASHIR ZAHIR PL2 HENG HONG CHUAN PL2 HO JING YANG DANIEL PL2 HO SI SHI ANNETTE PL2 HO WEI BIN, JERRY PL2 HU XINYING PL2 HUANG XUANKUN PL2 IAN CHUA PL2 ISABELLA CHEONG XIAO XUAN PL2 IVAN ANDIKA LIE PL2 JANEL ANG YEE HUEY PL2 JASON SATHYA CITRO PL2 JASPER ONG SHAO YONG PL2 JAZHTEN LOW YONGSHEN PL2 JERRY ZHANG ZHUORAN PL2 JESS TEO XI ZHI PL2 JOEL CHANG ZHI KAI PL2 JOHN CUTHBERT KHOO TENG FONG PL2 JOSEPH WONG YEFENG PL2 JUSTIN CHIA JIA JIN PL3 K ALAGES PL3 KARAN SARAT PL3 KARNATI SAI ABHISHEK PL3 KEE KAH LOK PL3 KEITH CHAN JUN KAI PL3 KELVIN HARRIS PL3 KEVIN PUTERA PL3 KEZIA KEW KAI YUN PL3 KHAIRUL IMAN NASRI B AZHARIE PL3 KHOO TZE YANG RAYSON PL3 KISHORE R PL3 KWOK KUIN EK JEREMY PL3 KYAWT KYAWT SAN PL3 LAI WEN XUAN JEREMY PL3 LAM TIAN WEI JUSTIN PL3 LE HONG LONG PL3 LEE HONG CHIEN, KENNETH PL3 LEE LI XIN PL3 LEE RAIYAN BIN ZULKIFLI PL3 LEE WEI HERN, JASON PL3 LEE YUEYU PL3 LEE ZHEN YU PL4 LEOW YONG HENG PL4 LEOW YONG KANG ANDREW PL4 LI JIAYU PL4 LI ZIHAN PL4 LIAO LIXIN PL4 LIAO TIANCHANG PL4 LIM CHEE SENG BRIAN PL4 LIM CHEK JUN PL4 LIM CHENG YIN, RYAN PL4 LIM HAO XIANG, SEAN PL4 LIM JIA WEI PL4 LIM JIAYI, TAMELLY PL4 LIM JUN KUANG, LIONEL PL4 LIM LI LINCOLN PL4 LIM SI YING PL4 LIM TING WEI PL4 LIM WEN HAN, EUGENE PL4 LIM YAN TING PL4 LIN JIAYUE PL4 LING WEN JIAN PL4 LIU JINGXUAN PL4 LIU PEIZE PL5 LIU SHIRU PL5 LIU SONGTAO PL5 LIU WEI JIE NICHOLAS PL5 LOH CHING WEI, JOSHUA PL5 LOH YONG ZEE PL5 LOW EE TER PL5 LOW JIA YEE PL5 LOW QIRAN PL5 LOW SIU YUAN, FRANCIS PL5 LUCAS FOO SOO QUAN PL5 LYE JUN WEI ANANDA PL5 MARC PHUA HSIAO MENG PL5 MATTHEW NATHANAEL SUGIRI PL5 MERVIN WEE MINGWEN PL5 MICHELLE TOH HUI PING PL5 MODAK SHANTANU BHARAT PL5 MOHAMED RIYAS PL5 MOHAMMAD YOUSUF MINHAJ ZIA PL5 MUHAMMAD FAIRUZ B AMIRHAMZAH PL5 MUHAMMAD HOZEFA ZUMKHAWALA PL6 MUHAMMAD SHOLIHIN BIN KAMARUDIN PL6 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN PL6 NATHAN YEO KEE HERN PL6 NEO WEN HUI PL6 NG JIE WU PL6 NG JING KANG PL6 NG JING KIAT PL6 NG SHI QI, CARRIE PL6 NG SIU HIAN PL6 NG WEE KIAT PL6 NG WEI JIE, BRANDON PL6 NG ZI HUI PL6 NGAN JI CHENG PL6 NGUYEN THANH DUC PL6 NGUYEN TIEN DAT PL6 NIGEL TAN PL6 NIGELLE LEO YUWEN PL6 NISHANTH ELANGO PL6 NYAN WUN PAING PL6 OEI CHIU YAN REBECCA PL6 ONG YU XUAN PL6 OUNG YONG SHENG KENNEDY PL6 OW ZHENG KUAN PL6 P PRADEEP PL6 PANG JIA JUN VERNON PL6 PARK SO HYUN PL6 PARMAR VARUN SAMIR PL6 PARVATHI RANJITH MENON ESLab 1 PATWARI RISHAB ESLab 1 PEI YAN BO ESLab 1 PHOON JIA JUIN ESLab 1 POH CHOO LEONG, LINSTON ESLab 1 PONG LOONG BOB ESLab 1 POON KAH ONN, BENJAMIN ESLab 1 POW JING YONG ESLab 1 QIAN JIE ESLab 1 QUAH YOU JING KANE ESLab 1 QUEK AIK PENG ESLab 1 RAGHAV BHARDWAJ ESLab 1 RAJAMOHAN B PRIYAN ESLab 1 RAVEENDRAN AJEY ASHOK ESLab 1 RISHI MAHADEVAN ESLab 1 RUSDI HAIZIM B RAHIM ESLab 1 RYAN TAN YU ESLab 1 SAI GANESH SURESH ESLab 1 SCOTT FLOYD ZHEN-YAN SMAHON ESLab 1 SEE SHENG CHAO ESLab 1 SENTHIL ARAAVIND ESLab 2 SHA LONG ESLab 2 SHANNON LEE ESLab 2 SHAWN WONG JUN KIT ESLab 2 SHRIYA SAXENA ESLab 2 SIM YU JIE ESLab 2 SITI NADIAH BINTE MOHAMED RAMLI ESLab 2 SUTHER DAVID SAMUEL ESLab 2 TALAGADADIVI DURGA RUKMINI MANASWINI ESLab 2 TAM WEI IAN JOSHUA ESLab 2 TAN GUAN YEW ESLab 2 TAN KAI LI CATHERINE ESLab 2 TAN KOK JOON ESLab 2 TAN LI ANN PETER ESLab 2 TAN YEH HAN, JOHN ESLab 2 TAN YI XIANG ESLab 2 TAN ZHENG FU JUSTIN ESLab 2 TAN ZHENG WEN ESLab 2 TAY JIN WEN ESLab 2 TAY JING XUAN ESLab 2 TAY TZE-WEI, CALEB WSLab 1 TAY YEE EN, RYAN WSLab 1 TEH ZI HUAI WSLab 1 TEO WEI JIE, SHAUN WSLab 1 TOH YING YING JANICE WSLab 1 TONG QI WEI WSLab 1 TRAN MINH DUONG WSLab 1 TRAN QUANG THANH WSLab 1 TSHIN QI REN WSLab 1 UMAR BIN MOIZ WSLab 1 VASAVADA TEJAS SUDHIR WSLab 1 VIDHYABHARATHI SOMASUNDARAM WSLab 1 VIVIAN LEE BOON GEOK WSLab 1 WANG ZICONG WSLab 1 WEI FENG WSLab 1 WENG KEXIN WSLab 1 WONG JIN EN, SHANNON WSLab 1 WONG REN-WEI, RYAN WSLab 1 XUE ZHENGQING WSLab 1 YANG AN QI WSLab 1 YANG CHENGLONG WSLab 1 YANG KAI ZE WSLab 3 YANG ZI YUN WSLab 3 YAP JIN FA WSLab 3 YAP KESIN WSLab 3 YE GUOQUAN WSLab 3 YE TONG WSLab 3 YEN PEI CHIH WSLab 3 YEW JING HUI WSLab 3 YU XIAOXUE WSLab 3 YUAN JIAYI WSLab 3 YUE JUN YI WSLab 3 ZHANG SHIYU WSLab 3 ZHANG YIHAN WSLab 3 ZHANG YIPING WSLab 3 ZHANG YUE HAN WSLab 3 ZHAO PENGFEI WSLab 3 ZHAO TIANQI WSLab 3 ZHENG KAINING WSLab 3 ZHU BO WSLab 3 ZHU YIJIE WSLab 3 ZOE WONG XIN LEI WSLab 3","title":"Practical Exam 1: Lab Allocation"},{"location":"pe1-venue.html#practical-exam-1-lab-allocation","text":"NAME PE1 Venue AARUSHI SINGH PL1 ADELYN KOH JING YING PL1 AHMAD MUDAAFI' B ZAINUDDIN PL1 AI ZHENGWEI PL1 ALEX TEO KANG JIE PL1 AMIR AZHAR B AZIZAN PL1 ANDREW LAU JIA JUN PL1 ANG KENG SIANG PL1 ANG KIANG YANG PL1 AW CHIAN HAO PL1 BALAM SAI ROHIT REDDY PL1 BEATRICE CHAN TONG PL1 BENEDICT YU CHENG EN PL1 BENJAMIN CHIA SHAN HONG PL1 BRANSON LEE JUN XIAN PL1 CAI RONG PL1 CHAN EE ZHENG, BENJAMIN PL1 CHAN HIN, SEAN PL1 CHAN WEI FONG, MAX PL1 CHAN YEE CHONG PHILIP PL1 CHAN YEW CHUN DANIEL PL1 CHAN ZHI ZHENG, AMOS PL1 CHANG HUI ZHEN PL1 CHANG ZHONG KAI PL1 CHEN CHAO PL1 CHEN TONG PL1 CHENG LE DA, CLEMENT PL1 CHENG WANYIN PL1 CHENG WEIXUAN PL1 CHERYL NG YUN LIN PL1 CHEW JUN KONG PL1 CHIA BIING HANN PL1 CHNG XIAN YI PL1 CHOI WONJAE PL1 CHU JUI HUNG @JEFFERSON CHU PL1 CHUA MAI FENG, CARL PL1 CHUA WEN XUAN PL1 CHUA ZONG WEI PL1 CLAIRE CHAN YEN HWA PL1 CYNTHIA LEE WENG YAN PL1 DANIEL TAN WEE LIANG PL2 DANISH B EDDIE PL2 DARREN ONG PL2 DEBBIE TAN JIA MIN PL2 DING NING PL2 DIVAKARAN HARITHA PL2 EDMUND TEO WEI XIN PL2 EU JING SEN PL2 EVELYN YI-WEN CHEN PL2 FATIN NABILAH BTE SUHAIMI PL2 FOO CHI HEN PL2 GINA QUAH JIE XI PL2 GLEN WONG SHU ZE PL2 GOH RUI PING SAMANTHA PL2 GOH ZHEN HAO JOEY PL2 GONDHALEKAR SUKRUT YOGESH PL2 GREGORY TAN WEI YUAN PL2 GUI XIXIAN PL2 GUO HAOREN PL2 HANS KURNIA WIDJAJA PL2 HAO YUN PL2 HASHIR ZAHIR PL2 HENG HONG CHUAN PL2 HO JING YANG DANIEL PL2 HO SI SHI ANNETTE PL2 HO WEI BIN, JERRY PL2 HU XINYING PL2 HUANG XUANKUN PL2 IAN CHUA PL2 ISABELLA CHEONG XIAO XUAN PL2 IVAN ANDIKA LIE PL2 JANEL ANG YEE HUEY PL2 JASON SATHYA CITRO PL2 JASPER ONG SHAO YONG PL2 JAZHTEN LOW YONGSHEN PL2 JERRY ZHANG ZHUORAN PL2 JESS TEO XI ZHI PL2 JOEL CHANG ZHI KAI PL2 JOHN CUTHBERT KHOO TENG FONG PL2 JOSEPH WONG YEFENG PL2 JUSTIN CHIA JIA JIN PL3 K ALAGES PL3 KARAN SARAT PL3 KARNATI SAI ABHISHEK PL3 KEE KAH LOK PL3 KEITH CHAN JUN KAI PL3 KELVIN HARRIS PL3 KEVIN PUTERA PL3 KEZIA KEW KAI YUN PL3 KHAIRUL IMAN NASRI B AZHARIE PL3 KHOO TZE YANG RAYSON PL3 KISHORE R PL3 KWOK KUIN EK JEREMY PL3 KYAWT KYAWT SAN PL3 LAI WEN XUAN JEREMY PL3 LAM TIAN WEI JUSTIN PL3 LE HONG LONG PL3 LEE HONG CHIEN, KENNETH PL3 LEE LI XIN PL3 LEE RAIYAN BIN ZULKIFLI PL3 LEE WEI HERN, JASON PL3 LEE YUEYU PL3 LEE ZHEN YU PL4 LEOW YONG HENG PL4 LEOW YONG KANG ANDREW PL4 LI JIAYU PL4 LI ZIHAN PL4 LIAO LIXIN PL4 LIAO TIANCHANG PL4 LIM CHEE SENG BRIAN PL4 LIM CHEK JUN PL4 LIM CHENG YIN, RYAN PL4 LIM HAO XIANG, SEAN PL4 LIM JIA WEI PL4 LIM JIAYI, TAMELLY PL4 LIM JUN KUANG, LIONEL PL4 LIM LI LINCOLN PL4 LIM SI YING PL4 LIM TING WEI PL4 LIM WEN HAN, EUGENE PL4 LIM YAN TING PL4 LIN JIAYUE PL4 LING WEN JIAN PL4 LIU JINGXUAN PL4 LIU PEIZE PL5 LIU SHIRU PL5 LIU SONGTAO PL5 LIU WEI JIE NICHOLAS PL5 LOH CHING WEI, JOSHUA PL5 LOH YONG ZEE PL5 LOW EE TER PL5 LOW JIA YEE PL5 LOW QIRAN PL5 LOW SIU YUAN, FRANCIS PL5 LUCAS FOO SOO QUAN PL5 LYE JUN WEI ANANDA PL5 MARC PHUA HSIAO MENG PL5 MATTHEW NATHANAEL SUGIRI PL5 MERVIN WEE MINGWEN PL5 MICHELLE TOH HUI PING PL5 MODAK SHANTANU BHARAT PL5 MOHAMED RIYAS PL5 MOHAMMAD YOUSUF MINHAJ ZIA PL5 MUHAMMAD FAIRUZ B AMIRHAMZAH PL5 MUHAMMAD HOZEFA ZUMKHAWALA PL6 MUHAMMAD SHOLIHIN BIN KAMARUDIN PL6 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN PL6 NATHAN YEO KEE HERN PL6 NEO WEN HUI PL6 NG JIE WU PL6 NG JING KANG PL6 NG JING KIAT PL6 NG SHI QI, CARRIE PL6 NG SIU HIAN PL6 NG WEE KIAT PL6 NG WEI JIE, BRANDON PL6 NG ZI HUI PL6 NGAN JI CHENG PL6 NGUYEN THANH DUC PL6 NGUYEN TIEN DAT PL6 NIGEL TAN PL6 NIGELLE LEO YUWEN PL6 NISHANTH ELANGO PL6 NYAN WUN PAING PL6 OEI CHIU YAN REBECCA PL6 ONG YU XUAN PL6 OUNG YONG SHENG KENNEDY PL6 OW ZHENG KUAN PL6 P PRADEEP PL6 PANG JIA JUN VERNON PL6 PARK SO HYUN PL6 PARMAR VARUN SAMIR PL6 PARVATHI RANJITH MENON ESLab 1 PATWARI RISHAB ESLab 1 PEI YAN BO ESLab 1 PHOON JIA JUIN ESLab 1 POH CHOO LEONG, LINSTON ESLab 1 PONG LOONG BOB ESLab 1 POON KAH ONN, BENJAMIN ESLab 1 POW JING YONG ESLab 1 QIAN JIE ESLab 1 QUAH YOU JING KANE ESLab 1 QUEK AIK PENG ESLab 1 RAGHAV BHARDWAJ ESLab 1 RAJAMOHAN B PRIYAN ESLab 1 RAVEENDRAN AJEY ASHOK ESLab 1 RISHI MAHADEVAN ESLab 1 RUSDI HAIZIM B RAHIM ESLab 1 RYAN TAN YU ESLab 1 SAI GANESH SURESH ESLab 1 SCOTT FLOYD ZHEN-YAN SMAHON ESLab 1 SEE SHENG CHAO ESLab 1 SENTHIL ARAAVIND ESLab 2 SHA LONG ESLab 2 SHANNON LEE ESLab 2 SHAWN WONG JUN KIT ESLab 2 SHRIYA SAXENA ESLab 2 SIM YU JIE ESLab 2 SITI NADIAH BINTE MOHAMED RAMLI ESLab 2 SUTHER DAVID SAMUEL ESLab 2 TALAGADADIVI DURGA RUKMINI MANASWINI ESLab 2 TAM WEI IAN JOSHUA ESLab 2 TAN GUAN YEW ESLab 2 TAN KAI LI CATHERINE ESLab 2 TAN KOK JOON ESLab 2 TAN LI ANN PETER ESLab 2 TAN YEH HAN, JOHN ESLab 2 TAN YI XIANG ESLab 2 TAN ZHENG FU JUSTIN ESLab 2 TAN ZHENG WEN ESLab 2 TAY JIN WEN ESLab 2 TAY JING XUAN ESLab 2 TAY TZE-WEI, CALEB WSLab 1 TAY YEE EN, RYAN WSLab 1 TEH ZI HUAI WSLab 1 TEO WEI JIE, SHAUN WSLab 1 TOH YING YING JANICE WSLab 1 TONG QI WEI WSLab 1 TRAN MINH DUONG WSLab 1 TRAN QUANG THANH WSLab 1 TSHIN QI REN WSLab 1 UMAR BIN MOIZ WSLab 1 VASAVADA TEJAS SUDHIR WSLab 1 VIDHYABHARATHI SOMASUNDARAM WSLab 1 VIVIAN LEE BOON GEOK WSLab 1 WANG ZICONG WSLab 1 WEI FENG WSLab 1 WENG KEXIN WSLab 1 WONG JIN EN, SHANNON WSLab 1 WONG REN-WEI, RYAN WSLab 1 XUE ZHENGQING WSLab 1 YANG AN QI WSLab 1 YANG CHENGLONG WSLab 1 YANG KAI ZE WSLab 3 YANG ZI YUN WSLab 3 YAP JIN FA WSLab 3 YAP KESIN WSLab 3 YE GUOQUAN WSLab 3 YE TONG WSLab 3 YEN PEI CHIH WSLab 3 YEW JING HUI WSLab 3 YU XIAOXUE WSLab 3 YUAN JIAYI WSLab 3 YUE JUN YI WSLab 3 ZHANG SHIYU WSLab 3 ZHANG YIHAN WSLab 3 ZHANG YIPING WSLab 3 ZHANG YUE HAN WSLab 3 ZHAO PENGFEI WSLab 3 ZHAO TIANQI WSLab 3 ZHENG KAINING WSLab 3 ZHU BO WSLab 3 ZHU YIJIE WSLab 3 ZOE WONG XIN LEI WSLab 3","title":"Practical Exam 1: Lab Allocation"},{"location":"pe1.html","text":"Practice Exam 1 Questions Exam Paper Click on GitHub Link to accept, run get-pe01 and submit-pe01 to solve this like any other assignments. Basic Info Date: 6 October, 2018 (Saturday) Time: 9am to 12noon Venue: Various programming labs Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 4 to 5 programming questions, very easy to hard Criteria: Correctness and Style. One mark is allocated for programming style for each question. Duration: 2 hours and 30 minutes Open Book (You can bring analog references) Lab Allocation Every student is assigned to a programming lab. Please see the allocation below. You should acclimatize yourself to the use of the PC desktops in the lab assigned to you. Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2) Here are the locatons for the respective labs Special Restrictions You will be issued a special account on the PE day to solve the exam questions. There will be no Internet access. Vim Configuration Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins. General Advice Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? what is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so. You will be given a question form to ask questions to clarify doubts about the question paper. But note that you can only ask a boolean question (YES/NO answer). Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases. Lab and Seat Allocation NAME Venue Seat Number AARUSHI SINGH PL1 soctf-imac215-002 ADELYN KOH JING YING PL1 soctf-imac215-003 AHMAD MUDAAFI' B ZAINUDDIN PL1 soctf-imac215-004 AI ZHENGWEI PL1 soctf-imac215-005 ALEX TEO KANG JIE PL1 soctf-imac215-008 AMIR AZHAR B AZIZAN PL1 soctf-imac215-009 ANDREW LAU JIA JUN PL1 soctf-imac215-010 ANG KENG SIANG PL1 soctf-imac215-011 ANG KIANG YANG PL1 soctf-imac215-012 AW CHIAN HAO PL1 soctf-imac215-013 BALAM SAI ROHIT REDDY PL1 soctf-imac215-014 BEATRICE CHAN TONG PL1 soctf-imac215-015 BENEDICT YU CHENG EN PL1 soctf-imac215-016 BENJAMIN CHIA SHAN HONG PL1 soctf-imac215-017 CAI RONG PL1 soctf-imac215-019 CHAN EE ZHENG, BENJAMIN PL1 soctf-imac215-020 CHAN HIN, SEAN PL1 soctf-imac215-021 CHAN WEI FONG, MAX PL1 soctf-imac215-022 CHAN YEE CHONG PHILIP PL1 soctf-imac215-023 CHAN YEW CHUN DANIEL PL1 soctf-imac215-024 CHAN ZHI ZHENG, AMOS PL1 soctf-imac215-025 CHANG HUI ZHEN PL1 soctf-imac215-026 CHANG ZHONG KAI PL1 soctf-imac215-027 CHEN CHAO PL1 soctf-imac215-028 CHEN TONG PL1 soctf-imac215-029 CHENG LE DA, CLEMENT PL1 soctf-imac215-030 CHENG WANYIN PL1 soctf-imac215-031 CHENG WEIXUAN PL1 soctf-imac215-032 CHERYL NG YUN LIN PL1 soctf-imac215-033 CHEW JUN KONG PL1 soctf-imac215-034 CHIA BIING HANN PL1 soctf-imac215-035 CHNG XIAN YI WSLab 3 ws3-002 CHOI WONJAE PL1 soctf-imac215-037 CHU JUI HUNG @JEFFERSON CHU PL1 soctf-imac215-038 CHUA MAI FENG, CARL PL1 soctf-imac215-039 CHUA WEN XUAN PL1 soctf-imac215-040 CHUA ZONG WEI PL1 soctf-imac215-043 CLAIRE CHAN YEN HWA PL1 soctf-imac215-044 CYNTHIA LEE WENG YAN PL1 soctf-imac215-045 DANIEL TAN WEE LIANG PL2 soctf-pl2-002 DANISH B EDDIE PL2 soctf-pl2-003 DARREN ONG PL2 soctf-pl2-004 DEBBIE TAN JIA MIN PL2 soctf-pl2-005 DING NING PL2 soctf-pl2-006 DIVAKARAN HARITHA PL2 soctf-pl2-007 EDMUND TEO WEI XIN PL2 soctf-pl2-009 EU JING SEN PL2 soctf-pl2-010 EVELYN YI-WEN CHEN PL2 soctf-pl2-011 FATIN NABILAH BTE SUHAIMI PL2 soctf-pl2-012 FOO CHI HEN PL2 soctf-pl2-013 GINA QUAH JIE XI PL2 soctf-pl2-014 GLEN WONG SHU ZE PL2 soctf-pl2-016 GOH RUI PING SAMANTHA PL2 soctf-pl2-017 GOH ZHEN HAO JOEY PL2 soctf-pl2-018 GONDHALEKAR SUKRUT YOGESH PL2 soctf-pl2-019 GREGORY TAN WEI YUAN PL2 soctf-pl2-020 GUI XIXIAN PL2 soctf-pl2-021 GUO HAOREN PL2 soctf-pl2-022 HANS KURNIA WIDJAJA PL2 soctf-pl2-023 HAO YUN PL2 soctf-pl2-024 HASHIR ZAHIR PL2 soctf-pl2-025 HENG HONG CHUAN PL2 soctf-pl2-026 HO JING YANG DANIEL PL2 soctf-pl2-028 HO SI SHI ANNETTE PL2 soctf-pl2-029 HO WEI BIN, JERRY PL2 soctf-pl2-030 HU XINYING PL2 soctf-pl2-031 HUANG XUANKUN PL2 soctf-pl2-032 IAN CHUA PL2 soctf-pl2-033 ISABELLA CHEONG XIAO XUAN PL2 soctf-pl2-035 IVAN ANDIKA LIE PL2 soctf-pl2-036 JANEL ANG YEE HUEY PL2 soctf-pl2-037 JASON SATHYA CITRO PL2 soctf-pl2-038 JASPER ONG SHAO YONG PL2 soctf-pl2-039 JAZHTEN LOW YONGSHEN PL2 soctf-pl2-040 JERRY ZHANG ZHUORAN PL2 soctf-pl2-042 JESS TEO XI ZHI PL2 soctf-pl2-043 JOEL CHANG ZHI KAI PL2 soctf-pl2-044 JOHN CUTHBERT KHOO TENG FONG PL2 soctf-pl2-045 JOSEPH WONG YEFENG PL2 soctf-pl2-046 JUSTIN CHIA JIA JIN PL3 soctf-pl3-001 K ALAGES PL3 soctf-pl3-002 KARAN SARAT PL3 soctf-pl3-003 KARNATI SAI ABHISHEK PL3 soctf-pl3-005 KEE KAH LOK PL3 soctf-pl3-006 KEITH CHAN JUN KAI PL3 soctf-pl3-007 KELVIN HARRIS PL3 soctf-pl3-009 KEVIN PUTERA PL3 soctf-pl3-010 KEZIA KEW KAI YUN PL3 soctf-pl3-011 KHAIRUL IMAN NASRI B AZHARIE PL3 soctf-pl3-013 KHOO TZE YANG RAYSON PL3 soctf-pl3-014 KISHORE R PL3 soctf-pl3-015 KWOK KUIN EK JEREMY PL3 soctf-pl3-016 KYAWT KYAWT SAN PL3 soctf-pl3-017 LAI WEN XUAN JEREMY PL3 soctf-pl3-018 LAM TIAN WEI JUSTIN PL3 soctf-pl3-019 LE HONG LONG PL3 soctf-pl3-020 LEE HONG CHIEN, KENNETH PL3 soctf-pl3-021 LEE LI XIN WSLab 3 ws3-003 LEE RAIYAN BIN ZULKIFLI PL3 soctf-pl3-023 LEE WEI HERN, JASON PL3 soctf-pl3-025 LEE YUEYU PL3 soctf-pl3-026 LEE ZHEN YU PL4 soctf-pl4-002 LEOW YONG HENG PL4 soctf-pl4-003 LEOW YONG KANG ANDREW PL4 soctf-pl4-004 LI JIAYU PL4 soctf-pl4-005 LI ZIHAN PL4 soctf-pl4-006 LIAO LIXIN PL4 soctf-pl4-007 LIAO TIANCHANG PL4 soctf-pl4-008 LIM CHEE SENG BRIAN PL4 soctf-pl4-009 LIM CHEK JUN PL4 soctf-pl4-010 LIM CHENG YIN, RYAN PL4 soctf-pl4-011 LIM HAO XIANG, SEAN PL4 soctf-pl4-012 LIM JIA WEI PL4 soctf-pl4-013 LIM JIAYI, TAMELLY PL4 soctf-pl4-014 LIM JUN KUANG, LIONEL PL4 soctf-pl4-015 LIM LI LINCOLN PL4 soctf-pl4-016 LIM SI YING PL4 soctf-pl4-017 LIM TING WEI PL4 soctf-pl4-018 LIM WEN HAN, EUGENE PL4 soctf-pl4-019 LIM YAN TING PL4 soctf-pl4-020 LIN JIAYUE PL4 soctf-pl4-021 LING WEN JIAN PL4 soctf-pl4-022 LIU JINGXUAN PL4 soctf-pl4-023 LIU PEIZE PL5 soctf-pl5-003 LIU SHIRU PL5 soctf-pl5-004 LIU SONGTAO PL5 soctf-pl5-005 LIU WEI JIE NICHOLAS PL5 soctf-pl5-006 LOH CHING WEI, JOSHUA PL5 soctf-pl5-007 LOH YONG ZEE PL5 soctf-pl5-008 LOW EE TER PL5 soctf-pl5-009 LOW JIA YEE PL5 soctf-pl5-010 LOW SIU YUAN, FRANCIS PL5 soctf-pl5-012 LUCAS FOO SOO QUAN PL5 soctf-pl5-013 LYE JUN WEI ANANDA PL5 soctf-pl5-014 MARC PHUA HSIAO MENG PL5 soctf-pl5-015 MATTHEW NATHANAEL SUGIRI PL5 soctf-pl5-016 MERVIN WEE MINGWEN PL5 soctf-pl5-017 MICHELLE TOH HUI PING PL5 soctf-pl5-019 MODAK SHANTANU BHARAT PL5 soctf-pl5-020 MOHAMED RIYAS PL5 soctf-pl5-021 MOHAMMAD YOUSUF MINHAJ ZIA PL5 soctf-pl5-022 MUHAMMAD FAIRUZ B AMIRHAMZAH PL5 soctf-pl5-023 MUHAMMAD HOZEFA ZUMKHAWALA PL6 soctf-pl6-003 MUHAMMAD SHOLIHIN BIN KAMARUDIN PL6 soctf-pl6-004 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN PL6 soctf-pl6-005 NATHAN YEO KEE HERN PL6 soctf-pl6-006 NEO WEN HUI PL6 soctf-pl6-007 NG JIE WU PL6 soctf-pl6-008 NG JING KANG PL6 soctf-pl6-009 NG JING KIAT PL6 soctf-pl6-010 NG SHI QI, CARRIE PL6 soctf-pl6-011 NG SIU HIAN PL6 soctf-pl6-012 NG WEE KIAT PL6 soctf-pl6-013 NG WEI JIE, BRANDON PL6 soctf-pl6-014 NG ZI HUI PL6 soctf-pl6-015 NGAN JI CHENG PL6 soctf-pl6-016 NGUYEN THANH DUC PL6 soctf-pl6-017 NGUYEN TIEN DAT PL6 soctf-pl6-018 NIGEL TAN PL6 soctf-pl6-019 NIGELLE LEO YUWEN PL6 soctf-pl6-020 NISHANTH ELANGO PL6 soctf-pl6-021 NYAN WUN PAING PL6 soctf-pl6-022 OEI CHIU YAN REBECCA PL6 soctf-pl6-023 ONG YU XUAN PL6 soctf-pl6-024 OUNG YONG SHENG KENNEDY PL6 soctf-pl6-025 OW ZHENG KUAN PL6 soctf-pl6-026 P PRADEEP PL6 soctf-pl6-027 PANG JIA JUN VERNON PL6 soctf-pl6-030 PARK SO HYUN PL6 soctf-pl6-031 PARMAR VARUN SAMIR PL6 soctf-pl6-032 PARVATHI RANJITH MENON ESLab 1 pc2 PATWARI RISHAB ESLab 1 pc3 PEI YAN BO ESLab 1 pc5 PHOON JIA JUIN ESLab 1 pc6 POH CHOO LEONG, LINSTON ESLab 1 pc8 PONG LOONG BOB ESLab 1 pc9 POON KAH ONN, BENJAMIN ESLab 1 pc11 POW JING YONG ESLab 1 pc12 QIAN JIE ESLab 1 pc13 QUAH YOU JING KANE ESLab 1 pc14 QUEK AIK PENG ESLab 1 pc15 RAGHAV BHARDWAJ ESLab 1 pc16 RAJAMOHAN B PRIYAN ESLab 1 pc17 RAVEENDRAN AJEY ASHOK ESLab 1 pc18 RISHI MAHADEVAN ESLab 1 pc19 RUSDI HAIZIM B RAHIM ESLab 1 pc20 RYAN TAN YU ESLab 1 pc21 SAI GANESH SURESH ESLab 1 pc22 SCOTT FLOYD ZHEN-YAN SMAHON ESLab 1 pc23 SEE SHENG CHAO WSLab 2 ws2-004 SENTHIL ARAAVIND ESLab 2 pc2 SHA LONG ESLab 2 pc3 SHANNON LEE ESLab 2 pc5 SHAWN WONG JUN KIT WSLab 2 ws2-003 SHRIYA SAXENA ESLab 2 pc8 SIM YU JIE ESLab 2 pc9 SITI NADIAH BINTE MOHAMED RAMLI ESLab 2 pc11 SUTHER DAVID SAMUEL ESLab 2 pc12 TALAGADADIVI DURGA RUKMINI MANASWINI ESLab 2 pc13 TAM WEI IAN JOSHUA ESLab 2 pc14 TAN GUAN YEW ESLab 2 pc15 TAN KAI LI CATHERINE ESLab 2 pc16 TAN KOK JOON ESLab 2 pc17 TAN LI ANN PETER ESLab 2 pc18 TAN YEH HAN, JOHN ESLab 2 pc19 TAN YI XIANG ESLab 2 pc20 TAN ZHENG FU JUSTIN ESLab 2 pc21 TAN ZHENG WEN ESLab 2 pc22 TAY JIN WEN ESLab 2 pc23 TAY JING XUAN ESLab 2 pc24 TAY TZE-WEI, CALEB WSLab 1 ws1-004 TAY YEE EN, RYAN WSLab 1 ws1-005 TEH ZI HUAI WSLab 1 ws1-006 TEO WEI JIE, SHAUN WSLab 1 ws1-007 TOH YING YING JANICE WSLab 1 ws1-008 TONG QI WEI WSLab 1 ws1-009 TRAN MINH DUONG WSLab 1 ws1-010 TRAN QUANG THANH WSLab 1 ws1-011 TSHIN QI REN WSLab 1 ws1-012 UMAR BIN MOIZ WSLab 1 ws1-013 VASAVADA TEJAS SUDHIR WSLab 1 ws1-014 VIDHYABHARATHI SOMASUNDARAM WSLab 1 ws1-015 VIVIAN LEE BOON GEOK WSLab 1 ws1-016 WANG ZICONG WSLab 1 ws1-017 WEI FENG WSLab 1 ws1-018 WENG KEXIN WSLab 1 ws1-019 WONG JIN EN, SHANNON WSLab 1 ws1-020 WONG REN-WEI, RYAN WSLab 1 ws1-021 XUE ZHENGQING WSLab 1 ws1-022 YANG AN QI WSLab 1 ws1-023 YANG CHENGLONG WSLab 1 ws1-024 YANG KAI ZE WSLab 3 ws3-004 YANG ZI YUN WSLab 3 ws3-005 YAP JIN FA WSLab 3 ws3-006 YAP KESIN WSLab 3 ws3-007 YE GUOQUAN WSLab 3 ws3-008 YE TONG WSLab 3 ws3-009 YEN PEI CHIH WSLab 3 ws3-010 YEW JING HUI WSLab 3 ws3-011 YU XIAOXUE WSLab 3 ws3-012 YUAN JIAYI WSLab 3 ws3-013 YUE JUN YI WSLab 3 ws3-014 ZHANG SHIYU WSLab 3 ws3-015 ZHANG YIHAN WSLab 3 ws3-016 ZHANG YIPING WSLab 3 ws3-017 ZHANG YUE HAN WSLab 3 ws3-018 ZHAO PENGFEI WSLab 3 ws3-019 ZHAO TIANQI WSLab 3 ws3-020 ZHENG KAINING WSLab 3 ws3-021 ZHU BO WSLab 3 ws3-022 ZHU YIJIE WSLab 3 ws3-023 ZOE WONG XIN LEI WSLab 3 ws3-024","title":"Info About PE1"},{"location":"pe1.html#practice-exam-1","text":"","title":"Practice Exam 1"},{"location":"pe1.html#questions","text":"Exam Paper Click on GitHub Link to accept, run get-pe01 and submit-pe01 to solve this like any other assignments.","title":"Questions"},{"location":"pe1.html#basic-info","text":"Date: 6 October, 2018 (Saturday) Time: 9am to 12noon Venue: Various programming labs Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 4 to 5 programming questions, very easy to hard Criteria: Correctness and Style. One mark is allocated for programming style for each question. Duration: 2 hours and 30 minutes Open Book (You can bring analog references)","title":"Basic Info"},{"location":"pe1.html#lab-allocation","text":"Every student is assigned to a programming lab. Please see the allocation below. You should acclimatize yourself to the use of the PC desktops in the lab assigned to you. Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2) Here are the locatons for the respective labs","title":"Lab Allocation"},{"location":"pe1.html#special-restrictions","text":"You will be issued a special account on the PE day to solve the exam questions. There will be no Internet access.","title":"Special Restrictions"},{"location":"pe1.html#vim-configuration","text":"Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins.","title":"Vim Configuration"},{"location":"pe1.html#czjqqkd4general-adviceczjqqkd5","text":"Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? what is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so. You will be given a question form to ask questions to clarify doubts about the question paper. But note that you can only ask a boolean question (YES/NO answer). Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases.","title":"\u0002czjqqkd:4\u0003General Advice\u0002czjqqkd:5\u0003"},{"location":"pe1.html#lab-and-seat-allocation","text":"NAME Venue Seat Number AARUSHI SINGH PL1 soctf-imac215-002 ADELYN KOH JING YING PL1 soctf-imac215-003 AHMAD MUDAAFI' B ZAINUDDIN PL1 soctf-imac215-004 AI ZHENGWEI PL1 soctf-imac215-005 ALEX TEO KANG JIE PL1 soctf-imac215-008 AMIR AZHAR B AZIZAN PL1 soctf-imac215-009 ANDREW LAU JIA JUN PL1 soctf-imac215-010 ANG KENG SIANG PL1 soctf-imac215-011 ANG KIANG YANG PL1 soctf-imac215-012 AW CHIAN HAO PL1 soctf-imac215-013 BALAM SAI ROHIT REDDY PL1 soctf-imac215-014 BEATRICE CHAN TONG PL1 soctf-imac215-015 BENEDICT YU CHENG EN PL1 soctf-imac215-016 BENJAMIN CHIA SHAN HONG PL1 soctf-imac215-017 CAI RONG PL1 soctf-imac215-019 CHAN EE ZHENG, BENJAMIN PL1 soctf-imac215-020 CHAN HIN, SEAN PL1 soctf-imac215-021 CHAN WEI FONG, MAX PL1 soctf-imac215-022 CHAN YEE CHONG PHILIP PL1 soctf-imac215-023 CHAN YEW CHUN DANIEL PL1 soctf-imac215-024 CHAN ZHI ZHENG, AMOS PL1 soctf-imac215-025 CHANG HUI ZHEN PL1 soctf-imac215-026 CHANG ZHONG KAI PL1 soctf-imac215-027 CHEN CHAO PL1 soctf-imac215-028 CHEN TONG PL1 soctf-imac215-029 CHENG LE DA, CLEMENT PL1 soctf-imac215-030 CHENG WANYIN PL1 soctf-imac215-031 CHENG WEIXUAN PL1 soctf-imac215-032 CHERYL NG YUN LIN PL1 soctf-imac215-033 CHEW JUN KONG PL1 soctf-imac215-034 CHIA BIING HANN PL1 soctf-imac215-035 CHNG XIAN YI WSLab 3 ws3-002 CHOI WONJAE PL1 soctf-imac215-037 CHU JUI HUNG @JEFFERSON CHU PL1 soctf-imac215-038 CHUA MAI FENG, CARL PL1 soctf-imac215-039 CHUA WEN XUAN PL1 soctf-imac215-040 CHUA ZONG WEI PL1 soctf-imac215-043 CLAIRE CHAN YEN HWA PL1 soctf-imac215-044 CYNTHIA LEE WENG YAN PL1 soctf-imac215-045 DANIEL TAN WEE LIANG PL2 soctf-pl2-002 DANISH B EDDIE PL2 soctf-pl2-003 DARREN ONG PL2 soctf-pl2-004 DEBBIE TAN JIA MIN PL2 soctf-pl2-005 DING NING PL2 soctf-pl2-006 DIVAKARAN HARITHA PL2 soctf-pl2-007 EDMUND TEO WEI XIN PL2 soctf-pl2-009 EU JING SEN PL2 soctf-pl2-010 EVELYN YI-WEN CHEN PL2 soctf-pl2-011 FATIN NABILAH BTE SUHAIMI PL2 soctf-pl2-012 FOO CHI HEN PL2 soctf-pl2-013 GINA QUAH JIE XI PL2 soctf-pl2-014 GLEN WONG SHU ZE PL2 soctf-pl2-016 GOH RUI PING SAMANTHA PL2 soctf-pl2-017 GOH ZHEN HAO JOEY PL2 soctf-pl2-018 GONDHALEKAR SUKRUT YOGESH PL2 soctf-pl2-019 GREGORY TAN WEI YUAN PL2 soctf-pl2-020 GUI XIXIAN PL2 soctf-pl2-021 GUO HAOREN PL2 soctf-pl2-022 HANS KURNIA WIDJAJA PL2 soctf-pl2-023 HAO YUN PL2 soctf-pl2-024 HASHIR ZAHIR PL2 soctf-pl2-025 HENG HONG CHUAN PL2 soctf-pl2-026 HO JING YANG DANIEL PL2 soctf-pl2-028 HO SI SHI ANNETTE PL2 soctf-pl2-029 HO WEI BIN, JERRY PL2 soctf-pl2-030 HU XINYING PL2 soctf-pl2-031 HUANG XUANKUN PL2 soctf-pl2-032 IAN CHUA PL2 soctf-pl2-033 ISABELLA CHEONG XIAO XUAN PL2 soctf-pl2-035 IVAN ANDIKA LIE PL2 soctf-pl2-036 JANEL ANG YEE HUEY PL2 soctf-pl2-037 JASON SATHYA CITRO PL2 soctf-pl2-038 JASPER ONG SHAO YONG PL2 soctf-pl2-039 JAZHTEN LOW YONGSHEN PL2 soctf-pl2-040 JERRY ZHANG ZHUORAN PL2 soctf-pl2-042 JESS TEO XI ZHI PL2 soctf-pl2-043 JOEL CHANG ZHI KAI PL2 soctf-pl2-044 JOHN CUTHBERT KHOO TENG FONG PL2 soctf-pl2-045 JOSEPH WONG YEFENG PL2 soctf-pl2-046 JUSTIN CHIA JIA JIN PL3 soctf-pl3-001 K ALAGES PL3 soctf-pl3-002 KARAN SARAT PL3 soctf-pl3-003 KARNATI SAI ABHISHEK PL3 soctf-pl3-005 KEE KAH LOK PL3 soctf-pl3-006 KEITH CHAN JUN KAI PL3 soctf-pl3-007 KELVIN HARRIS PL3 soctf-pl3-009 KEVIN PUTERA PL3 soctf-pl3-010 KEZIA KEW KAI YUN PL3 soctf-pl3-011 KHAIRUL IMAN NASRI B AZHARIE PL3 soctf-pl3-013 KHOO TZE YANG RAYSON PL3 soctf-pl3-014 KISHORE R PL3 soctf-pl3-015 KWOK KUIN EK JEREMY PL3 soctf-pl3-016 KYAWT KYAWT SAN PL3 soctf-pl3-017 LAI WEN XUAN JEREMY PL3 soctf-pl3-018 LAM TIAN WEI JUSTIN PL3 soctf-pl3-019 LE HONG LONG PL3 soctf-pl3-020 LEE HONG CHIEN, KENNETH PL3 soctf-pl3-021 LEE LI XIN WSLab 3 ws3-003 LEE RAIYAN BIN ZULKIFLI PL3 soctf-pl3-023 LEE WEI HERN, JASON PL3 soctf-pl3-025 LEE YUEYU PL3 soctf-pl3-026 LEE ZHEN YU PL4 soctf-pl4-002 LEOW YONG HENG PL4 soctf-pl4-003 LEOW YONG KANG ANDREW PL4 soctf-pl4-004 LI JIAYU PL4 soctf-pl4-005 LI ZIHAN PL4 soctf-pl4-006 LIAO LIXIN PL4 soctf-pl4-007 LIAO TIANCHANG PL4 soctf-pl4-008 LIM CHEE SENG BRIAN PL4 soctf-pl4-009 LIM CHEK JUN PL4 soctf-pl4-010 LIM CHENG YIN, RYAN PL4 soctf-pl4-011 LIM HAO XIANG, SEAN PL4 soctf-pl4-012 LIM JIA WEI PL4 soctf-pl4-013 LIM JIAYI, TAMELLY PL4 soctf-pl4-014 LIM JUN KUANG, LIONEL PL4 soctf-pl4-015 LIM LI LINCOLN PL4 soctf-pl4-016 LIM SI YING PL4 soctf-pl4-017 LIM TING WEI PL4 soctf-pl4-018 LIM WEN HAN, EUGENE PL4 soctf-pl4-019 LIM YAN TING PL4 soctf-pl4-020 LIN JIAYUE PL4 soctf-pl4-021 LING WEN JIAN PL4 soctf-pl4-022 LIU JINGXUAN PL4 soctf-pl4-023 LIU PEIZE PL5 soctf-pl5-003 LIU SHIRU PL5 soctf-pl5-004 LIU SONGTAO PL5 soctf-pl5-005 LIU WEI JIE NICHOLAS PL5 soctf-pl5-006 LOH CHING WEI, JOSHUA PL5 soctf-pl5-007 LOH YONG ZEE PL5 soctf-pl5-008 LOW EE TER PL5 soctf-pl5-009 LOW JIA YEE PL5 soctf-pl5-010 LOW SIU YUAN, FRANCIS PL5 soctf-pl5-012 LUCAS FOO SOO QUAN PL5 soctf-pl5-013 LYE JUN WEI ANANDA PL5 soctf-pl5-014 MARC PHUA HSIAO MENG PL5 soctf-pl5-015 MATTHEW NATHANAEL SUGIRI PL5 soctf-pl5-016 MERVIN WEE MINGWEN PL5 soctf-pl5-017 MICHELLE TOH HUI PING PL5 soctf-pl5-019 MODAK SHANTANU BHARAT PL5 soctf-pl5-020 MOHAMED RIYAS PL5 soctf-pl5-021 MOHAMMAD YOUSUF MINHAJ ZIA PL5 soctf-pl5-022 MUHAMMAD FAIRUZ B AMIRHAMZAH PL5 soctf-pl5-023 MUHAMMAD HOZEFA ZUMKHAWALA PL6 soctf-pl6-003 MUHAMMAD SHOLIHIN BIN KAMARUDIN PL6 soctf-pl6-004 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN PL6 soctf-pl6-005 NATHAN YEO KEE HERN PL6 soctf-pl6-006 NEO WEN HUI PL6 soctf-pl6-007 NG JIE WU PL6 soctf-pl6-008 NG JING KANG PL6 soctf-pl6-009 NG JING KIAT PL6 soctf-pl6-010 NG SHI QI, CARRIE PL6 soctf-pl6-011 NG SIU HIAN PL6 soctf-pl6-012 NG WEE KIAT PL6 soctf-pl6-013 NG WEI JIE, BRANDON PL6 soctf-pl6-014 NG ZI HUI PL6 soctf-pl6-015 NGAN JI CHENG PL6 soctf-pl6-016 NGUYEN THANH DUC PL6 soctf-pl6-017 NGUYEN TIEN DAT PL6 soctf-pl6-018 NIGEL TAN PL6 soctf-pl6-019 NIGELLE LEO YUWEN PL6 soctf-pl6-020 NISHANTH ELANGO PL6 soctf-pl6-021 NYAN WUN PAING PL6 soctf-pl6-022 OEI CHIU YAN REBECCA PL6 soctf-pl6-023 ONG YU XUAN PL6 soctf-pl6-024 OUNG YONG SHENG KENNEDY PL6 soctf-pl6-025 OW ZHENG KUAN PL6 soctf-pl6-026 P PRADEEP PL6 soctf-pl6-027 PANG JIA JUN VERNON PL6 soctf-pl6-030 PARK SO HYUN PL6 soctf-pl6-031 PARMAR VARUN SAMIR PL6 soctf-pl6-032 PARVATHI RANJITH MENON ESLab 1 pc2 PATWARI RISHAB ESLab 1 pc3 PEI YAN BO ESLab 1 pc5 PHOON JIA JUIN ESLab 1 pc6 POH CHOO LEONG, LINSTON ESLab 1 pc8 PONG LOONG BOB ESLab 1 pc9 POON KAH ONN, BENJAMIN ESLab 1 pc11 POW JING YONG ESLab 1 pc12 QIAN JIE ESLab 1 pc13 QUAH YOU JING KANE ESLab 1 pc14 QUEK AIK PENG ESLab 1 pc15 RAGHAV BHARDWAJ ESLab 1 pc16 RAJAMOHAN B PRIYAN ESLab 1 pc17 RAVEENDRAN AJEY ASHOK ESLab 1 pc18 RISHI MAHADEVAN ESLab 1 pc19 RUSDI HAIZIM B RAHIM ESLab 1 pc20 RYAN TAN YU ESLab 1 pc21 SAI GANESH SURESH ESLab 1 pc22 SCOTT FLOYD ZHEN-YAN SMAHON ESLab 1 pc23 SEE SHENG CHAO WSLab 2 ws2-004 SENTHIL ARAAVIND ESLab 2 pc2 SHA LONG ESLab 2 pc3 SHANNON LEE ESLab 2 pc5 SHAWN WONG JUN KIT WSLab 2 ws2-003 SHRIYA SAXENA ESLab 2 pc8 SIM YU JIE ESLab 2 pc9 SITI NADIAH BINTE MOHAMED RAMLI ESLab 2 pc11 SUTHER DAVID SAMUEL ESLab 2 pc12 TALAGADADIVI DURGA RUKMINI MANASWINI ESLab 2 pc13 TAM WEI IAN JOSHUA ESLab 2 pc14 TAN GUAN YEW ESLab 2 pc15 TAN KAI LI CATHERINE ESLab 2 pc16 TAN KOK JOON ESLab 2 pc17 TAN LI ANN PETER ESLab 2 pc18 TAN YEH HAN, JOHN ESLab 2 pc19 TAN YI XIANG ESLab 2 pc20 TAN ZHENG FU JUSTIN ESLab 2 pc21 TAN ZHENG WEN ESLab 2 pc22 TAY JIN WEN ESLab 2 pc23 TAY JING XUAN ESLab 2 pc24 TAY TZE-WEI, CALEB WSLab 1 ws1-004 TAY YEE EN, RYAN WSLab 1 ws1-005 TEH ZI HUAI WSLab 1 ws1-006 TEO WEI JIE, SHAUN WSLab 1 ws1-007 TOH YING YING JANICE WSLab 1 ws1-008 TONG QI WEI WSLab 1 ws1-009 TRAN MINH DUONG WSLab 1 ws1-010 TRAN QUANG THANH WSLab 1 ws1-011 TSHIN QI REN WSLab 1 ws1-012 UMAR BIN MOIZ WSLab 1 ws1-013 VASAVADA TEJAS SUDHIR WSLab 1 ws1-014 VIDHYABHARATHI SOMASUNDARAM WSLab 1 ws1-015 VIVIAN LEE BOON GEOK WSLab 1 ws1-016 WANG ZICONG WSLab 1 ws1-017 WEI FENG WSLab 1 ws1-018 WENG KEXIN WSLab 1 ws1-019 WONG JIN EN, SHANNON WSLab 1 ws1-020 WONG REN-WEI, RYAN WSLab 1 ws1-021 XUE ZHENGQING WSLab 1 ws1-022 YANG AN QI WSLab 1 ws1-023 YANG CHENGLONG WSLab 1 ws1-024 YANG KAI ZE WSLab 3 ws3-004 YANG ZI YUN WSLab 3 ws3-005 YAP JIN FA WSLab 3 ws3-006 YAP KESIN WSLab 3 ws3-007 YE GUOQUAN WSLab 3 ws3-008 YE TONG WSLab 3 ws3-009 YEN PEI CHIH WSLab 3 ws3-010 YEW JING HUI WSLab 3 ws3-011 YU XIAOXUE WSLab 3 ws3-012 YUAN JIAYI WSLab 3 ws3-013 YUE JUN YI WSLab 3 ws3-014 ZHANG SHIYU WSLab 3 ws3-015 ZHANG YIHAN WSLab 3 ws3-016 ZHANG YIPING WSLab 3 ws3-017 ZHANG YUE HAN WSLab 3 ws3-018 ZHAO PENGFEI WSLab 3 ws3-019 ZHAO TIANQI WSLab 3 ws3-020 ZHENG KAINING WSLab 3 ws3-021 ZHU BO WSLab 3 ws3-022 ZHU YIJIE WSLab 3 ws3-023 ZOE WONG XIN LEI WSLab 3 ws3-024","title":"Lab and Seat Allocation"},{"location":"pe2-comments.html","text":"PE2: Comments and Answer Keys transpose This is suppose to be a give-away question. We want to see if you can manipulate 2D arrays, including stepping through the elements, and allocating/deallocating the memory for them. First, let's write some functions to allocate, read, print, transpose and free a matrix. /** * Allocated and read a matrix from the standard input. * The caller is responsible to free the matrix. * * @param[in] row The number of rows to read. * @param[in] col The number of columns to read. * @return A 2D array containing the matrix. */ double ** read_matrix ( long row , long col ) { double ** m = calloc ( row , sizeof ( double * )); for ( long i = 0 ; i < row ; i += 1 ) { m [ i ] = cs1010_read_double_array ( col ); assert ( m [ i ] != NULL ); } return m ; } /** * Allocated a 2D matrix of 0s. * The caller is responsible to free the matrix. * * @param[in] row The number of rows to allocate. * @param[in] col The number of columns to allocate. * @return A 2D array containing the matrix. */ double ** alloc_matrix ( long row , long col ) { double ** m = calloc ( row , sizeof ( double * )); for ( long i = 0 ; i < row ; i += 1 ) { m [ i ] = calloc ( col , sizeof ( double )); } return m ; } /** * Print a given 2D matrix. * * @param[in] m The matrix to print. * @param[in] row The number of rows to print. * @param[in] col The number of columns to print. */ void print_matrix ( double ** m , long row , long col ) { for ( long i = 0 ; i < row ; i += 1 ) { for ( long j = 0 ; j < col ; j += 1 ) { cs1010_print_double ( m [ i ][ j ]); if ( j == col - 1 ) { cs1010_println_string ( \"\" ); } else { cs1010_print_string ( \" \" ); } } } } /** * Free the memory allocated for a 2D matrix. * * @param[in] m The matrix to free. * @param[in] row The number of rows in the matrix m. */ void free_matrix ( double ** m , long row ) { for ( long i = 0 ; i < row ; i += 1 ) { free ( m [ i ]); } free ( m ); } /** * Transpose a given matrix m1 and store the output in m2. * * @param[in] m1 The given matrix to transpose. * @param[out] m2 The transposed matrix. * @param[in] num_of_rows The number of rows in m1. * @param[in] num_of_cols The number of rows in m2. */ void transpose ( double ** m1 , double ** m2 , long num_of_rows , long num_of_cols ) { for ( long i = 0 ; i < num_of_rows ; i += 1 ) { for ( long j = 0 ; j < num_of_cols ; j += 1 ) { assert ( m1 [ i ] != NULL ); assert ( m2 [ j ] != NULL ); m2 [ j ][ i ] = m1 [ i ][ j ]; } } } The main program then looks like this: int main () { long num_rows = cs1010_read_long (); long num_cols = cs1010_read_long (); double ** m1 = read_matrix ( num_rows , num_cols ); double ** m2 = alloc_matrix ( num_cols , num_rows ); transpose ( m1 , m2 , num_rows , num_cols ); print_matrix ( m2 , num_cols , num_rows ); free_matrix ( m1 , num_rows ); free_matrix ( m2 , num_cols ); } palindrome This is a classic programming question and is also fairly simple. We want to see if you knows how to manipulate a string. Here is a loop version: bool is_palindrome ( char * s ) { long start = - 1 ; long end = strlen ( s ); do { do { start += 1 ; } while ( ! isalpha ( s [ start ])); do { end -= 1 ; } while ( ! isalpha ( s [ end ])); if ( tolower ( s [ start ]) != tolower ( s [ end ])) { return false ; } } while ( start < end ); return true ; } The two innwer loops skip the non-alphabetical characters at the beginning and at the end of the string. After we ensure that s[start] and s[end] are both alphabets, we compare the lower-case version. If they are different, then it is not a palindrome and we return false. Otherwise, we continue. If we have exhausted all the characters in the string and we have not returned false, then the string must be a palindrome. Here is a recursive version: bool is_palindrome ( char * s , long start , long end ) { if ( start >= end ) { return true ; } if ( ! isalpha ( s [ start ])) { return is_palindrome ( s , start + 1 , end ); } if ( ! isalpha ( s [ end ])) { return is_palindrome ( s , start , end - 1 ); } if ( tolower ( s [ start ]) == tolower ( s [ end ])) { return is_palindrome ( s , start + 1 , end - 1 ); } return false ; } rotate Getting 4 marks for this question is trivial (using a linear search). But trying to get all 9 marks is not so straight forward. It requires a tweak to the binary search to solve in O(\\log n) O(\\log n) time. The fact that it requires O(\\log n) O(\\log n) time hinted at the need to halve the array at every recursive call. To decide which half to search, we first have to analyze the properties of the input. The properties can be summarized as follows: But once you have the cases above, the code is quiet straightforward. If q falls under the half that is a sorted array, then we perform binary search on that half, otherwise, we recursively call the function to search in the rotated and sorted array on the other half. /** * Look for q in list[i]..list[j]. * * @pre list is sorted. * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( j < i ) { return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } /* * - list[i]..list[mid] is strictly increasing. So we do binary search * if q falls within this range. Otherwise, we recursively search * the other half (which is a rotated list). */ if ( list [ i ] < list [ mid ]) { if ( list [ i ] <= q && q <= list [ mid ]) { return binary_search ( list , i , mid - 1 , q ); } return search ( list , mid + 1 , j , q ); } /* * - list[i]..list[mid] is rotated. So we do a binary search on the * other half. */ if ( list [ mid + 1 ] <= q && q <= list [ j ]) { return binary_search ( list , mid + 1 , j , q ); } return search ( list , i , mid - 1 , q ); } Here, the function binary_search is the same one given in the lecture. marcell This question is designed to check if you know how to write efficient code. It is an extension to goldbach from PE1. The prerequisite to solving this question well is that you must know how to find a prime number in O(\\sqrt{n}) O(\\sqrt{n}) time. If you have been paying attention to Assignment 2, PE1 Comments, and Unit 22, you should have what it takes to solve this. Everyone's first instict would be to write a function is_prime and a function is_semiprime to check if a number is prime or semiprime. However, our second principle of writing efficient code avoid repetitive work , applies here. If you wrote these two functions, you will notice that we need to scan through numbers between 2 to \\sqrt{n} \\sqrt{n} for an input n n for both functions. So we could combine them into one function: long is_prime_or_semiprime ( long n ) { if ( n <= 1 ) { return NEITHER ; } for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { if ( is_prime ( i ) && is_prime ( n / i )) { return SEMIPRIME ; } return NEITHER ; } } return PRIME ; } Update: Line 6 of the function was originally: if ( is_prime_or_semiprime ( i ) == PRIME && is_prime_or_semiprime ( n / i ) == PRIME ) { We have replaced the line with if ( is_prime ( i ) && is_prime ( n / i )) { so that the running time can be analyzed to be O(\\sqrt{n}) O(\\sqrt{n}) in a more straight forward manner. With the above function, finding the number of pairs is not much different from goldbach : int counter = 0 ; for ( long i = 2 ; i <= n / 2 ; i += 1 ) { long p1 = is_prime_or_semiprime ( i ); if ( p1 == PRIME || p1 == SEMIPRIME ) { long j = n - i ; int p2 = is_prime_or_semiprime ( j ); if (( p1 == PRIME && p2 == SEMIPRIME ) || ( p1 == SEMIPRIME && p2 == PRIME )) { counter += 1 ; } } } bracket This is meant to be the hardest question that separates A+ from A students. Note that, if we ignore condition 2(i) (a valid string can be a concatenation of two valid strings), a valid string is just a \"palindrome\" consisting of characters ({[<>]}) , except that we match the opening brackets to the closing brackets instead of the same characters. If you solve that by modifying the recursive version of the palindrome code above, you should get some partial correctness marks. The tricky part is to handle condition 2(i). So our recursive function has to tell us, if the input string contains a valid string, and where does it ends. One solution is to write a recursive function that \"consumes\" a valid string (and only a valid string) recursively, and returns the next character that is unconsumed. If the next character is \\0 , then the string must be a valid string, since everything is consumed. Let's first write a couple of helper functions: bool is_open ( char c ) { return c == '(' || c == '{' || c == '[' || c == '<' ; } The above checks if a given character is an open bracket. bool is_matching_close ( char c , char d ) { return ( c == '(' && d == ')' ) || ( c == '{' && d == '}' ) || ( c == '<' && d == '>' ) || ( c == '[' && d == ']' ); } The above checks if a pair of input characters are matching brackets. And now, the recursive function to consume a valid string. It returns the index to the first character that is not consumed. int consume_valid ( char * string , int begin ) { if ( string [ begin ] == '\\0' ) { return begin ; } if ( ! is_open ( string [ begin ])) { return begin ; } int end = consume_valid ( string , begin + 1 ); if ( is_matching_close ( string [ begin ], string [ end ])) { return consume_valid ( string , end + 1 ); } return begin ; } Let's first look at Line 2-4. If the input string is empty, then by Rule 1 it is always valid. Line 5-7 checks if the input string starts with a closing bracket. If so, it cannot be a valid string and the function consumes nothing. By Rule 2, it must starts with an open bracket. So we return begin since this is the index to the first unconsumed character. When we reach Line 9, we can assert that the string begins with an open bracket. So we consume the string from index begin + 1 onwards recursively. By wishful thinking, we can assume that this function will consume a valid string and returns the index of the first unconsumed character. We now check on Line 10, if this unconsumed character ( string[end] ) is a matching close bracket to string[begin] , following Rule 2(ii). If it does not match, then we return begin (Line 13) since string[begin] is the first unmatched character (so the function spews out all the consumed characters and un-consumes them). If Line 10 checks out, then the string from begin to end is valid, and we continue to recursively consume from character end + 1 onwards. In main , we call the function as follows: int end = is_valid ( str , 0 ); if ( str [ end ] == '\\0' ) { cs1010_println_string ( \"yes\" ); } else { cs1010_println_string ( \"no\" ); }","title":"PE2 Comments and Answers"},{"location":"pe2-comments.html#pe2-comments-and-answer-keys","text":"","title":"PE2: Comments and Answer Keys"},{"location":"pe2-comments.html#transpose","text":"This is suppose to be a give-away question. We want to see if you can manipulate 2D arrays, including stepping through the elements, and allocating/deallocating the memory for them. First, let's write some functions to allocate, read, print, transpose and free a matrix. /** * Allocated and read a matrix from the standard input. * The caller is responsible to free the matrix. * * @param[in] row The number of rows to read. * @param[in] col The number of columns to read. * @return A 2D array containing the matrix. */ double ** read_matrix ( long row , long col ) { double ** m = calloc ( row , sizeof ( double * )); for ( long i = 0 ; i < row ; i += 1 ) { m [ i ] = cs1010_read_double_array ( col ); assert ( m [ i ] != NULL ); } return m ; } /** * Allocated a 2D matrix of 0s. * The caller is responsible to free the matrix. * * @param[in] row The number of rows to allocate. * @param[in] col The number of columns to allocate. * @return A 2D array containing the matrix. */ double ** alloc_matrix ( long row , long col ) { double ** m = calloc ( row , sizeof ( double * )); for ( long i = 0 ; i < row ; i += 1 ) { m [ i ] = calloc ( col , sizeof ( double )); } return m ; } /** * Print a given 2D matrix. * * @param[in] m The matrix to print. * @param[in] row The number of rows to print. * @param[in] col The number of columns to print. */ void print_matrix ( double ** m , long row , long col ) { for ( long i = 0 ; i < row ; i += 1 ) { for ( long j = 0 ; j < col ; j += 1 ) { cs1010_print_double ( m [ i ][ j ]); if ( j == col - 1 ) { cs1010_println_string ( \"\" ); } else { cs1010_print_string ( \" \" ); } } } } /** * Free the memory allocated for a 2D matrix. * * @param[in] m The matrix to free. * @param[in] row The number of rows in the matrix m. */ void free_matrix ( double ** m , long row ) { for ( long i = 0 ; i < row ; i += 1 ) { free ( m [ i ]); } free ( m ); } /** * Transpose a given matrix m1 and store the output in m2. * * @param[in] m1 The given matrix to transpose. * @param[out] m2 The transposed matrix. * @param[in] num_of_rows The number of rows in m1. * @param[in] num_of_cols The number of rows in m2. */ void transpose ( double ** m1 , double ** m2 , long num_of_rows , long num_of_cols ) { for ( long i = 0 ; i < num_of_rows ; i += 1 ) { for ( long j = 0 ; j < num_of_cols ; j += 1 ) { assert ( m1 [ i ] != NULL ); assert ( m2 [ j ] != NULL ); m2 [ j ][ i ] = m1 [ i ][ j ]; } } } The main program then looks like this: int main () { long num_rows = cs1010_read_long (); long num_cols = cs1010_read_long (); double ** m1 = read_matrix ( num_rows , num_cols ); double ** m2 = alloc_matrix ( num_cols , num_rows ); transpose ( m1 , m2 , num_rows , num_cols ); print_matrix ( m2 , num_cols , num_rows ); free_matrix ( m1 , num_rows ); free_matrix ( m2 , num_cols ); }","title":"transpose"},{"location":"pe2-comments.html#palindrome","text":"This is a classic programming question and is also fairly simple. We want to see if you knows how to manipulate a string. Here is a loop version: bool is_palindrome ( char * s ) { long start = - 1 ; long end = strlen ( s ); do { do { start += 1 ; } while ( ! isalpha ( s [ start ])); do { end -= 1 ; } while ( ! isalpha ( s [ end ])); if ( tolower ( s [ start ]) != tolower ( s [ end ])) { return false ; } } while ( start < end ); return true ; } The two innwer loops skip the non-alphabetical characters at the beginning and at the end of the string. After we ensure that s[start] and s[end] are both alphabets, we compare the lower-case version. If they are different, then it is not a palindrome and we return false. Otherwise, we continue. If we have exhausted all the characters in the string and we have not returned false, then the string must be a palindrome. Here is a recursive version: bool is_palindrome ( char * s , long start , long end ) { if ( start >= end ) { return true ; } if ( ! isalpha ( s [ start ])) { return is_palindrome ( s , start + 1 , end ); } if ( ! isalpha ( s [ end ])) { return is_palindrome ( s , start , end - 1 ); } if ( tolower ( s [ start ]) == tolower ( s [ end ])) { return is_palindrome ( s , start + 1 , end - 1 ); } return false ; }","title":"palindrome"},{"location":"pe2-comments.html#rotate","text":"Getting 4 marks for this question is trivial (using a linear search). But trying to get all 9 marks is not so straight forward. It requires a tweak to the binary search to solve in O(\\log n) O(\\log n) time. The fact that it requires O(\\log n) O(\\log n) time hinted at the need to halve the array at every recursive call. To decide which half to search, we first have to analyze the properties of the input. The properties can be summarized as follows: But once you have the cases above, the code is quiet straightforward. If q falls under the half that is a sorted array, then we perform binary search on that half, otherwise, we recursively call the function to search in the rotated and sorted array on the other half. /** * Look for q in list[i]..list[j]. * * @pre list is sorted. * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( j < i ) { return - 1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } /* * - list[i]..list[mid] is strictly increasing. So we do binary search * if q falls within this range. Otherwise, we recursively search * the other half (which is a rotated list). */ if ( list [ i ] < list [ mid ]) { if ( list [ i ] <= q && q <= list [ mid ]) { return binary_search ( list , i , mid - 1 , q ); } return search ( list , mid + 1 , j , q ); } /* * - list[i]..list[mid] is rotated. So we do a binary search on the * other half. */ if ( list [ mid + 1 ] <= q && q <= list [ j ]) { return binary_search ( list , mid + 1 , j , q ); } return search ( list , i , mid - 1 , q ); } Here, the function binary_search is the same one given in the lecture.","title":"rotate"},{"location":"pe2-comments.html#marcell","text":"This question is designed to check if you know how to write efficient code. It is an extension to goldbach from PE1. The prerequisite to solving this question well is that you must know how to find a prime number in O(\\sqrt{n}) O(\\sqrt{n}) time. If you have been paying attention to Assignment 2, PE1 Comments, and Unit 22, you should have what it takes to solve this. Everyone's first instict would be to write a function is_prime and a function is_semiprime to check if a number is prime or semiprime. However, our second principle of writing efficient code avoid repetitive work , applies here. If you wrote these two functions, you will notice that we need to scan through numbers between 2 to \\sqrt{n} \\sqrt{n} for an input n n for both functions. So we could combine them into one function: long is_prime_or_semiprime ( long n ) { if ( n <= 1 ) { return NEITHER ; } for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { if ( is_prime ( i ) && is_prime ( n / i )) { return SEMIPRIME ; } return NEITHER ; } } return PRIME ; } Update: Line 6 of the function was originally: if ( is_prime_or_semiprime ( i ) == PRIME && is_prime_or_semiprime ( n / i ) == PRIME ) { We have replaced the line with if ( is_prime ( i ) && is_prime ( n / i )) { so that the running time can be analyzed to be O(\\sqrt{n}) O(\\sqrt{n}) in a more straight forward manner. With the above function, finding the number of pairs is not much different from goldbach : int counter = 0 ; for ( long i = 2 ; i <= n / 2 ; i += 1 ) { long p1 = is_prime_or_semiprime ( i ); if ( p1 == PRIME || p1 == SEMIPRIME ) { long j = n - i ; int p2 = is_prime_or_semiprime ( j ); if (( p1 == PRIME && p2 == SEMIPRIME ) || ( p1 == SEMIPRIME && p2 == PRIME )) { counter += 1 ; } } }","title":"marcell"},{"location":"pe2-comments.html#bracket","text":"This is meant to be the hardest question that separates A+ from A students. Note that, if we ignore condition 2(i) (a valid string can be a concatenation of two valid strings), a valid string is just a \"palindrome\" consisting of characters ({[<>]}) , except that we match the opening brackets to the closing brackets instead of the same characters. If you solve that by modifying the recursive version of the palindrome code above, you should get some partial correctness marks. The tricky part is to handle condition 2(i). So our recursive function has to tell us, if the input string contains a valid string, and where does it ends. One solution is to write a recursive function that \"consumes\" a valid string (and only a valid string) recursively, and returns the next character that is unconsumed. If the next character is \\0 , then the string must be a valid string, since everything is consumed. Let's first write a couple of helper functions: bool is_open ( char c ) { return c == '(' || c == '{' || c == '[' || c == '<' ; } The above checks if a given character is an open bracket. bool is_matching_close ( char c , char d ) { return ( c == '(' && d == ')' ) || ( c == '{' && d == '}' ) || ( c == '<' && d == '>' ) || ( c == '[' && d == ']' ); } The above checks if a pair of input characters are matching brackets. And now, the recursive function to consume a valid string. It returns the index to the first character that is not consumed. int consume_valid ( char * string , int begin ) { if ( string [ begin ] == '\\0' ) { return begin ; } if ( ! is_open ( string [ begin ])) { return begin ; } int end = consume_valid ( string , begin + 1 ); if ( is_matching_close ( string [ begin ], string [ end ])) { return consume_valid ( string , end + 1 ); } return begin ; } Let's first look at Line 2-4. If the input string is empty, then by Rule 1 it is always valid. Line 5-7 checks if the input string starts with a closing bracket. If so, it cannot be a valid string and the function consumes nothing. By Rule 2, it must starts with an open bracket. So we return begin since this is the index to the first unconsumed character. When we reach Line 9, we can assert that the string begins with an open bracket. So we consume the string from index begin + 1 onwards recursively. By wishful thinking, we can assume that this function will consume a valid string and returns the index of the first unconsumed character. We now check on Line 10, if this unconsumed character ( string[end] ) is a matching close bracket to string[begin] , following Rule 2(ii). If it does not match, then we return begin (Line 13) since string[begin] is the first unmatched character (so the function spews out all the consumed characters and un-consumes them). If Line 10 checks out, then the string from begin to end is valid, and we continue to recursively consume from character end + 1 onwards. In main , we call the function as follows: int end = is_valid ( str , 0 ); if ( str [ end ] == '\\0' ) { cs1010_println_string ( \"yes\" ); } else { cs1010_println_string ( \"no\" ); }","title":"bracket"},{"location":"pe2.html","text":"Practice Exam 2 Questions Exam Paper Basic Info Date: 10 November, 2018 (Saturday) Time: 1pm to 4pm Venue: Various programming labs Scope: Units 1-24, Assignments 1-7, Tutorials 1-9 5 programming questions, very easy to hard Criteria: Correctness, Style, Documentation, Efficient. Allocation differs per question. Duration: 2 hours and 30 minutes Open Book (You can bring analog references) Lab Allocation Every student is assigned to a programming lab. Please see the allocation below. Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2) Here are the locatons for the respective labs Special Restrictions You will be issued a special account on the PE day to solve the exam questions. There will be no Internet access. Vim Configuration Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins. General Advice Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. Pay attention to the marking criteria, which differs from question to question. Don't start typing your code right away. Think about the solution first -- what variables are needed? what is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so. You will be given a question form to ask questions to clarify doubts about the question paper. But note that you can only ask a boolean question (YES/NO answer). Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases. Lab and Seat Allocation NAME Venue Seat Number AARUSHI SINGH PL1 soctf-imac215-001 AHMAD MUDAAFI' B ZAINUDDIN PL1 soctf-imac215-002 AI ZHENGWEI PL1 soctf-imac215-003 ALEX TEO KANG JIE PL1 soctf-imac215-004 AMIR AZHAR B AZIZAN PL1 soctf-imac215-005 ANDREW LAU JIA JUN PL1 soctf-imac215-006 ANG KENG SIANG PL1 soctf-imac215-007 ANG KIANG YANG PL1 soctf-imac215-008 AW CHIAN HAO PL1 soctf-imac215-009 BALAM SAI ROHIT REDDY PL1 soctf-imac215-010 BEATRICE CHAN TONG PL1 soctf-imac215-011 BENEDICT YU CHENG EN PL1 soctf-imac215-012 BENJAMIN CHIA SHAN HONG PL1 soctf-imac215-013 CAI RONG PL1 soctf-imac215-014 CHAN EE ZHENG, BENJAMIN PL1 soctf-imac215-015 CHAN HIN, SEAN PL1 soctf-imac215-016 CHAN WEI FONG, MAX PL1 soctf-imac215-017 CHAN YEE CHONG PHILIP PL1 soctf-imac215-018 CHAN YEW CHUN DANIEL PL1 soctf-imac215-019 CHAN ZHI ZHENG, AMOS PL1 soctf-imac215-020 CHANG HUI ZHEN PL1 soctf-imac215-021 CHANG ZHONG KAI PL1 soctf-imac215-022 CHEN CHAO PL1 soctf-imac215-023 CHEN TONG PL1 soctf-imac215-024 CHENG LE DA, CLEMENT PL1 soctf-imac215-025 CHENG WANYIN PL1 soctf-imac215-027 CHENG WEIXUAN PL1 soctf-imac215-028 CHERYL NG YUN LIN PL1 soctf-imac215-029 CHEW JUN KONG PL1 soctf-imac215-030 CHIA BIING HANN PL1 soctf-imac215-031 CHNG XIAN YI PL1 soctf-imac215-032 CHOI WONJAE PL1 soctf-imac215-034 CHU JUI HUNG @JEFFERSON CHU PL1 soctf-imac215-035 CHUA MAI FENG, CARL PL1 soctf-imac215-036 CHUA WEN XUAN PL1 soctf-imac215-037 CHUA ZONG WEI PL1 soctf-imac215-038 CLAIRE CHAN YEN HWA PL1 soctf-imac215-039 CYNTHIA LEE WENG YAN PL1 soctf-imac215-043 DANIEL TAN WEE LIANG PL1 soctf-imac215-044 DANISH B EDDIE PL1 soctf-imac215-045 DARREN ONG PL2 soctf-pl2-001 DEBBIE TAN JIA MIN PL2 soctf-pl2-002 DING NING PL2 soctf-pl2-003 DIVAKARAN HARITHA PL2 soctf-pl2-004 EDMUND TEO WEI XIN PL2 soctf-pl2-005 EU JING SEN PL2 soctf-pl2-006 EVELYN YI-WEN CHEN PL2 soctf-pl2-007 FATIN NABILAH BTE SUHAIMI PL2 soctf-pl2-009 FOO CHI HEN PL2 soctf-pl2-010 GINA QUAH JIE XI PL2 soctf-pl2-011 GLEN WONG SHU ZE PL2 soctf-pl2-012 GOH RUI PING SAMANTHA PL2 soctf-pl2-013 GOH ZHEN HAO JOEY PL2 soctf-pl2-014 GONDHALEKAR SUKRUT YOGESH PL2 soctf-pl2-014 GREGORY TAN WEI YUAN PL2 soctf-pl2-016 GUI XIXIAN PL2 soctf-pl2-017 GUO HAOREN PL2 soctf-pl2-018 HANS KURNIA WIDJAJA PL2 soctf-pl2-019 HAO YUN PL2 soctf-pl2-020 HASHIR ZAHIR PL2 soctf-pl2-022 HENG HONG CHUAN PL2 soctf-pl2-023 HO JING YANG DANIEL PL2 soctf-pl2-024 HO SI SHI ANNETTE PL2 soctf-pl2-025 HO WEI BIN, JERRY PL2 soctf-pl2-026 HU XINYING PL2 soctf-pl2-028 HUANG XUANKUN PL2 soctf-pl2-029 IAN CHUA PL2 soctf-pl2-030 ISABELLA CHEONG XIAO XUAN PL2 soctf-pl2-031 IVAN ANDIKA LIE PL2 soctf-pl2-032 JANEL ANG YEE HUEY PL2 soctf-pl2-035 JASON SATHYA CITRO PL2 soctf-pl2-036 JASPER ONG SHAO YONG PL2 soctf-pl2-037 JAZHTEN LOW YONGSHEN PL2 soctf-pl2-038 JERRY ZHANG ZHUORAN PL2 soctf-pl2-039 JESS TEO XI ZHI PL2 soctf-pl2-041 JOEL CHANG ZHI KAI PL2 soctf-pl2-042 JOHN CUTHBERT KHOO TENG FONG PL2 soctf-pl2-043 JOSEPH WONG YEFENG PL2 soctf-pl2-044 JUSTIN CHIA JIA JIN PL2 soctf-pl2-045 K ALAGES PL2 soctf-pl2-046 KARAN SARAT PL3 soctf-pl3-001 KARNATI SAI ABHISHEK PL3 soctf-pl3-002 KEE KAH LOK PL3 soctf-pl3-003 KEITH CHAN JUN KAI PL3 soctf-pl3-004 KELVIN HARRIS PL3 soctf-pl3-006 KEVIN PUTERA PL3 soctf-pl3-007 KEZIA KEW KAI YUN PL3 soctf-pl3-008 KHAIRUL IMAN NASRI B AZHARIE PL3 soctf-pl3-010 KHOO TZE YANG RAYSON PL3 soctf-pl3-011 KISHORE R PL3 soctf-pl3-012 KWOK KUIN EK JEREMY PL3 soctf-pl3-013 KYAWT KYAWT SAN PL3 soctf-pl3-014 LAI WEN XUAN JEREMY PL3 soctf-pl3-015 LAM TIAN WEI JUSTIN PL3 soctf-pl3-016 LE HONG LONG PL3 soctf-pl3-017 LEE HONG CHIEN, KENNETH PL3 soctf-pl3-018 LEE LI XIN PL3 soctf-pl3-019 LEE RAIYAN BIN ZULKIFLI PL3 soctf-pl3-020 LEE WEI HERN, JASON PL3 soctf-pl3-021 LEE YUEYU PL3 soctf-pl3-022 LEE ZHEN YU PL3 soctf-pl3-025 LEOW YONG HENG PL3 soctf-pl3-026 LEOW YONG KANG ANDREW PL4 soctf-pl4-001 LI JIAYU PL4 soctf-pl4-002 LI ZIHAN PL4 soctf-pl4-003 LIAO LIXIN PL4 soctf-pl4-004 LIAO TIANCHANG PL4 soctf-pl4-006 LIM CHEE SENG BRIAN PL4 soctf-pl4-007 LIM CHEK JUN PL4 soctf-pl4-008 LIM CHENG YIN, RYAN PL4 soctf-pl4-010 LIM HAO XIANG, SEAN PL4 soctf-pl4-011 LIM JIA WEI PL4 soctf-pl4-012 LIM JIAYI, TAMELLY PL4 soctf-pl4-014 LIM JUN KUANG, LIONEL PL4 soctf-pl4-015 LIM LI LINCOLN PL4 soctf-pl4-016 LIM SI YING PL4 soctf-pl4-017 LIM TING WEI PL4 soctf-pl4-018 LIM WEN HAN, EUGENE PL4 soctf-pl4-019 LIM YAN TING PL4 soctf-pl4-020 LIN JIAYUE PL4 soctf-pl4-021 LING WEN JIAN PL4 soctf-pl4-022 LIU JINGXUAN PL4 soctf-pl4-023 LIU PEIZE PL4 soctf-pl4-024 LIU SHIRU PL4 soctf-pl4-025 LIU SONGTAO PL5 soctf-pl5-001 LIU WEI JIE NICHOLAS PL5 soctf-pl5-002 LOH CHING WEI, JOSHUA PL5 soctf-pl5-003 LOH YONG ZEE PL5 soctf-pl5-004 LOW EE TER PL5 soctf-pl5-005 LOW JIA YEE PL5 soctf-pl5-006 LOW SIU YUAN, FRANCIS PL5 soctf-pl5-007 LUCAS FOO SOO QUAN PL5 soctf-pl5-008 LYE JUN WEI ANANDA PL5 soctf-pl5-009 MARC PHUA HSIAO MENG PL5 soctf-pl5-010 MATTHEW NATHANAEL SUGIRI PL5 soctf-pl5-011 MERVIN WEE MINGWEN PL5 soctf-pl5-013 MICHELLE TOH HUI PING PL5 soctf-pl5-014 MODAK SHANTANU BHARAT PL5 soctf-pl5-015 MOHAMED RIYAS PL5 soctf-pl5-016 MOHAMMAD YOUSUF MINHAJ ZIA PL5 soctf-pl5-017 MUHAMMAD FAIRUZ B AMIRHAMZAH PL5 soctf-pl5-018 MUHAMMAD HOZEFA ZUMKHAWALA PL5 soctf-pl5-019 MUHAMMAD SHOLIHIN BIN KAMARUDIN PL5 soctf-pl5-020 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN PL5 soctf-pl5-021 NATHAN YEO KEE HERN PL5 soctf-pl5-022 NEO WEN HUI PL5 soctf-pl5-023 NG JIE WU WSLab 2 ws2-001 NG JING KANG WSLab 2 ws2-002 NG JING KIAT WSLab 2 ws2-003 NG SHI QI, CARRIE WSLab 2 ws2-004 NG SIU HIAN WSLab 2 ws2-005 NG WEE KIAT WSLab 2 ws2-006 NG WEI JIE, BRANDON WSLab 2 ws2-008 NG ZI HUI WSLab 2 ws2-009 NGAN JI CHENG WSLab 2 ws2-010 NGUYEN THANH DUC WSLab 2 ws2-011 NGUYEN TIEN DAT WSLab 2 ws2-012 NIGEL TAN WSLab 2 ws2-014 NIGELLE LEO YUWEN WSLab 2 ws2-015 NISHANTH ELANGO WSLab 2 ws2-016 NYAN WUN PAING WSLab 2 ws2-017 OEI CHIU YAN REBECCA WSLab 2 ws2-019 ONG YU XUAN WSLab 2 ws2-020 OUNG YONG SHENG KENNEDY WSLab 2 ws2-021 OW ZHENG KUAN WSLab 2 ws2-022 P PRADEEP WSLab 2 ws2-023 PANG JIA JUN VERNON WSLab 2 ws2-024 PARK SO HYUN ESLab 2 pc1 PARMAR VARUN SAMIR ESLab 1 pc1 PARVATHI RANJITH MENON ESLab 1 pc2 PATWARI RISHAB ESLab 1 pc3 PEI YAN BO ESLab 1 pc4 PHOON JIA JUIN ESLab 1 pc5 POH CHOO LEONG, LINSTON ESLab 1 pc6 PONG LOONG BOB ESLab 1 pc7 POON KAH ONN, BENJAMIN ESLab 1 pc8 POW JING YONG ESLab 1 pc9 QIAN JIE ESLab 1 pc10 QUAH YOU JING KANE ESLab 1 pc11 QUEK AIK PENG ESLab 1 pc12 RAGHAV BHARDWAJ ESLab 1 pc13 RAJAMOHAN B PRIYAN ESLab 1 pc14 RAVEENDRAN AJEY ASHOK ESLab 1 pc15 RISHI MAHADEVAN ESLab 1 pc16 RUSDI HAIZIM B RAHIM ESLab 1 pc17 RYAN TAN YU ESLab 1 pc18 SAI GANESH SURESH ESLab 1 pc19 SCOTT FLOYD ZHEN-YAN SMAHON ESLab 1 pc20 SEE SHENG CHAO ESLab 1 pc21 SENTHIL ARAAVIND ESLab 2 pc2 SHA LONG ESLab 2 pc3 SHANNON LEE ESLab 2 pc4 SHAWN WONG JUN KIT ESLab 2 pc5 SHRIYA SAXENA ESLab 2 pc6 SIM YU JIE ESLab 2 pc7 SITI NADIAH BINTE MOHAMED RAMLI ESLab 2 pc8 SUTHER DAVID SAMUEL ESLab 2 pc9 TALAGADADIVI DURGA RUKMINI MANASWINI ESLab 2 pc10 TAM WEI IAN JOSHUA ESLab 2 pc11 TAN GUAN YEW ESLab 2 pc12 TAN KAI LI CATHERINE ESLab 2 pc13 TAN KOK JOON ESLab 2 pc14 TAN LI ANN PETER ESLab 2 pc15 TAN YEH HAN, JOHN ESLab 2 pc16 TAN YI XIANG ESLab 2 pc17 TAN ZHENG FU JUSTIN ESLab 2 pc18 TAN ZHENG WEN ESLab 2 pc19 TAY JIN WEN ESLab 2 pc20 TAY JING XUAN ESLab 2 pc21 TAY TZE-WEI, CALEB WSLab 1 ws1-001 TAY YEE EN, RYAN WSLab 1 ws1-002 TEH ZI HUAI WSLab 1 ws1-003 TEO WEI JIE, SHAUN WSLab 1 ws1-004 TOH YING YING JANICE WSLab 1 ws1-005 TONG QI WEI WSLab 1 ws1-006 TRAN MINH DUONG WSLab 1 ws1-008 TRAN QUANG THANH WSLab 1 ws1-009 TSHIN QI REN WSLab 1 ws1-010 UMAR BIN MOIZ WSLab 1 ws1-011 VASAVADA TEJAS SUDHIR WSLab 1 ws1-014 VIDHYABHARATHI SOMASUNDARAM WSLab 1 ws1-015 VIVIAN LEE BOON GEOK WSLab 1 ws1-016 WANG ZICONG WSLab 1 ws1-017 WEI FENG WSLab 1 ws1-018 WENG KEXIN WSLab 1 ws1-019 WONG JIN EN, SHANNON WSLab 1 ws1-020 WONG REN-WEI, RYAN WSLab 1 ws1-021 XUE ZHENGQING WSLab 1 ws1-022 YANG AN QI WSLab 1 ws1-023 YANG CHENGLONG WSLab 1 ws1-024 YANG KAI ZE WSLab 3 ws3-001 YANG ZI YUN WSLab 3 ws3-002 YAP JIN FA WSLab 3 ws3-003 YAP KESIN WSLab 3 ws3-004 YE GUOQUAN WSLab 3 ws3-005 YE TONG WSLab 3 ws3-006 YEN PEI CHIH WSLab 3 ws3-008 YEW JING HUI WSLab 3 ws3-009 YU XIAOXUE WSLab 3 ws3-010 YUAN JIAYI WSLab 3 ws3-011 YUE JUN YI WSLab 3 ws3-012 ZHANG SHIYU WSLab 3 ws3-014 ZHANG YIHAN WSLab 3 ws3-015 ZHANG YIPING WSLab 3 ws3-016 ZHANG YUE HAN WSLab 3 ws3-017 ZHAO PENGFEI WSLab 3 ws3-019 ZHAO TIANQI WSLab 3 ws3-020 ZHENG KAINING WSLab 3 ws3-021 ZHU BO WSLab 3 ws3-022 ZHU YIJIE WSLab 3 ws3-023 ZOE WONG XIN LEI WSLab 3 ws3-024","title":"Info About PE2"},{"location":"pe2.html#practice-exam-2","text":"","title":"Practice Exam 2"},{"location":"pe2.html#questions","text":"Exam Paper","title":"Questions"},{"location":"pe2.html#basic-info","text":"Date: 10 November, 2018 (Saturday) Time: 1pm to 4pm Venue: Various programming labs Scope: Units 1-24, Assignments 1-7, Tutorials 1-9 5 programming questions, very easy to hard Criteria: Correctness, Style, Documentation, Efficient. Allocation differs per question. Duration: 2 hours and 30 minutes Open Book (You can bring analog references)","title":"Basic Info"},{"location":"pe2.html#lab-allocation","text":"Every student is assigned to a programming lab. Please see the allocation below. Special access has been given to students assigned to ES Lab 1 and 2 (Embedded System Teaching Lab 1 and 2) Here are the locatons for the respective labs","title":"Lab Allocation"},{"location":"pe2.html#special-restrictions","text":"You will be issued a special account on the PE day to solve the exam questions. There will be no Internet access.","title":"Special Restrictions"},{"location":"pe2.html#vim-configuration","text":"Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins.","title":"Vim Configuration"},{"location":"pe2.html#general-advice","text":"Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. Pay attention to the marking criteria, which differs from question to question. Don't start typing your code right away. Think about the solution first -- what variables are needed? what is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so. You will be given a question form to ask questions to clarify doubts about the question paper. But note that you can only ask a boolean question (YES/NO answer). Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases.","title":"General Advice"},{"location":"pe2.html#lab-and-seat-allocation","text":"NAME Venue Seat Number AARUSHI SINGH PL1 soctf-imac215-001 AHMAD MUDAAFI' B ZAINUDDIN PL1 soctf-imac215-002 AI ZHENGWEI PL1 soctf-imac215-003 ALEX TEO KANG JIE PL1 soctf-imac215-004 AMIR AZHAR B AZIZAN PL1 soctf-imac215-005 ANDREW LAU JIA JUN PL1 soctf-imac215-006 ANG KENG SIANG PL1 soctf-imac215-007 ANG KIANG YANG PL1 soctf-imac215-008 AW CHIAN HAO PL1 soctf-imac215-009 BALAM SAI ROHIT REDDY PL1 soctf-imac215-010 BEATRICE CHAN TONG PL1 soctf-imac215-011 BENEDICT YU CHENG EN PL1 soctf-imac215-012 BENJAMIN CHIA SHAN HONG PL1 soctf-imac215-013 CAI RONG PL1 soctf-imac215-014 CHAN EE ZHENG, BENJAMIN PL1 soctf-imac215-015 CHAN HIN, SEAN PL1 soctf-imac215-016 CHAN WEI FONG, MAX PL1 soctf-imac215-017 CHAN YEE CHONG PHILIP PL1 soctf-imac215-018 CHAN YEW CHUN DANIEL PL1 soctf-imac215-019 CHAN ZHI ZHENG, AMOS PL1 soctf-imac215-020 CHANG HUI ZHEN PL1 soctf-imac215-021 CHANG ZHONG KAI PL1 soctf-imac215-022 CHEN CHAO PL1 soctf-imac215-023 CHEN TONG PL1 soctf-imac215-024 CHENG LE DA, CLEMENT PL1 soctf-imac215-025 CHENG WANYIN PL1 soctf-imac215-027 CHENG WEIXUAN PL1 soctf-imac215-028 CHERYL NG YUN LIN PL1 soctf-imac215-029 CHEW JUN KONG PL1 soctf-imac215-030 CHIA BIING HANN PL1 soctf-imac215-031 CHNG XIAN YI PL1 soctf-imac215-032 CHOI WONJAE PL1 soctf-imac215-034 CHU JUI HUNG @JEFFERSON CHU PL1 soctf-imac215-035 CHUA MAI FENG, CARL PL1 soctf-imac215-036 CHUA WEN XUAN PL1 soctf-imac215-037 CHUA ZONG WEI PL1 soctf-imac215-038 CLAIRE CHAN YEN HWA PL1 soctf-imac215-039 CYNTHIA LEE WENG YAN PL1 soctf-imac215-043 DANIEL TAN WEE LIANG PL1 soctf-imac215-044 DANISH B EDDIE PL1 soctf-imac215-045 DARREN ONG PL2 soctf-pl2-001 DEBBIE TAN JIA MIN PL2 soctf-pl2-002 DING NING PL2 soctf-pl2-003 DIVAKARAN HARITHA PL2 soctf-pl2-004 EDMUND TEO WEI XIN PL2 soctf-pl2-005 EU JING SEN PL2 soctf-pl2-006 EVELYN YI-WEN CHEN PL2 soctf-pl2-007 FATIN NABILAH BTE SUHAIMI PL2 soctf-pl2-009 FOO CHI HEN PL2 soctf-pl2-010 GINA QUAH JIE XI PL2 soctf-pl2-011 GLEN WONG SHU ZE PL2 soctf-pl2-012 GOH RUI PING SAMANTHA PL2 soctf-pl2-013 GOH ZHEN HAO JOEY PL2 soctf-pl2-014 GONDHALEKAR SUKRUT YOGESH PL2 soctf-pl2-014 GREGORY TAN WEI YUAN PL2 soctf-pl2-016 GUI XIXIAN PL2 soctf-pl2-017 GUO HAOREN PL2 soctf-pl2-018 HANS KURNIA WIDJAJA PL2 soctf-pl2-019 HAO YUN PL2 soctf-pl2-020 HASHIR ZAHIR PL2 soctf-pl2-022 HENG HONG CHUAN PL2 soctf-pl2-023 HO JING YANG DANIEL PL2 soctf-pl2-024 HO SI SHI ANNETTE PL2 soctf-pl2-025 HO WEI BIN, JERRY PL2 soctf-pl2-026 HU XINYING PL2 soctf-pl2-028 HUANG XUANKUN PL2 soctf-pl2-029 IAN CHUA PL2 soctf-pl2-030 ISABELLA CHEONG XIAO XUAN PL2 soctf-pl2-031 IVAN ANDIKA LIE PL2 soctf-pl2-032 JANEL ANG YEE HUEY PL2 soctf-pl2-035 JASON SATHYA CITRO PL2 soctf-pl2-036 JASPER ONG SHAO YONG PL2 soctf-pl2-037 JAZHTEN LOW YONGSHEN PL2 soctf-pl2-038 JERRY ZHANG ZHUORAN PL2 soctf-pl2-039 JESS TEO XI ZHI PL2 soctf-pl2-041 JOEL CHANG ZHI KAI PL2 soctf-pl2-042 JOHN CUTHBERT KHOO TENG FONG PL2 soctf-pl2-043 JOSEPH WONG YEFENG PL2 soctf-pl2-044 JUSTIN CHIA JIA JIN PL2 soctf-pl2-045 K ALAGES PL2 soctf-pl2-046 KARAN SARAT PL3 soctf-pl3-001 KARNATI SAI ABHISHEK PL3 soctf-pl3-002 KEE KAH LOK PL3 soctf-pl3-003 KEITH CHAN JUN KAI PL3 soctf-pl3-004 KELVIN HARRIS PL3 soctf-pl3-006 KEVIN PUTERA PL3 soctf-pl3-007 KEZIA KEW KAI YUN PL3 soctf-pl3-008 KHAIRUL IMAN NASRI B AZHARIE PL3 soctf-pl3-010 KHOO TZE YANG RAYSON PL3 soctf-pl3-011 KISHORE R PL3 soctf-pl3-012 KWOK KUIN EK JEREMY PL3 soctf-pl3-013 KYAWT KYAWT SAN PL3 soctf-pl3-014 LAI WEN XUAN JEREMY PL3 soctf-pl3-015 LAM TIAN WEI JUSTIN PL3 soctf-pl3-016 LE HONG LONG PL3 soctf-pl3-017 LEE HONG CHIEN, KENNETH PL3 soctf-pl3-018 LEE LI XIN PL3 soctf-pl3-019 LEE RAIYAN BIN ZULKIFLI PL3 soctf-pl3-020 LEE WEI HERN, JASON PL3 soctf-pl3-021 LEE YUEYU PL3 soctf-pl3-022 LEE ZHEN YU PL3 soctf-pl3-025 LEOW YONG HENG PL3 soctf-pl3-026 LEOW YONG KANG ANDREW PL4 soctf-pl4-001 LI JIAYU PL4 soctf-pl4-002 LI ZIHAN PL4 soctf-pl4-003 LIAO LIXIN PL4 soctf-pl4-004 LIAO TIANCHANG PL4 soctf-pl4-006 LIM CHEE SENG BRIAN PL4 soctf-pl4-007 LIM CHEK JUN PL4 soctf-pl4-008 LIM CHENG YIN, RYAN PL4 soctf-pl4-010 LIM HAO XIANG, SEAN PL4 soctf-pl4-011 LIM JIA WEI PL4 soctf-pl4-012 LIM JIAYI, TAMELLY PL4 soctf-pl4-014 LIM JUN KUANG, LIONEL PL4 soctf-pl4-015 LIM LI LINCOLN PL4 soctf-pl4-016 LIM SI YING PL4 soctf-pl4-017 LIM TING WEI PL4 soctf-pl4-018 LIM WEN HAN, EUGENE PL4 soctf-pl4-019 LIM YAN TING PL4 soctf-pl4-020 LIN JIAYUE PL4 soctf-pl4-021 LING WEN JIAN PL4 soctf-pl4-022 LIU JINGXUAN PL4 soctf-pl4-023 LIU PEIZE PL4 soctf-pl4-024 LIU SHIRU PL4 soctf-pl4-025 LIU SONGTAO PL5 soctf-pl5-001 LIU WEI JIE NICHOLAS PL5 soctf-pl5-002 LOH CHING WEI, JOSHUA PL5 soctf-pl5-003 LOH YONG ZEE PL5 soctf-pl5-004 LOW EE TER PL5 soctf-pl5-005 LOW JIA YEE PL5 soctf-pl5-006 LOW SIU YUAN, FRANCIS PL5 soctf-pl5-007 LUCAS FOO SOO QUAN PL5 soctf-pl5-008 LYE JUN WEI ANANDA PL5 soctf-pl5-009 MARC PHUA HSIAO MENG PL5 soctf-pl5-010 MATTHEW NATHANAEL SUGIRI PL5 soctf-pl5-011 MERVIN WEE MINGWEN PL5 soctf-pl5-013 MICHELLE TOH HUI PING PL5 soctf-pl5-014 MODAK SHANTANU BHARAT PL5 soctf-pl5-015 MOHAMED RIYAS PL5 soctf-pl5-016 MOHAMMAD YOUSUF MINHAJ ZIA PL5 soctf-pl5-017 MUHAMMAD FAIRUZ B AMIRHAMZAH PL5 soctf-pl5-018 MUHAMMAD HOZEFA ZUMKHAWALA PL5 soctf-pl5-019 MUHAMMAD SHOLIHIN BIN KAMARUDIN PL5 soctf-pl5-020 MUHHAMMAD NUR HAFIDZ BIN HUSSAIN PL5 soctf-pl5-021 NATHAN YEO KEE HERN PL5 soctf-pl5-022 NEO WEN HUI PL5 soctf-pl5-023 NG JIE WU WSLab 2 ws2-001 NG JING KANG WSLab 2 ws2-002 NG JING KIAT WSLab 2 ws2-003 NG SHI QI, CARRIE WSLab 2 ws2-004 NG SIU HIAN WSLab 2 ws2-005 NG WEE KIAT WSLab 2 ws2-006 NG WEI JIE, BRANDON WSLab 2 ws2-008 NG ZI HUI WSLab 2 ws2-009 NGAN JI CHENG WSLab 2 ws2-010 NGUYEN THANH DUC WSLab 2 ws2-011 NGUYEN TIEN DAT WSLab 2 ws2-012 NIGEL TAN WSLab 2 ws2-014 NIGELLE LEO YUWEN WSLab 2 ws2-015 NISHANTH ELANGO WSLab 2 ws2-016 NYAN WUN PAING WSLab 2 ws2-017 OEI CHIU YAN REBECCA WSLab 2 ws2-019 ONG YU XUAN WSLab 2 ws2-020 OUNG YONG SHENG KENNEDY WSLab 2 ws2-021 OW ZHENG KUAN WSLab 2 ws2-022 P PRADEEP WSLab 2 ws2-023 PANG JIA JUN VERNON WSLab 2 ws2-024 PARK SO HYUN ESLab 2 pc1 PARMAR VARUN SAMIR ESLab 1 pc1 PARVATHI RANJITH MENON ESLab 1 pc2 PATWARI RISHAB ESLab 1 pc3 PEI YAN BO ESLab 1 pc4 PHOON JIA JUIN ESLab 1 pc5 POH CHOO LEONG, LINSTON ESLab 1 pc6 PONG LOONG BOB ESLab 1 pc7 POON KAH ONN, BENJAMIN ESLab 1 pc8 POW JING YONG ESLab 1 pc9 QIAN JIE ESLab 1 pc10 QUAH YOU JING KANE ESLab 1 pc11 QUEK AIK PENG ESLab 1 pc12 RAGHAV BHARDWAJ ESLab 1 pc13 RAJAMOHAN B PRIYAN ESLab 1 pc14 RAVEENDRAN AJEY ASHOK ESLab 1 pc15 RISHI MAHADEVAN ESLab 1 pc16 RUSDI HAIZIM B RAHIM ESLab 1 pc17 RYAN TAN YU ESLab 1 pc18 SAI GANESH SURESH ESLab 1 pc19 SCOTT FLOYD ZHEN-YAN SMAHON ESLab 1 pc20 SEE SHENG CHAO ESLab 1 pc21 SENTHIL ARAAVIND ESLab 2 pc2 SHA LONG ESLab 2 pc3 SHANNON LEE ESLab 2 pc4 SHAWN WONG JUN KIT ESLab 2 pc5 SHRIYA SAXENA ESLab 2 pc6 SIM YU JIE ESLab 2 pc7 SITI NADIAH BINTE MOHAMED RAMLI ESLab 2 pc8 SUTHER DAVID SAMUEL ESLab 2 pc9 TALAGADADIVI DURGA RUKMINI MANASWINI ESLab 2 pc10 TAM WEI IAN JOSHUA ESLab 2 pc11 TAN GUAN YEW ESLab 2 pc12 TAN KAI LI CATHERINE ESLab 2 pc13 TAN KOK JOON ESLab 2 pc14 TAN LI ANN PETER ESLab 2 pc15 TAN YEH HAN, JOHN ESLab 2 pc16 TAN YI XIANG ESLab 2 pc17 TAN ZHENG FU JUSTIN ESLab 2 pc18 TAN ZHENG WEN ESLab 2 pc19 TAY JIN WEN ESLab 2 pc20 TAY JING XUAN ESLab 2 pc21 TAY TZE-WEI, CALEB WSLab 1 ws1-001 TAY YEE EN, RYAN WSLab 1 ws1-002 TEH ZI HUAI WSLab 1 ws1-003 TEO WEI JIE, SHAUN WSLab 1 ws1-004 TOH YING YING JANICE WSLab 1 ws1-005 TONG QI WEI WSLab 1 ws1-006 TRAN MINH DUONG WSLab 1 ws1-008 TRAN QUANG THANH WSLab 1 ws1-009 TSHIN QI REN WSLab 1 ws1-010 UMAR BIN MOIZ WSLab 1 ws1-011 VASAVADA TEJAS SUDHIR WSLab 1 ws1-014 VIDHYABHARATHI SOMASUNDARAM WSLab 1 ws1-015 VIVIAN LEE BOON GEOK WSLab 1 ws1-016 WANG ZICONG WSLab 1 ws1-017 WEI FENG WSLab 1 ws1-018 WENG KEXIN WSLab 1 ws1-019 WONG JIN EN, SHANNON WSLab 1 ws1-020 WONG REN-WEI, RYAN WSLab 1 ws1-021 XUE ZHENGQING WSLab 1 ws1-022 YANG AN QI WSLab 1 ws1-023 YANG CHENGLONG WSLab 1 ws1-024 YANG KAI ZE WSLab 3 ws3-001 YANG ZI YUN WSLab 3 ws3-002 YAP JIN FA WSLab 3 ws3-003 YAP KESIN WSLab 3 ws3-004 YE GUOQUAN WSLab 3 ws3-005 YE TONG WSLab 3 ws3-006 YEN PEI CHIH WSLab 3 ws3-008 YEW JING HUI WSLab 3 ws3-009 YU XIAOXUE WSLab 3 ws3-010 YUAN JIAYI WSLab 3 ws3-011 YUE JUN YI WSLab 3 ws3-012 ZHANG SHIYU WSLab 3 ws3-014 ZHANG YIHAN WSLab 3 ws3-015 ZHANG YIPING WSLab 3 ws3-016 ZHANG YUE HAN WSLab 3 ws3-017 ZHAO PENGFEI WSLab 3 ws3-019 ZHAO TIANQI WSLab 3 ws3-020 ZHENG KAINING WSLab 3 ws3-021 ZHU BO WSLab 3 ws3-022 ZHU YIJIE WSLab 3 ws3-023 ZOE WONG XIN LEI WSLab 3 ws3-024","title":"Lab and Seat Allocation"},{"location":"policies.html","text":"Policies Email Communication Please use only your official NUS email for communication with the teaching staffs -- either the one with @u.nus.edu or @comp.nus.edu.sg . Please use email only for private matters. Prefix your email subject with [CS1010] . Please use Piazza for other matters related to the module. If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate. Lab Sessions Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions. You should stick to your allocated time slot for tutorials. If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs). Late Submissions All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached). Discussions and Plagiarism We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard on academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally. Screencast Screencast will be recorded and posted online 3-4 days after the lecture. This will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all. Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip lecture. Research has shown that the effect of over-reliance on screencast is negative. Model Solutions and Slides Slides will be posted after the class. Note that slides are used as a visual aid to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution. Grading Students will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). Open Book Assessment All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Policies"},{"location":"policies.html#policies","text":"","title":"Policies"},{"location":"policies.html#email-communication","text":"Please use only your official NUS email for communication with the teaching staffs -- either the one with @u.nus.edu or @comp.nus.edu.sg . Please use email only for private matters. Prefix your email subject with [CS1010] . Please use Piazza for other matters related to the module. If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.","title":"Email Communication"},{"location":"policies.html#lab-sessions","text":"Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions. You should stick to your allocated time slot for tutorials. If there is a strong reason for your to attend another tutorial session, please inform your undergraduate discussion leaders (UDLs).","title":"Lab Sessions"},{"location":"policies.html#late-submissions","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment which was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).","title":"Late Submissions"},{"location":"policies.html#discussions-and-plagiarism","text":"We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard on academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.","title":"Discussions and Plagiarism"},{"location":"policies.html#screencast","text":"Screencast will be recorded and posted online 3-4 days after the lecture. This will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all. Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip lecture. Research has shown that the effect of over-reliance on screencast is negative.","title":"Screencast"},{"location":"policies.html#model-solutions-and-slides","text":"Slides will be posted after the class. Note that slides are used as a visual aid to assist me during lecture. It is not meant as summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.","title":"Model Solutions and Slides"},{"location":"policies.html#grading","text":"Students will received the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve).","title":"Grading"},{"location":"policies.html#open-book-assessment","text":"All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Open Book Assessment"},{"location":"quiz.html","text":"Quizzes We have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010. There are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes. The quizzes are linked here: Kahoot! Quizzes Week 4: Flow Charts (3 September 2018) Google Form Quizzes Quiz 1: Using PE and UNIX Quiz 2: Compiling Your Code Quiz 3: Basic C Syntax","title":"Quizzes"},{"location":"quiz.html#quizzes","text":"We have setup some quizzes to help you check for yourself how much you know about the topics we cover in CS1010. There are two types of quizzes: (a) in-class Kahoot! quizzes, and (b) out-of-class Google Form quizzes. The quizzes are linked here:","title":"Quizzes"},{"location":"quiz.html#kahoot-quizzes","text":"","title":"Kahoot! Quizzes"},{"location":"quiz.html#week-4-flow-charts-3-september-2018","text":"","title":"Week 4: Flow Charts (3 September 2018)"},{"location":"quiz.html#google-form-quizzes","text":"","title":"Google Form Quizzes"},{"location":"quiz.html#quiz-1-using-pe-and-unix","text":"","title":"Quiz 1: Using PE and UNIX"},{"location":"quiz.html#quiz-2-compiling-your-code","text":"","title":"Quiz 2: Compiling Your Code"},{"location":"quiz.html#quiz-3-basic-c-syntax","text":"","title":"Quiz 3: Basic C Syntax"},{"location":"readings.html","text":"Readings Must Read How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, .. Why C? Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller Vim Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\" Vim Video Tutorial (from Aaron Tan) Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Readings"},{"location":"readings.html#readings","text":"","title":"Readings"},{"location":"readings.html#must-read","text":"How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..","title":"Must Read"},{"location":"readings.html#why-c","text":"Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller","title":"Why C?"},{"location":"readings.html#vim","text":"Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"","title":"Vim"},{"location":"readings.html#vim-video-tutorial-from-aaron-tan","text":"Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Vim Video Tutorial (from Aaron Tan)"},{"location":"schedule.html","text":"Schedule This is a tentative schedule for CS1010. Lecture Schedule (Tentative) Week Starting.. Topics Assignment 1 2018-08-13 Units 1-2: Computational Problem Solving 2 2018-08-20 Units 3-4: Functions & Types 3 2018-08-27 Units 5-7: Basic C programs 4 2018-09-03 Units 8-9: Conditionals AS01 released 5 2018-09-10 Units 10-12 Loops AS02 released 6 2018-09-17 Units 13-16 Memory, Array, Strings AS03 released - 2018-09-24 Break 7 2018-10-01 Midterm PE1 AS04 released 8 2018-10-08 Call-by-Referece, nD-Array AS05 released 9 2018-10-15 Efficiency, Macro AS06 released 10 2018-10-22 Searching and Sorting AS07 released 11 2018-10-29 More recursion AS08 released 12 2018-11-05 Struct and I/O PE2 AS09 released 13 2018-11-12 Recap Tutorial Time / Venue (scroll horizontally to see the full table) Day/Time COM1 B108 COM1 B109 COM1 B111 COM1 B112 COM1 0120 I3 0336 I3 0338 AS6 0421 Mon 1000 C10 Joanne C09 Evan Mon 1400 C1A Xiao Liang Tue 1200 03 Addison Tue 1400 C03 Kyle C02 Thanh Wed 1000 C07 Jun Hui C08 Shui Herng C06 Shu Peng 11 Rengan Wed 1200 10 David 07 Aaron Wed 1400 08 Tian Yang Thu 1000 05 Jeffrey 01 Si Jie Thu 1200 C11 Kerryn C04 Jiefeng C05 Qinhua 12 Heng Guang Thu 1400 06 Archana Fri 1200 02 Liang Jun Fri 1400 04 Wangfan","title":"Schedule"},{"location":"schedule.html#schedule","text":"This is a tentative schedule for CS1010.","title":"Schedule"},{"location":"schedule.html#lecture-schedule-tentative","text":"Week Starting.. Topics Assignment 1 2018-08-13 Units 1-2: Computational Problem Solving 2 2018-08-20 Units 3-4: Functions & Types 3 2018-08-27 Units 5-7: Basic C programs 4 2018-09-03 Units 8-9: Conditionals AS01 released 5 2018-09-10 Units 10-12 Loops AS02 released 6 2018-09-17 Units 13-16 Memory, Array, Strings AS03 released - 2018-09-24 Break 7 2018-10-01 Midterm PE1 AS04 released 8 2018-10-08 Call-by-Referece, nD-Array AS05 released 9 2018-10-15 Efficiency, Macro AS06 released 10 2018-10-22 Searching and Sorting AS07 released 11 2018-10-29 More recursion AS08 released 12 2018-11-05 Struct and I/O PE2 AS09 released 13 2018-11-12 Recap","title":"Lecture Schedule (Tentative)"},{"location":"schedule.html#tutorial-time-venue","text":"(scroll horizontally to see the full table) Day/Time COM1 B108 COM1 B109 COM1 B111 COM1 B112 COM1 0120 I3 0336 I3 0338 AS6 0421 Mon 1000 C10 Joanne C09 Evan Mon 1400 C1A Xiao Liang Tue 1200 03 Addison Tue 1400 C03 Kyle C02 Thanh Wed 1000 C07 Jun Hui C08 Shui Herng C06 Shu Peng 11 Rengan Wed 1200 10 David 07 Aaron Wed 1400 08 Tian Yang Thu 1000 05 Jeffrey 01 Si Jie Thu 1200 C11 Kerryn C04 Jiefeng C05 Qinhua 12 Heng Guang Thu 1400 06 Archana Fri 1200 02 Liang Jun Fri 1400 04 Wangfan","title":"Tutorial Time / Venue"},{"location":"style.html","text":"CS1010 C Style In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams. We typically allocate a few marks for coding style (each assignment/exam may have different allocation). You will lose marks for violation of style. This guide is modified from past CS1010 style guide by Aaron Tan. Why Coding Style is Important Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609. 1. Variable Declaration Each variable should be declared in its own line. double weight ; // The weight of the baby double height ; // The height of the baby Avoid double weight , height ; // Weight and height of the baby 2. Give Variables Descriptive Names This is the most important rule to follow. The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning. For example, int number_of_coins; is an appropriate variable but not int c; . Avoid using a single character for variable names. There are some exceptions, however, as shown below: If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain). If the variable is a transient/temporary variable whose purpose is clear. -If the variable is a loop variable whose purpose is clear. 3. Shorten Variable Names with Naming Conventions Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, MAX_LEN , num_of_elems , pcurr , table_num . However, do not invent your own abbreviation. For instance, names like nm_elemnts should be avoided. 4. Avoid Negated Variable or Function Names Negated variables often result in hard-to-read double-negatives in an expression like !is_not_err . So, avoid is_not_error , is_not_found , is_not_valid , cannot_open_file . Instead, we prefer is_error , is_found , is_valid , can_open_file etc. 5. Use #define to Define Constants for Magic Numbers Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example: Avoid: for ( i = 0 ; i < 100 ; i += 1 ) { : } Prefer: #define MAX_LEN 100 : for (i = 0; i < MAX_LEN; i += 1) { : } 6. Naming Conventions Constants All constant identifiers must be written in all caps and separated by an underscore _ . For instance MAX_ITERATIONS , MAX_LEN , GOLDEN_RATIO , COLOR_DEFAULT , PI . Variables and Functions Use lower case letters for variable names and function names, with multiple words separated by underscore _ . Example, cs1010_read_long , is_prime . 7. Use Consistent Indentation to Emphasize Block Structure The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide). Every block that follows a for , while , if-else , do-while statement must be indented from its enclosing block. Comments within a block should follow the indentation level of its enclosing block. For example, for ( i = 0 ; i < 3 ; i += 1 ) { // Comments should be indented too while ( j != i ) { // More indented comments printf ( \"Hello \\n \" ); } } The following are the wrong ways to indent the comments. for ( i = 0 ; i < 3 ; i += 1 ) { // This comment should be indented and aligned with the while statement. while ( j != i ) { // This comment should be aligned with the printf statement. printf ( \"Hello \\n \" ); } } 8. Don't Mix Tabs and Spaces You must use only spaces in your code. Do not use tabs. You can add the configuration set expandtab to automatically expand any tab that you enter into spaces. 9. Spaces in if , else , for , while , do - while Statements Add a single space between the keywords if , else , for , while and the following parentheses and between the parentheses and next curly bracket. For instance: for( ... ) { // not good for( ... ){ // not good for ( ... ) { // good 10. Spaces in Assignments Add a single space before and after = . a=b; // no a= b; // no a =b; // no a = b; // OK! 11. Positions of Open and Close Braces There are two camps on the position of open braces. The following shows the \"trailing open braces\": for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in: for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } Both styles are acceptable, but you should be consistent and should not mix both styles in a single program. For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them. 12. Comment Major Code Segments Adequately Major segments of code should have explanatory comments. A major segment may be a loop block or a function block. You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how. An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments. For example, // Check and reject out-of-bounds indices if ( k < 0 || k >= MAX_LEN ) { return - 1 ; } 13. Avoid Superfluous Comments A comment such as: i += 1 // add one to i serves no purpose, adds clutter to a program and does more harm than good. 14. Blank Lines It is good to add a blank line between two functions, or two long segments of code for readability. // This function ... int f ( int x ) { // body } // This function ... int g ( double y ) { // body } // Statements 1 to 10 belong to a sub-task statement1 ; statement2 ; : statement10 ; // Leave a blank line for readability statement11 ; statement12 ; : However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present. 15. Long Lines If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines. if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040C ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102R || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101R || has_ma1311 || has_ma1506 || has_ma1508E )) is bad if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040c ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102r || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101r || has_ma1311 || has_ma1506 || has_ma1508e )) is better.","title":"Style Guide"},{"location":"style.html#cs1010-c-style","text":"In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams. We typically allocate a few marks for coding style (each assignment/exam may have different allocation). You will lose marks for violation of style. This guide is modified from past CS1010 style guide by Aaron Tan.","title":"CS1010 C Style"},{"location":"style.html#why-coding-style-is-important","text":"Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.","title":"Why Coding Style is Important"},{"location":"style.html#1-variable-declaration","text":"Each variable should be declared in its own line. double weight ; // The weight of the baby double height ; // The height of the baby Avoid double weight , height ; // Weight and height of the baby","title":"1. Variable Declaration"},{"location":"style.html#2-give-variables-descriptive-names","text":"This is the most important rule to follow. The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning. For example, int number_of_coins; is an appropriate variable but not int c; . Avoid using a single character for variable names. There are some exceptions, however, as shown below: If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain). If the variable is a transient/temporary variable whose purpose is clear. -If the variable is a loop variable whose purpose is clear.","title":"2. Give Variables Descriptive Names"},{"location":"style.html#3-shorten-variable-names-with-naming-conventions","text":"Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, MAX_LEN , num_of_elems , pcurr , table_num . However, do not invent your own abbreviation. For instance, names like nm_elemnts should be avoided.","title":"3. Shorten Variable Names with Naming Conventions"},{"location":"style.html#4-avoid-negated-variable-or-function-names","text":"Negated variables often result in hard-to-read double-negatives in an expression like !is_not_err . So, avoid is_not_error , is_not_found , is_not_valid , cannot_open_file . Instead, we prefer is_error , is_found , is_valid , can_open_file etc.","title":"4. Avoid Negated Variable or Function Names"},{"location":"style.html#5-use-define-to-define-constants-for-magic-numbers","text":"Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example: Avoid: for ( i = 0 ; i < 100 ; i += 1 ) { : } Prefer: #define MAX_LEN 100 : for (i = 0; i < MAX_LEN; i += 1) { : }","title":"5. Use #define to Define Constants for Magic Numbers"},{"location":"style.html#6-naming-conventions","text":"","title":"6. Naming Conventions"},{"location":"style.html#constants","text":"All constant identifiers must be written in all caps and separated by an underscore _ . For instance MAX_ITERATIONS , MAX_LEN , GOLDEN_RATIO , COLOR_DEFAULT , PI .","title":"Constants"},{"location":"style.html#variables-and-functions","text":"Use lower case letters for variable names and function names, with multiple words separated by underscore _ . Example, cs1010_read_long , is_prime .","title":"Variables and Functions"},{"location":"style.html#7-use-consistent-indentation-to-emphasize-block-structure","text":"The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide). Every block that follows a for , while , if-else , do-while statement must be indented from its enclosing block. Comments within a block should follow the indentation level of its enclosing block. For example, for ( i = 0 ; i < 3 ; i += 1 ) { // Comments should be indented too while ( j != i ) { // More indented comments printf ( \"Hello \\n \" ); } } The following are the wrong ways to indent the comments. for ( i = 0 ; i < 3 ; i += 1 ) { // This comment should be indented and aligned with the while statement. while ( j != i ) { // This comment should be aligned with the printf statement. printf ( \"Hello \\n \" ); } }","title":"7. Use Consistent Indentation to Emphasize Block Structure"},{"location":"style.html#8-dont-mix-tabs-and-spaces","text":"You must use only spaces in your code. Do not use tabs. You can add the configuration set expandtab to automatically expand any tab that you enter into spaces.","title":"8. Don't Mix Tabs and Spaces"},{"location":"style.html#9-spaces-in-if-else-for-while-do-while-statements","text":"Add a single space between the keywords if , else , for , while and the following parentheses and between the parentheses and next curly bracket. For instance: for( ... ) { // not good for( ... ){ // not good for ( ... ) { // good","title":"9. Spaces in if, else, for, while, do-while Statements"},{"location":"style.html#10-spaces-in-assignments","text":"Add a single space before and after = . a=b; // no a= b; // no a =b; // no a = b; // OK!","title":"10. Spaces in Assignments"},{"location":"style.html#11-positions-of-open-and-close-braces","text":"There are two camps on the position of open braces. The following shows the \"trailing open braces\": for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in: for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } Both styles are acceptable, but you should be consistent and should not mix both styles in a single program. For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.","title":"11. Positions of Open and Close Braces"},{"location":"style.html#12-comment-major-code-segments-adequately","text":"Major segments of code should have explanatory comments. A major segment may be a loop block or a function block. You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how. An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments. For example, // Check and reject out-of-bounds indices if ( k < 0 || k >= MAX_LEN ) { return - 1 ; }","title":"12. Comment Major Code Segments Adequately"},{"location":"style.html#13-avoid-superfluous-comments","text":"A comment such as: i += 1 // add one to i serves no purpose, adds clutter to a program and does more harm than good.","title":"13. Avoid Superfluous Comments"},{"location":"style.html#14-blank-lines","text":"It is good to add a blank line between two functions, or two long segments of code for readability. // This function ... int f ( int x ) { // body } // This function ... int g ( double y ) { // body } // Statements 1 to 10 belong to a sub-task statement1 ; statement2 ; : statement10 ; // Leave a blank line for readability statement11 ; statement12 ; : However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.","title":"14. Blank Lines"},{"location":"style.html#15-long-lines","text":"If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines. if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040C ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102R || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101R || has_ma1311 || has_ma1506 || has_ma1508E )) is bad if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040c ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102r || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101r || has_ma1311 || has_ma1506 || has_ma1508e )) is better.","title":"15. Long Lines"},{"location":"syllabus.html","text":"","title":"Syllabus"},{"location":"unix.html","text":"Basic UNIX Commands UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster. Connect to the Programming Environment (PE) If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assumes that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. pwd : Print Current Working directory pwd shows you which directory you are currently in ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it. ls : LiSt files The ls list the files in the current working directory. ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command. cd : Change Directory To navigate in the directory tree, changing the current working directory from to another, we use the cd command. ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return to home, we can alternatively use cd .. . ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$ rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/ cp : CoPy files ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory. mv : MoVe or rename files mv can move files from one directory to another. ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: ooiwt@pe111:~/tut01$ mv h and press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation. The tab key can also complete the name of command. rm : ReMove files Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While UNIX command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!) and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively ask you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you setup your own UNIX OS, you should add this alias alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: alias mv = \"mv -i\" alias cp = \"cp -i\" cat : CATenate file content to screen ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article. chmod : Changing UNIX File Permission It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwx--xrwx -rwxrwxrwx , or from -rwxr--r-- to -rwx--xr-x -rwxr-xr-x , and so on. You get the idea. Another way to change the permission is set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: chmod 444 <file> To set the permission to -rw------- , run: chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises. scp : Secure Copy Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well. Specifying A Path in UNIX In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any bash you like, if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"UNIX"},{"location":"unix.html#basic-unix-commands","text":"UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.","title":"Basic UNIX Commands"},{"location":"unix.html#connect-to-the-programming-environment-pe","text":"If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assumes that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given.","title":"Connect to the Programming Environment (PE)"},{"location":"unix.html#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it.","title":"pwd: Print Current Working directory"},{"location":"unix.html#ls-list-files","text":"The ls list the files in the current working directory. ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")","title":"ls: LiSt files"},{"location":"unix.html#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix.html#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from to another, we use the cd command. ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return to home, we can alternatively use cd .. . ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$","title":"cd: Change Directory"},{"location":"unix.html#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/","title":"rmdir: ReMove a subDIRectory"},{"location":"unix.html#cp-copy-files","text":"ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory.","title":"cp: CoPy files"},{"location":"unix.html#mv-move-or-rename-files","text":"mv can move files from one directory to another. ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: ooiwt@pe111:~/tut01$ mv h and press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation. The tab key can also complete the name of command.","title":"mv: MoVe or rename files"},{"location":"unix.html#rm-remove-files","text":"Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While UNIX command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!) and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively ask you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you setup your own UNIX OS, you should add this alias alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: alias mv = \"mv -i\" alias cp = \"cp -i\"","title":"rm: ReMove files"},{"location":"unix.html#cat-catenate-file-content-to-screen","text":"ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to screen"},{"location":"unix.html#man-online-manual","text":"An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.","title":"man: Online MANual"},{"location":"unix.html#chmod-changing-unix-file-permission","text":"It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwx--xrwx -rwxrwxrwx , or from -rwxr--r-- to -rwx--xr-x -rwxr-xr-x , and so on. You get the idea. Another way to change the permission is set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: chmod 444 <file> To set the permission to -rw------- , run: chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.","title":"chmod: Changing UNIX File Permission"},{"location":"unix.html#scp-secure-copy","text":"Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well.","title":"scp: Secure Copy"},{"location":"unix.html#specifying-a-path-in-unix","text":"In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any bash you like, if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"Specifying A Path in UNIX"},{"location":"vim.html","text":"Vim Tips I collected below some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively . 1. Useful Configuration You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you starts vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim . Help In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup . Backup Files You can ask vim to automatically backup files that you edit. This has been a life saver for me in multiple occasions. In your ~/.vimrc file, set backup will cause a copy of your file to be save with suffix ~ appended to its name everytime you save. I prefer not to clutter my working directory, so I set set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you. Syntax Highlighting If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : syntax on Ruler and Numbers If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc set ruler will display the line number and the column number on the lower right corner. You can also add set number to label each line with a line number. Auto Indentation (new) Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : set shiftwidth=2 2. Navigation Basic Navigation Use k and j keys to move up and down (just like Gmail and Facebook!). h and l to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many hjkl to see how you can navigate faster). w jump to the beginning of the next word b jump to the beginning of the previous word (reverse of w ) e jump to the end of the word (or next word when pressed again) f + char: search forward in the line and sit on the next matching char t + char: search forward in the line and sit on one space before the matching char $ jump to end of line 0 jump to the beginning of the line ^ jump to the first non-blank character of the line % jump between matching parentheses CTRL- d jump forward (Down) half page CTRL- f jump Forward one page CTRL- u jump backward (Up) half page CTRL- b jump Backward half page Jumping to a Line If the compiler tells you there is an error on Line x x , you can issue :<x> to jump to Line x x . For instance, :40 will go to Line 40. 3. Editing Operations Undo Since we are on the topic of correcting mistakes, u in command mode undo your changes. Prefix it with a number n n to undo n n times. If you want to undo your undo, <CTRL-R> will redo. Navigation + Editing vim is powerful because you can combine operations with navigation . For instance c to change, d to delete, y to yank (copy). Since w is the navigation command to move over the current word, combining them we get: cw change the current word (delete the current word and enter insert mode) dw delete the current word yw yank the current word (copy word into buffer) Can you guess what df) , dt) , c$ , y0 do? If you repeat the operation c , d , and y , it applies to the whole line, so: cc change the whole line dd delete the whole line yy yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5dd deletes 5 lines, 5dw deletes 5 words, etc. See the article Operator, the True Power of Vim for more details. Swapping Lines Sometimes you want to swap the order of two lines of code, in command mode, ddp will do the trick. dd deletes the current line, p paste it after the current line, in effect swapping the order of the two lines. Commenting blocks of code Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line V enter visual mode Use arrow key to select the block of code you want to comment. I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) // to insert the Java comment character (you will see it inserted in the current line, but don't worry) to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line <CTRL-v> enter block visual mode Use arrow key to select the columns of text containing // x to delete them 4. Other Advanced Features Search and Replace in vim :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurance of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement Shell Command If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , :!<command> will issue the command to shell. E.g., :!ls You can use this to compile your current file, without exiting vim . :!make make is actually a builtin command for vim so you can also simply run :make Abbreviation You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long( Auto-Completion You can <CTRL-P> to auto-complete. By default, the auto-complete dictionary is based on text in your current editing buffers. This is a very useful keystroke saver for long function and variable names. Auto-Indent the Whole File You can gg=G in command mode to auto-indent the whole file. gg is the command to go to the beginning of the file. = is the command to indent. G is the command to go to the end of the file. Splitting vim 's Viewport :sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl-w Ctrl-w moves between the different vim viewports 5. Plugins Syntax and Style Checker I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" New Addition: By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: -Wall -I/home/course/cs1010/include","title":"Vim"},{"location":"vim.html#vim-tips","text":"I collected below some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively .","title":"Vim Tips"},{"location":"vim.html#1-useful-configuration","text":"You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you starts vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim .","title":"1. Useful Configuration"},{"location":"vim.html#help","text":"In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup .","title":"Help"},{"location":"vim.html#backup-files","text":"You can ask vim to automatically backup files that you edit. This has been a life saver for me in multiple occasions. In your ~/.vimrc file, set backup will cause a copy of your file to be save with suffix ~ appended to its name everytime you save. I prefer not to clutter my working directory, so I set set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regreted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you.","title":"Backup Files"},{"location":"vim.html#syntax-highlighting","text":"If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : syntax on","title":"Syntax Highlighting"},{"location":"vim.html#ruler-and-numbers","text":"If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc set ruler will display the line number and the column number on the lower right corner. You can also add set number to label each line with a line number.","title":"Ruler and Numbers"},{"location":"vim.html#auto-indentation-czjqqkd0newczjqqkd1","text":"Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : set shiftwidth=2","title":"Auto Indentation \u0002czjqqkd:0\u0003(new)\u0002czjqqkd:1\u0003"},{"location":"vim.html#2-navigation","text":"","title":"2. Navigation"},{"location":"vim.html#basic-navigation","text":"Use k and j keys to move up and down (just like Gmail and Facebook!). h and l to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many hjkl to see how you can navigate faster). w jump to the beginning of the next word b jump to the beginning of the previous word (reverse of w ) e jump to the end of the word (or next word when pressed again) f + char: search forward in the line and sit on the next matching char t + char: search forward in the line and sit on one space before the matching char $ jump to end of line 0 jump to the beginning of the line ^ jump to the first non-blank character of the line % jump between matching parentheses CTRL- d jump forward (Down) half page CTRL- f jump Forward one page CTRL- u jump backward (Up) half page CTRL- b jump Backward half page","title":"Basic Navigation"},{"location":"vim.html#jumping-to-a-line","text":"If the compiler tells you there is an error on Line x x , you can issue :<x> to jump to Line x x . For instance, :40 will go to Line 40.","title":"Jumping to a Line"},{"location":"vim.html#3-editing-operations","text":"","title":"3. Editing Operations"},{"location":"vim.html#undo","text":"Since we are on the topic of correcting mistakes, u in command mode undo your changes. Prefix it with a number n n to undo n n times. If you want to undo your undo, <CTRL-R> will redo.","title":"Undo"},{"location":"vim.html#navigation-editing","text":"vim is powerful because you can combine operations with navigation . For instance c to change, d to delete, y to yank (copy). Since w is the navigation command to move over the current word, combining them we get: cw change the current word (delete the current word and enter insert mode) dw delete the current word yw yank the current word (copy word into buffer) Can you guess what df) , dt) , c$ , y0 do? If you repeat the operation c , d , and y , it applies to the whole line, so: cc change the whole line dd delete the whole line yy yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5dd deletes 5 lines, 5dw deletes 5 words, etc. See the article Operator, the True Power of Vim for more details.","title":"Navigation + Editing"},{"location":"vim.html#swapping-lines","text":"Sometimes you want to swap the order of two lines of code, in command mode, ddp will do the trick. dd deletes the current line, p paste it after the current line, in effect swapping the order of the two lines.","title":"Swapping Lines"},{"location":"vim.html#commenting-blocks-of-code","text":"Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line V enter visual mode Use arrow key to select the block of code you want to comment. I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) // to insert the Java comment character (you will see it inserted in the current line, but don't worry) to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line <CTRL-v> enter block visual mode Use arrow key to select the columns of text containing // x to delete them","title":"Commenting blocks of code"},{"location":"vim.html#4-other-advanced-features","text":"","title":"4. Other Advanced Features"},{"location":"vim.html#search-and-replace-in-vim","text":":%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurance of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement","title":"Search and Replace in vim"},{"location":"vim.html#shell-command","text":"If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , :!<command> will issue the command to shell. E.g., :!ls You can use this to compile your current file, without exiting vim . :!make make is actually a builtin command for vim so you can also simply run :make","title":"Shell Command"},{"location":"vim.html#abbreviation","text":"You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long(","title":"Abbreviation"},{"location":"vim.html#auto-completion","text":"You can <CTRL-P> to auto-complete. By default, the auto-complete dictionary is based on text in your current editing buffers. This is a very useful keystroke saver for long function and variable names.","title":"Auto-Completion"},{"location":"vim.html#auto-indent-the-whole-file","text":"You can gg=G in command mode to auto-indent the whole file. gg is the command to go to the beginning of the file. = is the command to indent. G is the command to go to the end of the file.","title":"Auto-Indent the Whole File"},{"location":"vim.html#splitting-vims-viewport","text":":sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl-w Ctrl-w moves between the different vim viewports","title":"Splitting vim's Viewport"},{"location":"vim.html#5-plugins","text":"","title":"5. Plugins"},{"location":"vim.html#syntax-and-style-checker","text":"I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" New Addition: By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: -Wall -I/home/course/cs1010/include","title":"Syntax and Style Checker"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html","text":"Assignment 1: Comments Notes on Marking Schemes We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the main concept tested in each question (writing arithmetic expressions in invest , recursion in digits , use of functions in box , and logical expressions and conditionals in taxi ), receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group. The following list includes some of the common mistakes we encountered. General Mistakes This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers Logical Mistakes (bugs) In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully. Answer Keys Invest This problem assesses if students know how to use arithmetic operations, parenthesis, and math library properly. Most common mistakes include using float and int as data type, which would lead to loss of precision and overflow. Suppose someone has $2.6 billion in his bank account, using int would cause an overflow. /** * CS1010 Semester 1 AY18/19 * Assignment 1: Invest * * Read in three positive integer corresponding to the principal, the * interest rate, and the number of years. Print the resulting amount * after the given num of years to the standard output. * * @file: invest.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" #include <math.h> int main () { long principal = cs1010_read_long (); long rate = cs1010_read_long (); long num_of_years = cs1010_read_long (); double r = rate / 100.0 ; double result = principal * ( 1 - pow ( r , num_of_years + 1 )) / ( 1 - r ); cs1010_println_double ( result ); } Box This problem tests if students know how to write and reuse functions. Some students wrote different versions of area_of_rectangle : long area_of_rectangle1 ( long width , long height ) { return width * height ; } long area_of_rectangle2 ( long width , long base ) { return width * base ; } long area_of_rectangle3 ( long base , long height ) { return base * height ; } demonstrating that they do not understand how functions can be reused by passing in different parameters. This problem also demonstrates how functions written for another problem (calculating the hypotenuse of a triangle in class) can be used to solve a different problem (diagonal of the box). The hypotenuse_of function written in class, however, takes in long instead of double , so we have to change that. Some of you also change the hypotenuse_of method to take in three parameters so that it calculates the diagonal directly. This solution is fine as well. /** * CS1010 Semester 1 AY18/19 * Assignment 1: Box * * Read in three positive integer corresponding to the width, * height, and length of a box from the standard input, and * print the total surface area and the length of the diagonal * to the standard output. * * @file: box.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" #include <math.h> /** * Calculate the hypotenuse of a triangle. * * @param[in] base The base of the triangle. * @param[in] height The height of the triangle. * @return The hypotenuse of the triangle. */ double hypotenuse_of ( double base , double height ) { return sqrt ( base * base + height * height ); } /** * Calculate the area of a rectangle. * * @param[in] width The width of the rectangle. * @param[in] height The height of the rectangle. * @return The surface area of the rectangle. */ long area_of_rectangle ( long width , long height ) { return width * height ; } int main () { long width = cs1010_read_long (); long height = cs1010_read_long (); long length = cs1010_read_long (); long surface_area = 2 * area_of_rectangle ( width , height ) + 2 * area_of_rectangle ( width , length ) + 2 * area_of_rectangle ( length , height ); cs1010_print_long ( surface_area ); cs1010_print_string ( \" \" ); double hypotenuse = hypotenuse_of ( hypotenuse_of ( width , height ), length ); cs1010_println_double ( hypotenuse ); } Digits Most students who solve this correctly (without a loop and without segmentation fault) are able to get the idea of how recursion can be used here. The most common error we see if a mismatch of types, where students use int leading to failure when we test with a large integer beyond the range of int . /** * CS1010 Semester 1 AY18/19 * Assignment 1: Digits * * Read in a positive integer from the standard input and print * the sum of all digits in the integer to the standard output. * * @file: digits.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" /** * Sum the digits in input. * * @param[in] input The integer whose digits we are summing. * @return The sum of digits in the parameter input. */ long sum_of_digits ( long input ) { if ( input < 10 ) { return input ; } long last_digit = input % 10 ; long rest = input / 10 ; return last_digit + sum_of_digits ( rest ); } int main () { long input = cs1010_read_long (); cs1010_println_long ( sum_of_digits ( input )); } Taxi This is a more complex problem. We hope that students, when thinking about the solution of this problem, can appreciate the importance of breaking down the problem into simpler subproblems so that you can think, solve, and test the sub-solutions, independently, before combining them to solve the larger problem. Another objective of this question is to get students to think about what parameters and variables are needed to solve a subproblem. Students who think through this should realize that to calculate the metered fare only the distance is needed and to calculate the surcharge, only the day and time is needed. Further, to determine evening peak and midnight peak, only the hour is needed (not minutes nor day). Some common mistakes include being careless in checking for the peak hour surcharge (bug in logical expressions). Some students use ceil to calculate the metered fare, which is fine (simpler than the sample code below). But a few students incorrectly use round instead. /** * CS1010 Semester 1 AY18/19 * Assignment 1: Taxi * * Read in four positive integer corresponding to the day of the week, * the hour and minute of boarding, and the distance traveled. Print * to the standard output, the fare of the taxi. * height, and length of a box from the standard input, and * print the total surface area and the length of the diagonal * to the standard output. * * @file: taxi.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" #include <stdbool.h> /** * Check if a given day is a weekday. * * @param[in] day The day of the week (1 for Monday, 7 for Sunday). * @return true if the day is a weekday, false otherwise. */ bool is_weekday ( long day ) { return ( day >= 1 && day <= 5 ); } /** * Check if a given time falls under morning peak hour (6am to 9:29am) * * @param[in] hour The given hour. * @param[in] minute The given minute. * @return true if the given time falls under morning peak hour. * false otherwise. */ bool is_morning_peak ( long hour , long minute ) { return ( hour >= 6 && hour < 9 ) || ( hour == 9 && minute <= 29 ); } /** * Check if a given time falls under evening peak hour (6pm to 11:59pm). * * @param[in] hour The given hour. * @return true if the given time falls under morning peak hour. * false otherwise. */ bool is_evening_peak ( long hour ) { return ( hour >= 18 && hour <= 23 ); } /** * Check if a given time falls under midnight peak hour (0:00 to 5:59am). * * @param[in] hour The given hour. * @return true if the given time falls under midnight peak hour. * false otherwise. */ bool is_midnight_peak ( long hour ) { return ( hour >= 0 && hour < 6 ); } /** * Check if surchange should be applied given day and time. * * @param[in] day Day of the taxi trip * @param[in] hour Hour of boarding time. * @param[in] minute Minute of boarding time * @return The surchage applied (1.0 if no surcharge)). */ double surcharge ( long day , long hour , long minute ) { if ( is_weekday ( day ) && is_morning_peak ( hour , minute )) { return 1.25 ; } if ( is_evening_peak ( hour )) { return 1.25 ; } if ( is_midnight_peak ( hour )) { return 1.5 ; } return 1.0 ; } /** * Calculate the metered fare for a taxi trip (before surcharge). * * @param[in] distance The distance travelled. */ double metered_fare ( long distance ) { double fare = 3.40 ; distance -= 1000 ; if ( distance <= 0 ) { return fare ; } if ( distance <= 9200 ) { fare += 0.22 * ( distance / 400 ); if ( distance % 400 > 0 ) { fare += 0.22 ; } } else { fare += 0.22 * ( 9200 / 400 ); } distance -= 9200 ; if ( distance <= 0 ) { return fare ; } fare += 0.22 * ( distance / 350 ); if ( distance % 350 > 0 ) { fare += 0.22 ; } return fare ; } /** * Calculate the fare for a taxi trip (including surcharge). * * @param[in] day Day of the taxi trip * @param[in] hour Hour of boarding time * @param[in] minute Minute of boarding time * @param[in] distance The distance travelled */ double fare ( long day , long hour , long minute , long distance ) { return metered_fare ( distance ) * surcharge ( day , hour , minute ); } int main () { long day = cs1010_read_long (); long start_hour = cs1010_read_long (); long start_minute = cs1010_read_long (); long distance = cs1010_read_long (); cs1010_println_double ( fare ( day , start_hour , start_minute , distance )); }","title":"Assignment 1: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#assignment-1-comments","text":"","title":"Assignment 1: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#notes-on-marking-schemes","text":"We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the main concept tested in each question (writing arithmetic expressions in invest , recursion in digits , use of functions in box , and logical expressions and conditionals in taxi ), receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group. The following list includes some of the common mistakes we encountered.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#general-mistakes","text":"This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers","title":"General Mistakes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#logical-mistakes-bugs","text":"In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully.","title":"Logical Mistakes (bugs)"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#invest","text":"This problem assesses if students know how to use arithmetic operations, parenthesis, and math library properly. Most common mistakes include using float and int as data type, which would lead to loss of precision and overflow. Suppose someone has $2.6 billion in his bank account, using int would cause an overflow. /** * CS1010 Semester 1 AY18/19 * Assignment 1: Invest * * Read in three positive integer corresponding to the principal, the * interest rate, and the number of years. Print the resulting amount * after the given num of years to the standard output. * * @file: invest.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" #include <math.h> int main () { long principal = cs1010_read_long (); long rate = cs1010_read_long (); long num_of_years = cs1010_read_long (); double r = rate / 100.0 ; double result = principal * ( 1 - pow ( r , num_of_years + 1 )) / ( 1 - r ); cs1010_println_double ( result ); }","title":"Invest"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#box","text":"This problem tests if students know how to write and reuse functions. Some students wrote different versions of area_of_rectangle : long area_of_rectangle1 ( long width , long height ) { return width * height ; } long area_of_rectangle2 ( long width , long base ) { return width * base ; } long area_of_rectangle3 ( long base , long height ) { return base * height ; } demonstrating that they do not understand how functions can be reused by passing in different parameters. This problem also demonstrates how functions written for another problem (calculating the hypotenuse of a triangle in class) can be used to solve a different problem (diagonal of the box). The hypotenuse_of function written in class, however, takes in long instead of double , so we have to change that. Some of you also change the hypotenuse_of method to take in three parameters so that it calculates the diagonal directly. This solution is fine as well. /** * CS1010 Semester 1 AY18/19 * Assignment 1: Box * * Read in three positive integer corresponding to the width, * height, and length of a box from the standard input, and * print the total surface area and the length of the diagonal * to the standard output. * * @file: box.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" #include <math.h> /** * Calculate the hypotenuse of a triangle. * * @param[in] base The base of the triangle. * @param[in] height The height of the triangle. * @return The hypotenuse of the triangle. */ double hypotenuse_of ( double base , double height ) { return sqrt ( base * base + height * height ); } /** * Calculate the area of a rectangle. * * @param[in] width The width of the rectangle. * @param[in] height The height of the rectangle. * @return The surface area of the rectangle. */ long area_of_rectangle ( long width , long height ) { return width * height ; } int main () { long width = cs1010_read_long (); long height = cs1010_read_long (); long length = cs1010_read_long (); long surface_area = 2 * area_of_rectangle ( width , height ) + 2 * area_of_rectangle ( width , length ) + 2 * area_of_rectangle ( length , height ); cs1010_print_long ( surface_area ); cs1010_print_string ( \" \" ); double hypotenuse = hypotenuse_of ( hypotenuse_of ( width , height ), length ); cs1010_println_double ( hypotenuse ); }","title":"Box"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#digits","text":"Most students who solve this correctly (without a loop and without segmentation fault) are able to get the idea of how recursion can be used here. The most common error we see if a mismatch of types, where students use int leading to failure when we test with a large integer beyond the range of int . /** * CS1010 Semester 1 AY18/19 * Assignment 1: Digits * * Read in a positive integer from the standard input and print * the sum of all digits in the integer to the standard output. * * @file: digits.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" /** * Sum the digits in input. * * @param[in] input The integer whose digits we are summing. * @return The sum of digits in the parameter input. */ long sum_of_digits ( long input ) { if ( input < 10 ) { return input ; } long last_digit = input % 10 ; long rest = input / 10 ; return last_digit + sum_of_digits ( rest ); } int main () { long input = cs1010_read_long (); cs1010_println_long ( sum_of_digits ( input )); }","title":"Digits"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as01-comments.html#taxi","text":"This is a more complex problem. We hope that students, when thinking about the solution of this problem, can appreciate the importance of breaking down the problem into simpler subproblems so that you can think, solve, and test the sub-solutions, independently, before combining them to solve the larger problem. Another objective of this question is to get students to think about what parameters and variables are needed to solve a subproblem. Students who think through this should realize that to calculate the metered fare only the distance is needed and to calculate the surcharge, only the day and time is needed. Further, to determine evening peak and midnight peak, only the hour is needed (not minutes nor day). Some common mistakes include being careless in checking for the peak hour surcharge (bug in logical expressions). Some students use ceil to calculate the metered fare, which is fine (simpler than the sample code below). But a few students incorrectly use round instead. /** * CS1010 Semester 1 AY18/19 * Assignment 1: Taxi * * Read in four positive integer corresponding to the day of the week, * the hour and minute of boarding, and the distance traveled. Print * to the standard output, the fare of the taxi. * height, and length of a box from the standard input, and * print the total surface area and the length of the diagonal * to the standard output. * * @file: taxi.c * @author: XXX (Group YYY) */ #include \"cs1010.h\" #include <stdbool.h> /** * Check if a given day is a weekday. * * @param[in] day The day of the week (1 for Monday, 7 for Sunday). * @return true if the day is a weekday, false otherwise. */ bool is_weekday ( long day ) { return ( day >= 1 && day <= 5 ); } /** * Check if a given time falls under morning peak hour (6am to 9:29am) * * @param[in] hour The given hour. * @param[in] minute The given minute. * @return true if the given time falls under morning peak hour. * false otherwise. */ bool is_morning_peak ( long hour , long minute ) { return ( hour >= 6 && hour < 9 ) || ( hour == 9 && minute <= 29 ); } /** * Check if a given time falls under evening peak hour (6pm to 11:59pm). * * @param[in] hour The given hour. * @return true if the given time falls under morning peak hour. * false otherwise. */ bool is_evening_peak ( long hour ) { return ( hour >= 18 && hour <= 23 ); } /** * Check if a given time falls under midnight peak hour (0:00 to 5:59am). * * @param[in] hour The given hour. * @return true if the given time falls under midnight peak hour. * false otherwise. */ bool is_midnight_peak ( long hour ) { return ( hour >= 0 && hour < 6 ); } /** * Check if surchange should be applied given day and time. * * @param[in] day Day of the taxi trip * @param[in] hour Hour of boarding time. * @param[in] minute Minute of boarding time * @return The surchage applied (1.0 if no surcharge)). */ double surcharge ( long day , long hour , long minute ) { if ( is_weekday ( day ) && is_morning_peak ( hour , minute )) { return 1.25 ; } if ( is_evening_peak ( hour )) { return 1.25 ; } if ( is_midnight_peak ( hour )) { return 1.5 ; } return 1.0 ; } /** * Calculate the metered fare for a taxi trip (before surcharge). * * @param[in] distance The distance travelled. */ double metered_fare ( long distance ) { double fare = 3.40 ; distance -= 1000 ; if ( distance <= 0 ) { return fare ; } if ( distance <= 9200 ) { fare += 0.22 * ( distance / 400 ); if ( distance % 400 > 0 ) { fare += 0.22 ; } } else { fare += 0.22 * ( 9200 / 400 ); } distance -= 9200 ; if ( distance <= 0 ) { return fare ; } fare += 0.22 * ( distance / 350 ); if ( distance % 350 > 0 ) { fare += 0.22 ; } return fare ; } /** * Calculate the fare for a taxi trip (including surcharge). * * @param[in] day Day of the taxi trip * @param[in] hour Hour of boarding time * @param[in] minute Minute of boarding time * @param[in] distance The distance travelled */ double fare ( long day , long hour , long minute , long distance ) { return metered_fare ( distance ) * surcharge ( day , hour , minute ); } int main () { long day = cs1010_read_long (); long start_hour = cs1010_read_long (); long start_minute = cs1010_read_long (); long distance = cs1010_read_long (); cs1010_println_double ( fare ( day , start_hour , start_minute , distance )); }","title":"Taxi"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html","text":"Assignment 2: Comments Mark Distribution Output from histogram . Marks are scaled up by 3x. \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 10 - 20 20 - 30 30 - 40 \u2588 40 - 50 \u2588\u2588 50 - 60 60 - 70 \u2588 70 - 80 \u2588 80 - 90 \u2588\u2588\u2588\u258c 90 - 100 \u2588\u2588\u258c Notes on Marking Schemes We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group. Style Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. To be safe, please follow strictly the CS1010 coding standards. General Mistakes This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers Logical Mistakes (bugs) In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully. Misunderstanding about if - else We noted that there are students who did not understand how if - else works. For instance, there are students who write this: if ( day == 0 ) { cs1010_println_string ( \"Monday\" ); } if ( day == 1 ) { cs1010_println_string ( \"Tuesday\" ); } The above actually compares day with 0 , 1 , .. multiple times, even after a match is found, which is redundant. Since day can take on only a single value. The correct way is to use else if ( day == 0 ) { cs1010_println_string ( \"Monday\" ); } else if ( day == 1 ) { cs1010_println_string ( \"Tuesday\" ); } Another mistake we see is: if ( dist > 0.7 ) { cs1010_println_string ( \"+\" ); } else if ( dist <= 0.7 && dist > 0.5 ) { cs1010_println_string ( \"*\" ); } This demonstrates that students do not fully understand the meaning of else , which negates the previous condition. Once we reach the else branch, we are guaranteed that dist > 0.7 is false, which means that dist <= 0.7 is true, so the check for dist <= 0.7 is redundant. Answer Keys Collatz We can break the problem down into three sub-problems. So, write three functions: Given a number n n , perform one step of the operation. This can be solved with a simple if-else statement. Most students do not have a problem with this. Given a number n n , find the stopping time. This involves repeatedly calling one_collatz_step until we reach 1, and count how many steps are needed. Most students do not have a problem with this. Given a number N N , find the number between 1 to N N , inclusive, that gives the largest stopping time, breaking tie by choosing the larger number . This is similar to the max problem that we have seen since Lecture 1, so most students are able to solve this. About \u2159 of you, however, did not properly break ties by choosing the larger number. Recall from your Tutorial 1 that, when you compare with max_so_far , whether you use > or >= makes a big difference here. You get 1 mark deduction if you do not break ties properly. Weekday Let's look at how to solve this problem without using any formula. The most straightforward way is to count how many days have passed since January 1, 1900, and do a % 7 . We can break the problem down into several subproblems. Suppose the input date is year , month and day , Count the number of days from January 1, 1900, to December 31, the year before (i.e., year-1 ). This can be done by just summing up, in a loop, the days in every year from 1900 to year-1 , inclusive. For each year, if it is a leap year, add 366, otherwise, add 365. Some common mistakes include an error in loop terminating condition (either adds one extra year or one less year). Check if a year is a leap year. This comes straight from Exercise 2. Count the number of days since January 1, the current year. This subproblem is similar to the problem from Exercise 2. You have to, however, be careful of whether year is a leap year. (Question 3 from Exercise 2 assumes that the year is not a leap year). So, you should add 1 to the answer if month is larger than 2 and year is a leap year. Common bugs include: (i) not checking if the current year is a leap year, and (ii) add one day for all months (not just March onwards). Determine the day of the week. From (1) and (3) you get the total number of days since January 1, 1900. We can then do a % 7 . If we get 0, it is a Monday; 1, a Tuesday; etc. Some students lose points unnecessarily by having spelling errors in the output. There are other simpler ways to solve this problem. Some students use the Zeller's Algorithm , which is perfectly fine too. Circle Again, break it down into several smaller problems. Calculate the distance of a location to the center. Most common issues we see: Many of you use pow(x, 2) to square an integer. pow is a powerful function and is written to be general, so it is slower than just doing x*x . Many of you use labs() or fabs() on the result of a square or a square root function. This is redundant since the square of a number and the square root of a number is always positive! Draw each \"pixel\" of the circle. The drawing part is actually easy. Suppose you have a function to compute the distance, say, dist(row, col, r) , and you do this: if ( dist ( row , col , r ) > 0.7 ) { cs1010_println_string ( \"+\" ); } else if ( dist ( row , col , r ) > 0.5 ) { cs1010_println_string ( \"*\" ); } else .. This is functionally correct, but it leads to multiple invocations of dist and calculation of the distance, even though the result does not change. When we start to factor in efficiency into grading criteria, you will be penalized for this. Draw each row of the circle. Draw the circle. Most students have no problem with (3) and (4) above. Pattern Some students creatively call this the \"Christmas Tree\" problem :) This might seems daunting at first, but once you break it down into smaller problems, it can be solved fairly easily. This question is designed to see if students can, at this stage, solve problems by breaking it down into multiple smaller problems -- something that we have been iterating since Lecture 2. Let say the input be the interval n n and height h h . For this problem, we can break it down into the following sub-problems: Find the first number in each leading cell at each row. Example, for n n = 2, the first number is 1, 3, 7, 13, .. For n n = 5, the first number is 1, 6, 16, 31, 51, .. This leading number can be calculated with the following loop: long leading_number ( long row , long n ) { long number = 1 ; for ( long i = 1 ; i <= row ; i += 1 ) { number += i * n ; } return number ; } Find the rest of the n-1 n-1 numbers in each leading cell at each row. Once we have the first number, we just loop through the rest of the n - 1 n - 1 , increment by row + 1 each time, something like this: void print_pattern ( long row , long col , long n ) { long num = leading_number ( row , n ); for ( long i = 0 ; i < n ; i += 1 ) { num += ( row + 1 ); } } We can then find the numbers in the rest of the cells in the same row. void print_pattern ( long row , long col , long n ) { long num = leading_number ( row , n ) + col ; // note the change here for ( long i = 0 ; i < n ; i += 1 ) { num += ( row + 1 ); } } The steps above give us the number in each cell, all we need to do now is to decide whether to print # or . Suppose we have a function is_prime , we can do this: void print_pattern ( long row , long col , long n ) { long num = leading_number ( row , n ) + col ; // note the change here bool found = false ; for ( long i = 0 ; i < n && ! found ; i += 1 ) { if ( num == 1 || is_prime ( num )) { cs1010_print_string ( \"#\" ); found = true ; } else { num += ( row + 1 ); } } if ( ! found ) { cs1010_print_string ( \" \" ); } } Now, let's figure out how to check if a number is prime. You have seen this problem in Exercise 3. But there are different solutions, with different degrees of efficiency. Here is the first version: bool is_prime ( long n ) { bool is_prime = true ; for ( long i = 2 ; i <= n - 1 ; i ++ ) { if ( n % i == 0 ) { is_prime = false ; } } return is_prime ; } It checks all numbers between 2 to n - 1 , if there is a number i by which n is divisible, then n is not prime. This is an incredibly slow implementation even though it is correct. The most glaring issue is that it continues to check, if even though it has found an \"evidence\" that n is not a prime. What we should do, instead, is to immediately bail out of the function once we found that n is not a prime. bool is_prime ( long n ) { for ( long i = 2 ; i <= n - 1 ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } We can do even better. Since the smaller integer factor is 2, there is actually no need to check if n is divisible by anything larger than n/2 . For instance, to check if 17 is prime, there is no need to check if 17 is divisible by 9, 10, 11, 12, .. 16. So we can skip checking half the number! bool is_prime ( long n ) { for ( long i = 2 ; i <= n / 2 ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } Can we do better? It turned out, yes. Suppose n is a composite number is equals to a * b , for some integer a and b . One of these two numbers must be smaller or equal to square root of n . (Spend a moment to think about why -- if you are taking CS1231, try to prove this by contradiction.) So, we do not have to check beyond the square root of n . bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } We can further optimize this. Some of you actually use the fact that every prime besides 2 and 3 must be of the form 6k - 1 or 6k + 1 and use this to speed up the is_prime() function. Now, coming back to printing the Christmas tree. Now that we know what to print in each cell, we just need to write functions to print each row and each col, padding the pattern properly to be a triangle. void print_blanks ( long width ) { for ( long i = 0 ; i < width ; i += 1 ) { cs1010_print_string ( \" \" ); } } void print_triangle ( long row , long width , long n ) { for ( long i = 0 ; i < width ; i += 1 ) { print_pattern ( row , i , n ); } } void draw_triangle ( long h , long n ) { for ( long row = 0 ; row < h ; row += 1 ) { print_blanks ( h - row - 1 ); print_triangle ( row , 2 * row + 1 , n ); print_blanks ( h - row - 1 ); cs1010_println_string ( \"\" ); } }","title":"Assignment 2: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#assignment-2-comments","text":"","title":"Assignment 2: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#mark-distribution","text":"Output from histogram . Marks are scaled up by 3x. \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 10 - 20 20 - 30 30 - 40 \u2588 40 - 50 \u2588\u2588 50 - 60 60 - 70 \u2588 70 - 80 \u2588 80 - 90 \u2588\u2588\u2588\u258c 90 - 100 \u2588\u2588\u258c","title":"Mark Distribution"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#notes-on-marking-schemes","text":"We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#style","text":"Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. To be safe, please follow strictly the CS1010 coding standards.","title":"Style"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#general-mistakes","text":"This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers","title":"General Mistakes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#logical-mistakes-bugs","text":"In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully.","title":"Logical Mistakes (bugs)"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#misunderstanding-about-if-else","text":"We noted that there are students who did not understand how if - else works. For instance, there are students who write this: if ( day == 0 ) { cs1010_println_string ( \"Monday\" ); } if ( day == 1 ) { cs1010_println_string ( \"Tuesday\" ); } The above actually compares day with 0 , 1 , .. multiple times, even after a match is found, which is redundant. Since day can take on only a single value. The correct way is to use else if ( day == 0 ) { cs1010_println_string ( \"Monday\" ); } else if ( day == 1 ) { cs1010_println_string ( \"Tuesday\" ); } Another mistake we see is: if ( dist > 0.7 ) { cs1010_println_string ( \"+\" ); } else if ( dist <= 0.7 && dist > 0.5 ) { cs1010_println_string ( \"*\" ); } This demonstrates that students do not fully understand the meaning of else , which negates the previous condition. Once we reach the else branch, we are guaranteed that dist > 0.7 is false, which means that dist <= 0.7 is true, so the check for dist <= 0.7 is redundant.","title":"Misunderstanding about if-else"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#collatz","text":"We can break the problem down into three sub-problems. So, write three functions: Given a number n n , perform one step of the operation. This can be solved with a simple if-else statement. Most students do not have a problem with this. Given a number n n , find the stopping time. This involves repeatedly calling one_collatz_step until we reach 1, and count how many steps are needed. Most students do not have a problem with this. Given a number N N , find the number between 1 to N N , inclusive, that gives the largest stopping time, breaking tie by choosing the larger number . This is similar to the max problem that we have seen since Lecture 1, so most students are able to solve this. About \u2159 of you, however, did not properly break ties by choosing the larger number. Recall from your Tutorial 1 that, when you compare with max_so_far , whether you use > or >= makes a big difference here. You get 1 mark deduction if you do not break ties properly.","title":"Collatz"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#weekday","text":"Let's look at how to solve this problem without using any formula. The most straightforward way is to count how many days have passed since January 1, 1900, and do a % 7 . We can break the problem down into several subproblems. Suppose the input date is year , month and day , Count the number of days from January 1, 1900, to December 31, the year before (i.e., year-1 ). This can be done by just summing up, in a loop, the days in every year from 1900 to year-1 , inclusive. For each year, if it is a leap year, add 366, otherwise, add 365. Some common mistakes include an error in loop terminating condition (either adds one extra year or one less year). Check if a year is a leap year. This comes straight from Exercise 2. Count the number of days since January 1, the current year. This subproblem is similar to the problem from Exercise 2. You have to, however, be careful of whether year is a leap year. (Question 3 from Exercise 2 assumes that the year is not a leap year). So, you should add 1 to the answer if month is larger than 2 and year is a leap year. Common bugs include: (i) not checking if the current year is a leap year, and (ii) add one day for all months (not just March onwards). Determine the day of the week. From (1) and (3) you get the total number of days since January 1, 1900. We can then do a % 7 . If we get 0, it is a Monday; 1, a Tuesday; etc. Some students lose points unnecessarily by having spelling errors in the output. There are other simpler ways to solve this problem. Some students use the Zeller's Algorithm , which is perfectly fine too.","title":"Weekday"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#circle","text":"Again, break it down into several smaller problems. Calculate the distance of a location to the center. Most common issues we see: Many of you use pow(x, 2) to square an integer. pow is a powerful function and is written to be general, so it is slower than just doing x*x . Many of you use labs() or fabs() on the result of a square or a square root function. This is redundant since the square of a number and the square root of a number is always positive! Draw each \"pixel\" of the circle. The drawing part is actually easy. Suppose you have a function to compute the distance, say, dist(row, col, r) , and you do this: if ( dist ( row , col , r ) > 0.7 ) { cs1010_println_string ( \"+\" ); } else if ( dist ( row , col , r ) > 0.5 ) { cs1010_println_string ( \"*\" ); } else .. This is functionally correct, but it leads to multiple invocations of dist and calculation of the distance, even though the result does not change. When we start to factor in efficiency into grading criteria, you will be penalized for this. Draw each row of the circle. Draw the circle. Most students have no problem with (3) and (4) above.","title":"Circle"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as02-comments.html#pattern","text":"Some students creatively call this the \"Christmas Tree\" problem :) This might seems daunting at first, but once you break it down into smaller problems, it can be solved fairly easily. This question is designed to see if students can, at this stage, solve problems by breaking it down into multiple smaller problems -- something that we have been iterating since Lecture 2. Let say the input be the interval n n and height h h . For this problem, we can break it down into the following sub-problems: Find the first number in each leading cell at each row. Example, for n n = 2, the first number is 1, 3, 7, 13, .. For n n = 5, the first number is 1, 6, 16, 31, 51, .. This leading number can be calculated with the following loop: long leading_number ( long row , long n ) { long number = 1 ; for ( long i = 1 ; i <= row ; i += 1 ) { number += i * n ; } return number ; } Find the rest of the n-1 n-1 numbers in each leading cell at each row. Once we have the first number, we just loop through the rest of the n - 1 n - 1 , increment by row + 1 each time, something like this: void print_pattern ( long row , long col , long n ) { long num = leading_number ( row , n ); for ( long i = 0 ; i < n ; i += 1 ) { num += ( row + 1 ); } } We can then find the numbers in the rest of the cells in the same row. void print_pattern ( long row , long col , long n ) { long num = leading_number ( row , n ) + col ; // note the change here for ( long i = 0 ; i < n ; i += 1 ) { num += ( row + 1 ); } } The steps above give us the number in each cell, all we need to do now is to decide whether to print # or . Suppose we have a function is_prime , we can do this: void print_pattern ( long row , long col , long n ) { long num = leading_number ( row , n ) + col ; // note the change here bool found = false ; for ( long i = 0 ; i < n && ! found ; i += 1 ) { if ( num == 1 || is_prime ( num )) { cs1010_print_string ( \"#\" ); found = true ; } else { num += ( row + 1 ); } } if ( ! found ) { cs1010_print_string ( \" \" ); } } Now, let's figure out how to check if a number is prime. You have seen this problem in Exercise 3. But there are different solutions, with different degrees of efficiency. Here is the first version: bool is_prime ( long n ) { bool is_prime = true ; for ( long i = 2 ; i <= n - 1 ; i ++ ) { if ( n % i == 0 ) { is_prime = false ; } } return is_prime ; } It checks all numbers between 2 to n - 1 , if there is a number i by which n is divisible, then n is not prime. This is an incredibly slow implementation even though it is correct. The most glaring issue is that it continues to check, if even though it has found an \"evidence\" that n is not a prime. What we should do, instead, is to immediately bail out of the function once we found that n is not a prime. bool is_prime ( long n ) { for ( long i = 2 ; i <= n - 1 ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } We can do even better. Since the smaller integer factor is 2, there is actually no need to check if n is divisible by anything larger than n/2 . For instance, to check if 17 is prime, there is no need to check if 17 is divisible by 9, 10, 11, 12, .. 16. So we can skip checking half the number! bool is_prime ( long n ) { for ( long i = 2 ; i <= n / 2 ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } Can we do better? It turned out, yes. Suppose n is a composite number is equals to a * b , for some integer a and b . One of these two numbers must be smaller or equal to square root of n . (Spend a moment to think about why -- if you are taking CS1231, try to prove this by contradiction.) So, we do not have to check beyond the square root of n . bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } We can further optimize this. Some of you actually use the fact that every prime besides 2 and 3 must be of the form 6k - 1 or 6k + 1 and use this to speed up the is_prime() function. Now, coming back to printing the Christmas tree. Now that we know what to print in each cell, we just need to write functions to print each row and each col, padding the pattern properly to be a triangle. void print_blanks ( long width ) { for ( long i = 0 ; i < width ; i += 1 ) { cs1010_print_string ( \" \" ); } } void print_triangle ( long row , long width , long n ) { for ( long i = 0 ; i < width ; i += 1 ) { print_pattern ( row , i , n ); } } void draw_triangle ( long h , long n ) { for ( long row = 0 ; row < h ; row += 1 ) { print_blanks ( h - row - 1 ); print_triangle ( row , 2 * row + 1 , n ); print_blanks ( h - row - 1 ); cs1010_println_string ( \"\" ); } }","title":"Pattern"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html","text":"Assignment 3: Comments Mark Distribution The output from histogram . Marks are scaled up by 3x. \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 \u258c 10 - 20 \u258c 20 - 30 30 - 40 \u258c 40 - 50 \u258c 50 - 60 \u258c 60 - 70 \u2588 70 - 80 \u2588\u2588\u2588\u2588 80 - 90 \u2588\u2588\u2588 90 - 100 \u2588\u2588\u258c Notes on Marking Schemes We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group. Style Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. To be safe, please follow strictly the CS1010 coding standards. General Mistakes This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers Logical Mistakes (bugs) In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully. Note: we didn't deduct marks for using VLA for this assignment, as you have not learned about malloc / calloc yet. Answer Keys Kendall We need to count the total number of inversions in a given array. I break this problem into two: Given an element a_i a_i , how many elements are out of the order with respect to this element? We then sum up the total number of elements out of order, for each a_i a_i . This question should be quite straightforward, except that we need to consider the following: if the pair a_i a_i and a_j a_j are out of order, then we can count this pair as one inversion only. We need to fix a convention on how we account for inversion. I use convention that we count the inversion if i < j i < j and $a_i > a_j a_j . In other words, for the subproblem 1 above, we only need to check for inversions for each element a_j a_j , if j > i j > i . a_i a_i shouldn't be the last element since there is no j j that is bigger than i i . Slightly more \u2158 of the class get this question correct, with full marks. Well done! (The snippet for this program can be found in Unit 22 on efficiency). Histogram To solve this problem, we should break the problem into two steps. First, we go through the data and count the number of items in each basket. This can be done with the following snippet. #define NUM_OF_BUCKETS 10 #define MAX_SCORE 100 : /** * Populate the buckets of the histogram based on the input array marks, containing * num_of_items items. * * @param[in] histogram Counters to store how many items fall into each bucket. * @param[in] num_of_items The number of input marks to sort into the buckets. * @param[in] marks An array of marks to be sorted into the buckets. */ void populate_histogram ( long histogram [ NUM_OF_BUCKETS ], int num_of_items , const double marks [ num_of_items ]) { double interval = MAX_SCORE / ( NUM_OF_BUCKETS * 1.0 ); for ( long i = 0 ; i < num_of_items ; i += 1 ) { long bucket = marks [ i ] / interval ; if ( bucket == NUM_OF_BUCKETS ) { bucket -= 1 ; } histogram [ bucket ] += 1 ; } } The only tricky part of this code is what happens if marks[i] is 100, in which case, marks[i]/interval would lead to bucket being 10 . Since the indices to the buckets are histogram[0] ,..., histogram[9] only, we would be writing into a memory location that we do not own if we increment histogram[10] . For this question, we were told that 100 belongs to b_9 b_9 . So, we need to decrement the variable bucket by 1. Second, after populating the buckets, we need to draw out the histogram: #define BAR_LENGTH 10.0 : double height [ NUM_OF_BUCKETS ]; for ( long i = 0 ; i < NUM_OF_BUCKETS ; i += 1 ) { cs1010_print_string ( axis_labels [ i ]); height [ i ] = BAR_LENGTH * histogram [ i ] / num_of_items ; // Print full blocks long num_of_cells = floor ( height [ i ]); for ( long j = 0 ; j < num_of_cells ; j += 1 ) { cs1010_print_string ( BLOCK ); } // Print final half-block, block or no block if height is integer double delta = height [ i ] - floor ( height [ i ]); if ( delta > 0.5 ) { cs1010_print_string ( BLOCK ); } else if ( delta > 0 ) { cs1010_print_string ( HALF_BLOCK ); } cs1010_println_string ( \"\" ); } } The purpose of this question to see how arrays can be used as a list (the input marks) and a lookup table (for histogram frequency, height, and y-axis). This should be quite straightforward. At least \u2158 of the class received 9 marks or above for this. Well done! There are some students, however, who tried to compare double variable using == operator and got deducted one mark for it. Revisit Unit 08 if you have doubts about why we should never compare double variable using == . Another common mistake that students make, at least at the beginning of doing this assignment, is to use cs1010_read_long() to read a double . The function cs1010_read_long() gives a warning if it is used to read a double value. This is one of the advantages of using the CS1010 library to read instead of the scanf functions. scanf would just silently failed and you would be left scratching your head why your code does not work! Counting Sort This is the assignment question that most students are having trouble with. Students who do not follow the instructions and use any other sorting algorithm (e.g., bubble sort) will receive 0 for correctness. Students who just loop through the array and prints out all the numbers, without counting, will get at most 2 marks for correctness. The question clearly asked you to count. // A 2 mark solution for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] == i ) { cs1010_println_long ( i ); } } } Students who just loop through the array and count, but goes through it multiple times to store the frequency of each number, will get at most 4 marks for correctness. Here, you are not exploiting array properly to help you solve the problem! // A 4 mark solution long counter [ k + 1 ] = { 0 }; for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] == i ) { counter [ i ] += 1 ; } } } for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < counter [ i ]; j += 1 ) { cs1010_println_long ( i ); } } In the code above, the counter array is useless, since we could have just use a simple counter variable (instead of an array) to achieve the same thing! // A 4 mark solution for ( int i = 1 ; i <= k ; i += 1 ) { long counter = 0 ; for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] == i ) { counter += 1 ; } } for ( int j = 0 ; j < counter ; j += 1 ) { cs1010_println_long ( i ); } } What we are looking for, and the \"mental leap\" that we want to see in the students, is how we can use an array as a lookup table to store the frequency counters. // An 8 mark solution long counter [ k + 1 ] = { 0 }; for ( int j = 0 ; j < n ; j += 1 ) { counter [ a [ j ]] += 1 ; } for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < counter [ i ]; j += 1 ) { cs1010_println_long ( i ); } } Only about half the class get this. But hopefully, after this assignment, everyone gets how powerful a lookup table is as a problem-solving tool. A final comment about the loop: for ( int j = 0 ; j < n ; j += 1 ) { counter [ a [ j ]] += 1 ; } We should not actually write code that looks like this unless we can be sure that a[j] is within range of 1 and k k . There is a reason that we ask you to validate the input for this question, but not for any other questions. Because, for this question, if you do not validate the input, it is very easy to access a location that is out-of-bounds of your array and crash your program. for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] >= 1 && a [ j ] <= k ) { counter [ a [ j ]] += 1 ; } }","title":"Assignment 3: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#assignment-3-comments","text":"","title":"Assignment 3: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#mark-distribution","text":"The output from histogram . Marks are scaled up by 3x. \u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534 0 - 10 \u258c 10 - 20 \u258c 20 - 30 30 - 40 \u258c 40 - 50 \u258c 50 - 60 \u258c 60 - 70 \u2588 70 - 80 \u2588\u2588\u2588\u2588 80 - 90 \u2588\u2588\u2588 90 - 100 \u2588\u2588\u258c","title":"Mark Distribution"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#notes-on-marking-schemes","text":"We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#style","text":"Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. To be safe, please follow strictly the CS1010 coding standards.","title":"Style"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#general-mistakes","text":"This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers","title":"General Mistakes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#logical-mistakes-bugs","text":"In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully. Note: we didn't deduct marks for using VLA for this assignment, as you have not learned about malloc / calloc yet.","title":"Logical Mistakes (bugs)"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#kendall","text":"We need to count the total number of inversions in a given array. I break this problem into two: Given an element a_i a_i , how many elements are out of the order with respect to this element? We then sum up the total number of elements out of order, for each a_i a_i . This question should be quite straightforward, except that we need to consider the following: if the pair a_i a_i and a_j a_j are out of order, then we can count this pair as one inversion only. We need to fix a convention on how we account for inversion. I use convention that we count the inversion if i < j i < j and $a_i > a_j a_j . In other words, for the subproblem 1 above, we only need to check for inversions for each element a_j a_j , if j > i j > i . a_i a_i shouldn't be the last element since there is no j j that is bigger than i i . Slightly more \u2158 of the class get this question correct, with full marks. Well done! (The snippet for this program can be found in Unit 22 on efficiency).","title":"Kendall"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#histogram","text":"To solve this problem, we should break the problem into two steps. First, we go through the data and count the number of items in each basket. This can be done with the following snippet. #define NUM_OF_BUCKETS 10 #define MAX_SCORE 100 : /** * Populate the buckets of the histogram based on the input array marks, containing * num_of_items items. * * @param[in] histogram Counters to store how many items fall into each bucket. * @param[in] num_of_items The number of input marks to sort into the buckets. * @param[in] marks An array of marks to be sorted into the buckets. */ void populate_histogram ( long histogram [ NUM_OF_BUCKETS ], int num_of_items , const double marks [ num_of_items ]) { double interval = MAX_SCORE / ( NUM_OF_BUCKETS * 1.0 ); for ( long i = 0 ; i < num_of_items ; i += 1 ) { long bucket = marks [ i ] / interval ; if ( bucket == NUM_OF_BUCKETS ) { bucket -= 1 ; } histogram [ bucket ] += 1 ; } } The only tricky part of this code is what happens if marks[i] is 100, in which case, marks[i]/interval would lead to bucket being 10 . Since the indices to the buckets are histogram[0] ,..., histogram[9] only, we would be writing into a memory location that we do not own if we increment histogram[10] . For this question, we were told that 100 belongs to b_9 b_9 . So, we need to decrement the variable bucket by 1. Second, after populating the buckets, we need to draw out the histogram: #define BAR_LENGTH 10.0 : double height [ NUM_OF_BUCKETS ]; for ( long i = 0 ; i < NUM_OF_BUCKETS ; i += 1 ) { cs1010_print_string ( axis_labels [ i ]); height [ i ] = BAR_LENGTH * histogram [ i ] / num_of_items ; // Print full blocks long num_of_cells = floor ( height [ i ]); for ( long j = 0 ; j < num_of_cells ; j += 1 ) { cs1010_print_string ( BLOCK ); } // Print final half-block, block or no block if height is integer double delta = height [ i ] - floor ( height [ i ]); if ( delta > 0.5 ) { cs1010_print_string ( BLOCK ); } else if ( delta > 0 ) { cs1010_print_string ( HALF_BLOCK ); } cs1010_println_string ( \"\" ); } } The purpose of this question to see how arrays can be used as a list (the input marks) and a lookup table (for histogram frequency, height, and y-axis). This should be quite straightforward. At least \u2158 of the class received 9 marks or above for this. Well done! There are some students, however, who tried to compare double variable using == operator and got deducted one mark for it. Revisit Unit 08 if you have doubts about why we should never compare double variable using == . Another common mistake that students make, at least at the beginning of doing this assignment, is to use cs1010_read_long() to read a double . The function cs1010_read_long() gives a warning if it is used to read a double value. This is one of the advantages of using the CS1010 library to read instead of the scanf functions. scanf would just silently failed and you would be left scratching your head why your code does not work!","title":"Histogram"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as03-comments.html#counting-sort","text":"This is the assignment question that most students are having trouble with. Students who do not follow the instructions and use any other sorting algorithm (e.g., bubble sort) will receive 0 for correctness. Students who just loop through the array and prints out all the numbers, without counting, will get at most 2 marks for correctness. The question clearly asked you to count. // A 2 mark solution for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] == i ) { cs1010_println_long ( i ); } } } Students who just loop through the array and count, but goes through it multiple times to store the frequency of each number, will get at most 4 marks for correctness. Here, you are not exploiting array properly to help you solve the problem! // A 4 mark solution long counter [ k + 1 ] = { 0 }; for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] == i ) { counter [ i ] += 1 ; } } } for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < counter [ i ]; j += 1 ) { cs1010_println_long ( i ); } } In the code above, the counter array is useless, since we could have just use a simple counter variable (instead of an array) to achieve the same thing! // A 4 mark solution for ( int i = 1 ; i <= k ; i += 1 ) { long counter = 0 ; for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] == i ) { counter += 1 ; } } for ( int j = 0 ; j < counter ; j += 1 ) { cs1010_println_long ( i ); } } What we are looking for, and the \"mental leap\" that we want to see in the students, is how we can use an array as a lookup table to store the frequency counters. // An 8 mark solution long counter [ k + 1 ] = { 0 }; for ( int j = 0 ; j < n ; j += 1 ) { counter [ a [ j ]] += 1 ; } for ( int i = 1 ; i <= k ; i += 1 ) { for ( int j = 0 ; j < counter [ i ]; j += 1 ) { cs1010_println_long ( i ); } } Only about half the class get this. But hopefully, after this assignment, everyone gets how powerful a lookup table is as a problem-solving tool. A final comment about the loop: for ( int j = 0 ; j < n ; j += 1 ) { counter [ a [ j ]] += 1 ; } We should not actually write code that looks like this unless we can be sure that a[j] is within range of 1 and k k . There is a reason that we ask you to validate the input for this question, but not for any other questions. Because, for this question, if you do not validate the input, it is very easy to access a location that is out-of-bounds of your array and crash your program. for ( int j = 0 ; j < n ; j += 1 ) { if ( a [ j ] >= 1 && a [ j ] <= k ) { counter [ a [ j ]] += 1 ; } }","title":"Counting Sort"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html","text":"Assignment 4: Comments Notes on Marking Schemes We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group. Style Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. To be safe, please follow strictly the CS1010 coding standards. Documentation Two marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 4. If you did not document your function, parameters, return values, or document wrongly (e.g., confused between @param[out] with @return , you will get a deduction of 1 mark. You get 0 if there is no documentation at all. The following are common formatting errors: @param command used in a comment that is not attached to a function declaration @return command used in a comment that is attached to a function returning void Parameter name not found in the function declaration. You should put the name of the variable only, exclude the type, * , [] . Putting @param with the parameter name, but no description of what the parameter does. Missing [in] , [out] , or [in,out] . Note that there is no space after , in [in,out] . General Mistakes This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers new -1 for using variable length array new -1 for extra elements in the array initializers new -1 for hardcoding the size of the array, hoping that it is big enough. new -1 for memory leaks Logical Mistakes (bugs) In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully. Answer Keys SelectionSort This is an easy question, but unfortunately, less than half the class received full marks. Most of these are due to lack of documentation >.< /** * Sort the input array list using selection sort. * * @param[in] length The size of the array * @param[in,out] list The array to sort */ void selection_sort ( long length , long list [ length ]) { long last = length ; for ( long i = 1 ; i <= length - 1 ; i += 1 ) { long curr_pos = last - 1 ; // Find the position of the max number between list[0]..list[last-1] long max_pos = max ( last , list ); if ( max_pos != curr_pos ) { long temp = list [ max_pos ]; list [ max_pos ] = list [ curr_pos ]; list [ curr_pos ] = temp ; } print ( length , list ); last -= 1 ; } } The only common mistake we see here is that the max function does not handle negative values. Add The most common mistake is accessing memory locations outside of the bound of the array. This is usually due to careless mistakes (forgetting to allocate an extra space for null character at the end of the string, or forgetting to allocate the extra carry). I have seen lots of code that compute the addition in one long chunk of code, making it hard to read, understand, and debug. Remember to practice decomposition -- breaking down the problem into smaller subproblems, and solve each one by writing a small function. For me, I broke down the tasks of adding two arbitrary large integers to adding two digits (with a possible carry): ** * Perform a single digit addition . The digits are stored in * char form . * * @ pre a and b can only be '0' , '1' , .. '9' * @ param [ in ] a The first operand of addition ( in char ) * @ param [ in ] b The second operand of addition ( in char ) * @ param [ in , out ] has_carry Whether we should add a carry when adding * a + b . If a + b generates a carry , * has_carry * will be set to true , otherwise to false . * * @ return The least significant digit of a + b ( as char ) */ char add_digit ( char a , char b , bool * has_carry ) { long sum = ( a - '0' ) + ( b - '0' ); char result ; if ( * has_carry ) { sum += 1 ; } if ( sum >= 10 ) { result = ( sum % 10 ) + '0' ; * has_carry = true ; } else { result = sum + '0' ; * has_carry = false ; } return result ; } Then, I add digits by digits, starting from least significant digits. Some students reverse the strings and add from the front -- which is unnecessary. long len1 = strlen ( operand1 ); long len2 = strlen ( operand2 ); long max = ( len1 > len2 ) ? len1 : len2 ; char result [ max + 2 ]; result [ max + 1 ] = '\\0' ; // starting from the back, add digit by digit long i = len1 - 1 ; long j = len2 - 1 ; long k = max ; bool has_carry = false ; while ( i >= 0 && j >= 0 ) { result [ k ] = add_digit ( operand1 [ i ], operand2 [ j ], & has_carry ); i -= 1 ; j -= 1 ; k -= 1 ; } Once I exit the while loop, I have either i < 0 || j < 0 . I have exhausted the digits in one of the operands. I figure out which one and continue to add 0 to the remaining operand. // done with the shorter number. Now handle the rest. char * rest ; if ( j >= 0 ) { rest = operand2 ; } else { rest = operand1 ; j = i ; } while ( j >= 0 ) { result [ k ] = add_digit ( rest [ j ], '0' , & has_carry ); k -= 1 ; j -= 1 ; } Finally, I check if there is a carry and print out the content accordingly: if ( has_carry ) { result [ k ] = '1' ; cs1010_println_string ( result ); } else { cs1010_println_string ( & result [ 1 ]); } Some students store each digit in a long or int , which makes it easier to handle the final carry. This approach takes more memory than storing a char but is fine. MasterMind One way to solve mastermind is to keep a temporary array (I called it marked ) that stores the same content as answer but once we found a match, we \"checked off\" the character so that id does not match again. #define MATCHED ' ' for ( long i = 0 ; i < PUZZLE_SIZE ; i += 1 ) { marked [ i ] = answer [ i ]; } long same_color_same_pos = 0 ; long same_color_diff_pos = 0 ; for ( long i = 0 ; i < PUZZLE_SIZE ; i += 1 ) { if ( guess [ i ] == marked [ i ]) { same_color_same_pos += 1 ; marked [ i ] = MATCHED ; } } for ( long i = 0 ; i < PUZZLE_SIZE ; i += 1 ) { bool found = false ; for ( long j = 0 ; j < PUZZLE_SIZE && ! found ; j += 1 ) { if ( guess [ i ] != answer [ i ] && guess [ i ] == marked [ j ]) { same_color_diff_pos += 1 ; found = true ; marked [ j ] = MATCHED ; } } } The two output numbers are same_color_same_pos and same_color_diff_pos . Despite being asked and clarified on Piazza at least twice, some students still stopped the game after 8 guesses. Please (i) read the question carefully, and (ii) read Piazza.","title":"Assignment 4: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#assignment-4-comments","text":"","title":"Assignment 4: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#notes-on-marking-schemes","text":"We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#style","text":"Two marks are allocated for each question. We won't penalize for every violation, but instead, the grader judges whether the code is clean, understandable, properly indented, use proper variable names, etc. 0 - 0.5 marks for very bad style, 1.0 - 1.5 for something in the middle, 2 for an ok code. To be safe, please follow strictly the CS1010 coding standards.","title":"Style"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#documentation","text":"Two marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 4. If you did not document your function, parameters, return values, or document wrongly (e.g., confused between @param[out] with @return , you will get a deduction of 1 mark. You get 0 if there is no documentation at all. The following are common formatting errors: @param command used in a comment that is not attached to a function declaration @return command used in a comment that is attached to a function returning void Parameter name not found in the function declaration. You should put the name of the variable only, exclude the type, * , [] . Putting @param with the parameter name, but no description of what the parameter does. Missing [in] , [out] , or [in,out] . Note that there is no space after , in [in,out] .","title":"Documentation"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#general-mistakes","text":"This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers new -1 for using variable length array new -1 for extra elements in the array initializers new -1 for hardcoding the size of the array, hoping that it is big enough. new -1 for memory leaks","title":"General Mistakes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#logical-mistakes-bugs","text":"In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully.","title":"Logical Mistakes (bugs)"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#selectionsort","text":"This is an easy question, but unfortunately, less than half the class received full marks. Most of these are due to lack of documentation >.< /** * Sort the input array list using selection sort. * * @param[in] length The size of the array * @param[in,out] list The array to sort */ void selection_sort ( long length , long list [ length ]) { long last = length ; for ( long i = 1 ; i <= length - 1 ; i += 1 ) { long curr_pos = last - 1 ; // Find the position of the max number between list[0]..list[last-1] long max_pos = max ( last , list ); if ( max_pos != curr_pos ) { long temp = list [ max_pos ]; list [ max_pos ] = list [ curr_pos ]; list [ curr_pos ] = temp ; } print ( length , list ); last -= 1 ; } } The only common mistake we see here is that the max function does not handle negative values.","title":"SelectionSort"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#add","text":"The most common mistake is accessing memory locations outside of the bound of the array. This is usually due to careless mistakes (forgetting to allocate an extra space for null character at the end of the string, or forgetting to allocate the extra carry). I have seen lots of code that compute the addition in one long chunk of code, making it hard to read, understand, and debug. Remember to practice decomposition -- breaking down the problem into smaller subproblems, and solve each one by writing a small function. For me, I broke down the tasks of adding two arbitrary large integers to adding two digits (with a possible carry): ** * Perform a single digit addition . The digits are stored in * char form . * * @ pre a and b can only be '0' , '1' , .. '9' * @ param [ in ] a The first operand of addition ( in char ) * @ param [ in ] b The second operand of addition ( in char ) * @ param [ in , out ] has_carry Whether we should add a carry when adding * a + b . If a + b generates a carry , * has_carry * will be set to true , otherwise to false . * * @ return The least significant digit of a + b ( as char ) */ char add_digit ( char a , char b , bool * has_carry ) { long sum = ( a - '0' ) + ( b - '0' ); char result ; if ( * has_carry ) { sum += 1 ; } if ( sum >= 10 ) { result = ( sum % 10 ) + '0' ; * has_carry = true ; } else { result = sum + '0' ; * has_carry = false ; } return result ; } Then, I add digits by digits, starting from least significant digits. Some students reverse the strings and add from the front -- which is unnecessary. long len1 = strlen ( operand1 ); long len2 = strlen ( operand2 ); long max = ( len1 > len2 ) ? len1 : len2 ; char result [ max + 2 ]; result [ max + 1 ] = '\\0' ; // starting from the back, add digit by digit long i = len1 - 1 ; long j = len2 - 1 ; long k = max ; bool has_carry = false ; while ( i >= 0 && j >= 0 ) { result [ k ] = add_digit ( operand1 [ i ], operand2 [ j ], & has_carry ); i -= 1 ; j -= 1 ; k -= 1 ; } Once I exit the while loop, I have either i < 0 || j < 0 . I have exhausted the digits in one of the operands. I figure out which one and continue to add 0 to the remaining operand. // done with the shorter number. Now handle the rest. char * rest ; if ( j >= 0 ) { rest = operand2 ; } else { rest = operand1 ; j = i ; } while ( j >= 0 ) { result [ k ] = add_digit ( rest [ j ], '0' , & has_carry ); k -= 1 ; j -= 1 ; } Finally, I check if there is a carry and print out the content accordingly: if ( has_carry ) { result [ k ] = '1' ; cs1010_println_string ( result ); } else { cs1010_println_string ( & result [ 1 ]); } Some students store each digit in a long or int , which makes it easier to handle the final carry. This approach takes more memory than storing a char but is fine.","title":"Add"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as04-comments.html#mastermind","text":"One way to solve mastermind is to keep a temporary array (I called it marked ) that stores the same content as answer but once we found a match, we \"checked off\" the character so that id does not match again. #define MATCHED ' ' for ( long i = 0 ; i < PUZZLE_SIZE ; i += 1 ) { marked [ i ] = answer [ i ]; } long same_color_same_pos = 0 ; long same_color_diff_pos = 0 ; for ( long i = 0 ; i < PUZZLE_SIZE ; i += 1 ) { if ( guess [ i ] == marked [ i ]) { same_color_same_pos += 1 ; marked [ i ] = MATCHED ; } } for ( long i = 0 ; i < PUZZLE_SIZE ; i += 1 ) { bool found = false ; for ( long j = 0 ; j < PUZZLE_SIZE && ! found ; j += 1 ) { if ( guess [ i ] != answer [ i ] && guess [ i ] == marked [ j ]) { same_color_diff_pos += 1 ; found = true ; marked [ j ] = MATCHED ; } } } The two output numbers are same_color_same_pos and same_color_diff_pos . Despite being asked and clarified on Piazza at least twice, some students still stopped the game after 8 guesses. Please (i) read the question carefully, and (ii) read Piazza.","title":"MasterMind"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html","text":"Assignment 5: Comments Notes on Marking Schemes We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group. Style No style marks are allocated for each question, but if you code is hard to understand, not properly indented, use non-descriptive variable names, etc, we will deduct up to 2 marks. To be safe, please follow strictly the CS1010 coding standards. Documentation Two marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 5. If you did not document your function, parameters, return values, or document wrongly (e.g., confused between @param[out] with @return , you will get a deduction of 1 mark. You get 0 if there is no documentation at all. The following are common formatting errors: @param command used in a comment that is not attached to a function declaration @return command used in a comment that is attached to a function returning void Parameter name not found in the function declaration. You should put the name of the variable only, exclude the type, * , [] . Putting @param with the parameter name, but no description of what the parameter does. Missing [in] , [out] , or [in,out] . Note that there is no space after , in [in,out] . General Mistakes This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers -1 for using variable length array -1 for extra elements in the array initializers -1 for hardcoding the size of the array, hoping that it is big enough. -1 for memory leaks Logical Mistakes (bugs) In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully. Assignment 5: Memory Errors Memory leaks are memory errors are especially serious in Assignment 5. About 70% of you have at least one memory-related bugs. A common error is to allocate a 2D array like this: char ** matrix = calloc ( m , sizeof ( char * )); for ( i = 0 ; i < m ; i += 1 ) { matrix [ i ] = calloc ( n , sizeof ( char )); matrix [ i ] = cs1010_read_word (); } Note that here you are reassigning matrix[i] that originally points to the memory region returned by calloc to the memory returned by cs1010_read_word . The memory returned by calloc is now unreachable and cannot be free. After using matrix , you should free them for ( i = 0 ; i < m ; i += 1 ) { free ( matrix [ i ]); } free ( matrix ); Another common memory error is the failure to consider the terminating null character in the allocation of string. If your string is of size n n , then you need to allocate n+1 n+1 characters for the string. Answer Keys Social This is not meant to be a hard question. There is a similar question (where k k is infinity and the array is not jagged) appeared in the final exam of CS1010 Semester 2 AY17/18. Unexpectedly, many students struggled with it as a programming assignment. There are several issues with most submissions I read. First, many students did not separate out the representation (using a jagged array) from the operation (checking if two person is a friend). This is despite a similar question is asked in Problem 19.2. If you do not write a function similar to dist from Problem 19.2, to check if two person is a friend, then the complexity of your solution increases significantly, as you have to deal with looping through the right column or the right row. Many bugs occur due to students forgetting to consider scanning through a row or a column. It is easier if you write a function that looks like the following: bool is_friend ( char ** network , int i , int j ) { if ( i >= j ) { return network [ i ][ j ] == FRIEND ; } return network [ j ][ i ] == FRIEND ; } Then you no longer have to worry about whether to traverse by row or by column! With the issue of how to access a jagged array out of the way, let's focus on how to find the k k -hop friendships among the people. Some of you tried to employ complicated methods (using recursion and advanced CS2040/C concepts such as breadth-first-search or depth-first-search) to find the k k -hop friendships directly. If you managed to do it, then bravo, you have learned something beyond CS1010 and are one step ahead of your peers! But I actually did not expect students to do this. My approach, as usual, is to break down the problem into smaller ones that we can solve. So let's try to find a 2-hop friendship first. How can we build the social network of 2-hop friendship? If two person i i and j j are not yet connected, we find a third person m m who is a mutual friend between the two of them. If we can find such a third person m m , then i i and j j are a 2-hop friend. We can do something like this: char is_connected ( long n , char ** degree_one , long i , long j ) { for ( int m = 0 ; m < n ; m += 1 ) { if ( is_friend ( degree_one , i , m ) && is_friend ( degree_one , m , j )) { return FRIEND ; } } return STRANGER ; } (I have #defined FRIEND to be '1' and STRANGER to be '0' ) Now we can just loop through every pair i i and j j void compute_degree_2 ( long n , char ** degree_one , char ** degree_two ) { for ( int i = 0 ; i < n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( is_friend ( degree_one , i , j )) { degree_two [ i ][ j ] = FRIEND ; } else { degree_two [ i ][ j ] = is_connected ( n , degree_one , i , j ); } } } } There is an important point in the code above, we need to store the resulting network in a new 2D array (I called it degree_two ) instead of updating the network in place: // not like this degree_one [ i ][ j ] = is_connected ( n , degree_one , i , j ); Some students stored the results back into the original 2D array, and as a result get the wrong output. This is the same for the next question life -- but it is easier to visualize and see the bug in life . And now we have constructed the social network of two hops. How do we construct a network of three hops? Well, a 3-hop relationship means that there must be someone m m , who is a 1-hop friend of i i and 2-hop friend of j j . We can make this more general: a h h -hop relationship means that there must be someone m m who is a 1-hop friend of i i and ( h-1 h-1 )-hop friend of j j . We can thus modify compute_degree_2 to compute_degree_h , making the code more general. /** * Checks if i and j has a common friend * @param[in] n The number of users * @param[in] degree_one The 1-hop friendship information * @param[in] degree_h The h-hop friendship information * @param[in] i A user * @param[in] j Another user * @return FRIEND if i and j has a (h+1)-hop connection, STRANGER otherwise. */ char is_connected ( long n , char ** degree_one , char ** degree_h_minus_1 , long i , long j ) { for ( int m = 0 ; m < n ; m += 1 ) { if ( is_friend ( degree_one , i , m ) && is_friend ( degree_h_minus_1 , m , j )) { return FRIEND ; } } return STRANGER ; } /** * Computers the h-hop friendship for the whole network. * @param[in] n The number of users. * @param[in] degree_one The 1-hop friendship network * @param[in] degree_h_minus_1 The (h-1)-hop friendship network * @param[out] degree_h The h-hop friendship network */ void compute_degree_h ( long n , char ** degree_one , char ** degree_h_minus_1 , char ** degree_h ) { for ( int i = 0 ; i < n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( is_friend ( degree_h_minus_1 , i , j )) { degree_h [ i ][ j ] = FRIEND ; } else { degree_h [ i ][ j ] = is_connected ( n , degree_one , degree_h_minus_1 , i , j ); } } } } Note that we need three 2D arrays now, one storing ( h-1 h-1 )-hop friendship, one storing 1-hop friendship, and one more to store the newly computed h h -hop friendship. Once we finish computed the h h -hop friendship, we do not need the array storing (h-1) (h-1) -hop friendship anymore and we can deallocate it (or better still, reuse it for h+1 h+1 -hop). Finally, we are ready to calculate the k k -hop friendship: for ( int h = 1 ; h < k ; h += 1 ) { compute_degree_h ( n , degree_one , degree_h_minus_1 , degree_h ); swap ( & degree_h_minus_1 , & degree_h ); } The call to swap is how we put the results of h h -hop friendship into the array degree_h_minus_1 , getting ready to be read for the next loop, and get the 2D array degree_h ready to store new results for the next loop. Life Most students do not have any problem solving life . The most common bugs are memory-related, which we have explained above. The gist of the solution to life falls on the three functions below: /** * Count the number of neighbors that is alive. * * @param[in] universe The game of life universe * @param[in] i The row coordinate of the current cell whose * neighbors we are counting. * @param[in] j The column coordinate of the current cell whose * neighbors we are counting. * @return The number of live neighbors. */ int count_live_neighbor ( char ** universe , long i , long j ) { long count = 0 ; for ( long x = - 1 ; x <= 1 ; x += 1 ) { for ( long y = - 1 ; y <= 1 ; y += 1 ) { if ( x != 0 || y != 0 ) { if ( is_alive ( universe [ i + x ][ j + y ])) { count += 1 ; } } } } return count ; } /** * Update the cell (i, j) in the universe. * * @param[in] universe The game of life universe * @param[in] i The row coordinate of the current cell we are updating * @param[in] j The column coordinate of the current cell we are updating * @return The new status of the cell (DEAD or LIVE) */ char update_cell ( char ** universe , long i , long j ) { int live_neighbor_count = count_live_neighbor ( universe , i , j ); if ( is_alive ( universe [ i ][ j ])) { if ( live_neighbor_count < 2 || live_neighbor_count > 3 ) { return DEAD ; } } else { if ( live_neighbor_count == 3 ) { return LIVE ; } } return universe [ i ][ j ]; } /** * Simulate one step of the game of life. * * @param[in] nrows The number of rows * @param[in] ncols The number of columns * @param[in] universe The curr game of life universe * @param[out] new_universe The updated game of life universe */ void simulate_game ( long nrows , long ncols , char ** universe , char ** next_universe ) { for ( long i = 1 ; i < nrows - 1 ; i += 1 ) { for ( long j = 1 ; j < ncols - 1 ; j += 1 ) { next_universe [ i ][ j ] = update_cell ( universe , i , j ); } } }","title":"Assignment 5: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#assignment-5-comments","text":"","title":"Assignment 5: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#notes-on-marking-schemes","text":"We apply the penalty to each program independently, i.e., the same mistake repeated in the different program get penalized multiple times. You will receive 0 marks if your program cannot be compiled or is plagiarised from another. Code that fails all test cases and showing that student does not understand the basic concepts receives 0 marks straight away. For the rest, we start with full marks and start deducting marks for each error. While the teaching team tries to ensure fair and consistent grading of assignments across all groups, each TA can, at his/her own discretion, and with the approval of Wei Tsang, adjust the grading criteria to align with the messages that they sent to the students in their tutorial group.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#style","text":"No style marks are allocated for each question, but if you code is hard to understand, not properly indented, use non-descriptive variable names, etc, we will deduct up to 2 marks. To be safe, please follow strictly the CS1010 coding standards.","title":"Style"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#documentation","text":"Two marks are allocated for each question. We do not penalize for formatting errors violation in Assignment 5. If you did not document your function, parameters, return values, or document wrongly (e.g., confused between @param[out] with @return , you will get a deduction of 1 mark. You get 0 if there is no documentation at all. The following are common formatting errors: @param command used in a comment that is not attached to a function declaration @return command used in a comment that is attached to a function returning void Parameter name not found in the function declaration. You should put the name of the variable only, exclude the type, * , [] . Putting @param with the parameter name, but no description of what the parameter does. Missing [in] , [out] , or [in,out] . Note that there is no space after , in [in,out] .","title":"Documentation"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#general-mistakes","text":"This penalty applies once per program (not per occurrence). -1 for missing type in function declaration or definition -1 for using int / long instead of bool for boolean functions or variables -1 for using double instead of long when it is not necessary (does not involve integer division). For instance, using double for invest.c during calculation is ok, using double for calculating the area of the box is not. -1 for using of int instead of long . Using int for this assignment is ok only for day , hour , and minute , where there is an implicit constraint on the range of the value. -1 for failing to use parenthesis (e.g., a && b || c ) -1 for unnecessary/unused parameters passed into a function -1 for unnecessary/unused variables declared -1 for not including @author/@group -1 for global variables -1 for unreachable code / return -1 for using == to compare real numbers -1 for using variable length array -1 for extra elements in the array initializers -1 for hardcoding the size of the array, hoping that it is big enough. -1 for memory leaks","title":"General Mistakes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#logical-mistakes-bugs","text":"In general, -1 for each bug. -1 for each incorrect logical expression -1 for each incorrect arithmetic expression -1 for each incorrect use of if - else -1 for each uninitialized variables causing incorrect output. -1 if program prints extra text / newline -1 if the program returns non-zero from main even if the program exits successfully.","title":"Logical Mistakes (bugs)"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#assignment-5-memory-errors","text":"Memory leaks are memory errors are especially serious in Assignment 5. About 70% of you have at least one memory-related bugs. A common error is to allocate a 2D array like this: char ** matrix = calloc ( m , sizeof ( char * )); for ( i = 0 ; i < m ; i += 1 ) { matrix [ i ] = calloc ( n , sizeof ( char )); matrix [ i ] = cs1010_read_word (); } Note that here you are reassigning matrix[i] that originally points to the memory region returned by calloc to the memory returned by cs1010_read_word . The memory returned by calloc is now unreachable and cannot be free. After using matrix , you should free them for ( i = 0 ; i < m ; i += 1 ) { free ( matrix [ i ]); } free ( matrix ); Another common memory error is the failure to consider the terminating null character in the allocation of string. If your string is of size n n , then you need to allocate n+1 n+1 characters for the string.","title":"Assignment 5: Memory Errors"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#social","text":"This is not meant to be a hard question. There is a similar question (where k k is infinity and the array is not jagged) appeared in the final exam of CS1010 Semester 2 AY17/18. Unexpectedly, many students struggled with it as a programming assignment. There are several issues with most submissions I read. First, many students did not separate out the representation (using a jagged array) from the operation (checking if two person is a friend). This is despite a similar question is asked in Problem 19.2. If you do not write a function similar to dist from Problem 19.2, to check if two person is a friend, then the complexity of your solution increases significantly, as you have to deal with looping through the right column or the right row. Many bugs occur due to students forgetting to consider scanning through a row or a column. It is easier if you write a function that looks like the following: bool is_friend ( char ** network , int i , int j ) { if ( i >= j ) { return network [ i ][ j ] == FRIEND ; } return network [ j ][ i ] == FRIEND ; } Then you no longer have to worry about whether to traverse by row or by column! With the issue of how to access a jagged array out of the way, let's focus on how to find the k k -hop friendships among the people. Some of you tried to employ complicated methods (using recursion and advanced CS2040/C concepts such as breadth-first-search or depth-first-search) to find the k k -hop friendships directly. If you managed to do it, then bravo, you have learned something beyond CS1010 and are one step ahead of your peers! But I actually did not expect students to do this. My approach, as usual, is to break down the problem into smaller ones that we can solve. So let's try to find a 2-hop friendship first. How can we build the social network of 2-hop friendship? If two person i i and j j are not yet connected, we find a third person m m who is a mutual friend between the two of them. If we can find such a third person m m , then i i and j j are a 2-hop friend. We can do something like this: char is_connected ( long n , char ** degree_one , long i , long j ) { for ( int m = 0 ; m < n ; m += 1 ) { if ( is_friend ( degree_one , i , m ) && is_friend ( degree_one , m , j )) { return FRIEND ; } } return STRANGER ; } (I have #defined FRIEND to be '1' and STRANGER to be '0' ) Now we can just loop through every pair i i and j j void compute_degree_2 ( long n , char ** degree_one , char ** degree_two ) { for ( int i = 0 ; i < n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( is_friend ( degree_one , i , j )) { degree_two [ i ][ j ] = FRIEND ; } else { degree_two [ i ][ j ] = is_connected ( n , degree_one , i , j ); } } } } There is an important point in the code above, we need to store the resulting network in a new 2D array (I called it degree_two ) instead of updating the network in place: // not like this degree_one [ i ][ j ] = is_connected ( n , degree_one , i , j ); Some students stored the results back into the original 2D array, and as a result get the wrong output. This is the same for the next question life -- but it is easier to visualize and see the bug in life . And now we have constructed the social network of two hops. How do we construct a network of three hops? Well, a 3-hop relationship means that there must be someone m m , who is a 1-hop friend of i i and 2-hop friend of j j . We can make this more general: a h h -hop relationship means that there must be someone m m who is a 1-hop friend of i i and ( h-1 h-1 )-hop friend of j j . We can thus modify compute_degree_2 to compute_degree_h , making the code more general. /** * Checks if i and j has a common friend * @param[in] n The number of users * @param[in] degree_one The 1-hop friendship information * @param[in] degree_h The h-hop friendship information * @param[in] i A user * @param[in] j Another user * @return FRIEND if i and j has a (h+1)-hop connection, STRANGER otherwise. */ char is_connected ( long n , char ** degree_one , char ** degree_h_minus_1 , long i , long j ) { for ( int m = 0 ; m < n ; m += 1 ) { if ( is_friend ( degree_one , i , m ) && is_friend ( degree_h_minus_1 , m , j )) { return FRIEND ; } } return STRANGER ; } /** * Computers the h-hop friendship for the whole network. * @param[in] n The number of users. * @param[in] degree_one The 1-hop friendship network * @param[in] degree_h_minus_1 The (h-1)-hop friendship network * @param[out] degree_h The h-hop friendship network */ void compute_degree_h ( long n , char ** degree_one , char ** degree_h_minus_1 , char ** degree_h ) { for ( int i = 0 ; i < n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( is_friend ( degree_h_minus_1 , i , j )) { degree_h [ i ][ j ] = FRIEND ; } else { degree_h [ i ][ j ] = is_connected ( n , degree_one , degree_h_minus_1 , i , j ); } } } } Note that we need three 2D arrays now, one storing ( h-1 h-1 )-hop friendship, one storing 1-hop friendship, and one more to store the newly computed h h -hop friendship. Once we finish computed the h h -hop friendship, we do not need the array storing (h-1) (h-1) -hop friendship anymore and we can deallocate it (or better still, reuse it for h+1 h+1 -hop). Finally, we are ready to calculate the k k -hop friendship: for ( int h = 1 ; h < k ; h += 1 ) { compute_degree_h ( n , degree_one , degree_h_minus_1 , degree_h ); swap ( & degree_h_minus_1 , & degree_h ); } The call to swap is how we put the results of h h -hop friendship into the array degree_h_minus_1 , getting ready to be read for the next loop, and get the 2D array degree_h ready to store new results for the next loop.","title":"Social"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as05-comments.html#life","text":"Most students do not have any problem solving life . The most common bugs are memory-related, which we have explained above. The gist of the solution to life falls on the three functions below: /** * Count the number of neighbors that is alive. * * @param[in] universe The game of life universe * @param[in] i The row coordinate of the current cell whose * neighbors we are counting. * @param[in] j The column coordinate of the current cell whose * neighbors we are counting. * @return The number of live neighbors. */ int count_live_neighbor ( char ** universe , long i , long j ) { long count = 0 ; for ( long x = - 1 ; x <= 1 ; x += 1 ) { for ( long y = - 1 ; y <= 1 ; y += 1 ) { if ( x != 0 || y != 0 ) { if ( is_alive ( universe [ i + x ][ j + y ])) { count += 1 ; } } } } return count ; } /** * Update the cell (i, j) in the universe. * * @param[in] universe The game of life universe * @param[in] i The row coordinate of the current cell we are updating * @param[in] j The column coordinate of the current cell we are updating * @return The new status of the cell (DEAD or LIVE) */ char update_cell ( char ** universe , long i , long j ) { int live_neighbor_count = count_live_neighbor ( universe , i , j ); if ( is_alive ( universe [ i ][ j ])) { if ( live_neighbor_count < 2 || live_neighbor_count > 3 ) { return DEAD ; } } else { if ( live_neighbor_count == 3 ) { return LIVE ; } } return universe [ i ][ j ]; } /** * Simulate one step of the game of life. * * @param[in] nrows The number of rows * @param[in] ncols The number of columns * @param[in] universe The curr game of life universe * @param[out] new_universe The updated game of life universe */ void simulate_game ( long nrows , long ncols , char ** universe , char ** next_universe ) { for ( long i = 1 ; i < nrows - 1 ; i += 1 ) { for ( long j = 1 ; j < ncols - 1 ; j += 1 ) { next_universe [ i ][ j ] = update_cell ( universe , i , j ); } } }","title":"Life"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html","text":"Assignment 6: Comments Notes on Marking Schemes For brevity, I won't repeat the detailed marking scheme, as it is the same as before. One major change is that we start to deduct marks for documentation format errors. The other major change is that we start to award marks based on the efficiency of the solution. Permutation 1 If the code does not produce the correct output, 0 marks for both efficiency and correctness. If the code produces the correct output, give up to 3 marks for correctness. If the solution is in O(n^2), then add 1 marks for efficiency. If it is slower than O(n^2), 0 marks for efficiency. Permutation 2 If the code does not produce the correct output, 0 marks for both efficiency and correctness. If the code produces the correct output, then give up to 3 marks for correctness. If the solution is in O(n), then add 5 marks for efficiency. If it is slower than O(n), 0 marks for efficiency. If the code does unnecessary or repetitive work (e.g., compute strlen repeatedly even if the string does not change). We may deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O. Permutation 3 If the code does not produce the correct output, 0 marks for both efficiency and correctness. If the code produces the correct output, then give up to 5 marks for correctness. Maximum marks for efficiency: 2 for O(nk^2) solution, 4 for O(nk) and 7 for O(n+k). Same as before, if students are doing unnecessary work or repetitive work (e.g., compute strlen repeatedly even if the string does not change). You can deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O (they have been told). Answer Keys Permutation 1 This is an easy question since the limit for this is O(n^2) O(n^2) . There are many different ways to solve this. A solution is to sort the input arrays using either selection sort, bubble sort, or insertion sort then checks if both arrays are equal. If you know of a faster sort (quick sort or merge sort -- CS2040C stuff) then you can actually solve this in O(n \\log n) O(n \\log n) time. Another approach is the following: for every element in L_1 L_1 , look for it in L_2 L_2 , then remove the matched element from the L_2 L_2 . If we can find every element of L_1 L_1 in L_2 L_2 , then they are a permutation of each other. The tricky part here is how to remove the matched element in L_2 L_2 . If you remove the matched element by shifting the elements in L_2 L_2 to \"cover the hole\", you will end up with a O(n^3) O(n^3) algorithm. You might also want to erase the element by setting the element to 0 or -1 (similar to mastermind ). But, since 0 and -1 are both valid inputs, we can't distinguish between an erased element and a valid input in this case. A better way is to move the matched element to the end of the array (similar to selection sort) and don't check it again. Some students take the solution for Permutation 2 and apply it to Permutation 1. This does not work, since for Permutation 2 the range of the elements is small (lowercase alphabets), while for Permutation 1, it's all possible integers! Permutation 2 We can solve Permutation 2 using the same solution as Permutation 1 -- sorting the input arrays and then checking if they are equal. But since the range of the elements is small (only 26 possibilities), we can use counting sort. Actually, we do not even need to sort! We just count how many times each alphabet appears in S_1 S_1 and in S_2 S_2 . If every alphabet appears the same number of times in S_1 S_1 and in S_2 S_2 , then S_2 S_2 is a permutation of S_1 S_1 . /** * Initialize a frequency array counting how many times each letter * appears in a string. * * @param[in] len The length of the string. * @param[in] s The string * @param[out] freq The frequency array. */ void build_frequency_array ( long len , const char s [ len ], long freq [ 26 ]) { for ( long i = 0 ; i < 26 ; i += 1 ) { freq [ i ] = 0 ; } for ( long i = 0 ; i < len ; i += 1 ) { freq [ s [ i ] - 'a' ] += 1 ; } } /** * Compares if two strings are permutation of each other, by * checking their frequency array. * * @param[in] freq1 The frequency array for the first string. * @param[in] freq2 The frequency array for the second string. * * @return true if the two strings contains the same frequency * array, false otherwise. */ bool is_permutation ( const long freq1 [ 26 ], const long freq2 [ 26 ]) { for ( long i = 0 ; i < 26 ; i += 1 ) { if ( freq1 [ i ] != freq2 [ i ]) { return false ; } } return true ; } Permutation 3 This is a more interesting and challenging question. Let's see first how we can solve this naively. A straightforward method is to find all possible substring of length k k from S_2 S_2 , and then use the solution to Permutation 1 to solve it. We have to check $O(n-k) = O(n) O(n) such possible substrings, and each check takes O(k^2) O(k^2) time. If we use the solution of Permutation 2 to check each substring, each check takes O(k) O(k) time only, and so the total running time is O(nk) O(nk) . Doing so would already give you 11 out of 14 marks! To get O(n + k) O(n + k) time, we need a bit of analyzing to avoid redundant work. Let's think about how we find all possible substring of length k k from a string s . We can scan from left to right, checking substring s[0]..s[k-1] , then s[1]..s[k] , then s[2]..s[k+1] . Remember that, from the solution of Permutation 2, \"checking\" means that we count how many times each alphabet appears in the string s[0]..s[k-1] , in the string s[1]..s[k] etc. But do we really need to re-count everything everytime we check a new substring? The principle of avoiding repetitive work applies here -- the two substrings s[0]..s[k-1] and s[1]..s[k] share a common substring s[1]..s[k-1] so we do not really need to count those alphabets again! As such, we can just update incrementally the number of occurances of each alphabet, by decrementing the count for s[0] , and incrementing the count for s[k] . As we move from s[1]..s[k] to s[2]..s[k+1] , we decrement the count for s[1] and increment the count for s[k+1] , etc. This can be done in constant time (irrespective of k k and n n ), or O(1) O(1) time. So now, we can start by setting up an array counting how many times each of the k k characters appear -- this takes O(k) O(k) time. Then scan through O(n) O(n) substring, for each one update the counting array and compare in O(1) O(1) time. /** * Update the frequency table for a new subtring of length k of s2, * starting from position start. * * @pre start >= 1 && start <= n - k. The input string s2 contains * only 'a'-'z'. * @param[in,out] freq The frequency table to update. * @param[in] s2 The string. * @param[in] start The beginning position of the substring. * @param[in] k The length of the substring. */ void update_frequency ( long freq2 [ 26 ], const char * s2 , int start , int k ) { freq2 [ s2 [ start - 1 ] - 'a' ] -= 1 ; freq2 [ s2 [ start + k - 1 ] - 'a' ] += 1 ; } /** * Find if s1 is a permutation of a substring of s2. * * @param[in] s1 The (shorter) string. * @param[in] s2 The string to search for a permutation of s1 in. * * @return true if s1 is a permutation of a substring of s2. */ bool find_permutation ( char * s1 , char * s2 ) { long k = strlen ( s1 ); long n = strlen ( s2 ); long freq1 [ 26 ]; long freq2 [ 26 ]; build_frequency_array ( k , s1 , freq1 ); build_frequency_array ( k , s2 , freq2 ); if ( is_permutation ( freq1 , freq2 )) { return true ; } for ( long start = 1 ; start <= n - k ; start += 1 ) { update_frequency ( freq2 , s2 , start , k ); if ( is_permutation ( freq1 , freq2 )) { return true ; } } return false ; }","title":"Assignment 6: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#assignment-6-comments","text":"","title":"Assignment 6: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#notes-on-marking-schemes","text":"For brevity, I won't repeat the detailed marking scheme, as it is the same as before. One major change is that we start to deduct marks for documentation format errors. The other major change is that we start to award marks based on the efficiency of the solution.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#permutation-1","text":"If the code does not produce the correct output, 0 marks for both efficiency and correctness. If the code produces the correct output, give up to 3 marks for correctness. If the solution is in O(n^2), then add 1 marks for efficiency. If it is slower than O(n^2), 0 marks for efficiency.","title":"Permutation 1"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#permutation-2","text":"If the code does not produce the correct output, 0 marks for both efficiency and correctness. If the code produces the correct output, then give up to 3 marks for correctness. If the solution is in O(n), then add 5 marks for efficiency. If it is slower than O(n), 0 marks for efficiency. If the code does unnecessary or repetitive work (e.g., compute strlen repeatedly even if the string does not change). We may deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O.","title":"Permutation 2"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#permutation-3","text":"If the code does not produce the correct output, 0 marks for both efficiency and correctness. If the code produces the correct output, then give up to 5 marks for correctness. Maximum marks for efficiency: 2 for O(nk^2) solution, 4 for O(nk) and 7 for O(n+k). Same as before, if students are doing unnecessary work or repetitive work (e.g., compute strlen repeatedly even if the string does not change). You can deduct 1 mark per occurrence of such inefficient code even if the code still runs in the same big O (they have been told).","title":"Permutation 3"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#permutation-1_1","text":"This is an easy question since the limit for this is O(n^2) O(n^2) . There are many different ways to solve this. A solution is to sort the input arrays using either selection sort, bubble sort, or insertion sort then checks if both arrays are equal. If you know of a faster sort (quick sort or merge sort -- CS2040C stuff) then you can actually solve this in O(n \\log n) O(n \\log n) time. Another approach is the following: for every element in L_1 L_1 , look for it in L_2 L_2 , then remove the matched element from the L_2 L_2 . If we can find every element of L_1 L_1 in L_2 L_2 , then they are a permutation of each other. The tricky part here is how to remove the matched element in L_2 L_2 . If you remove the matched element by shifting the elements in L_2 L_2 to \"cover the hole\", you will end up with a O(n^3) O(n^3) algorithm. You might also want to erase the element by setting the element to 0 or -1 (similar to mastermind ). But, since 0 and -1 are both valid inputs, we can't distinguish between an erased element and a valid input in this case. A better way is to move the matched element to the end of the array (similar to selection sort) and don't check it again. Some students take the solution for Permutation 2 and apply it to Permutation 1. This does not work, since for Permutation 2 the range of the elements is small (lowercase alphabets), while for Permutation 1, it's all possible integers!","title":"Permutation 1"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#permutation-2_1","text":"We can solve Permutation 2 using the same solution as Permutation 1 -- sorting the input arrays and then checking if they are equal. But since the range of the elements is small (only 26 possibilities), we can use counting sort. Actually, we do not even need to sort! We just count how many times each alphabet appears in S_1 S_1 and in S_2 S_2 . If every alphabet appears the same number of times in S_1 S_1 and in S_2 S_2 , then S_2 S_2 is a permutation of S_1 S_1 . /** * Initialize a frequency array counting how many times each letter * appears in a string. * * @param[in] len The length of the string. * @param[in] s The string * @param[out] freq The frequency array. */ void build_frequency_array ( long len , const char s [ len ], long freq [ 26 ]) { for ( long i = 0 ; i < 26 ; i += 1 ) { freq [ i ] = 0 ; } for ( long i = 0 ; i < len ; i += 1 ) { freq [ s [ i ] - 'a' ] += 1 ; } } /** * Compares if two strings are permutation of each other, by * checking their frequency array. * * @param[in] freq1 The frequency array for the first string. * @param[in] freq2 The frequency array for the second string. * * @return true if the two strings contains the same frequency * array, false otherwise. */ bool is_permutation ( const long freq1 [ 26 ], const long freq2 [ 26 ]) { for ( long i = 0 ; i < 26 ; i += 1 ) { if ( freq1 [ i ] != freq2 [ i ]) { return false ; } } return true ; }","title":"Permutation 2"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as06-comments.html#permutation-3_1","text":"This is a more interesting and challenging question. Let's see first how we can solve this naively. A straightforward method is to find all possible substring of length k k from S_2 S_2 , and then use the solution to Permutation 1 to solve it. We have to check $O(n-k) = O(n) O(n) such possible substrings, and each check takes O(k^2) O(k^2) time. If we use the solution of Permutation 2 to check each substring, each check takes O(k) O(k) time only, and so the total running time is O(nk) O(nk) . Doing so would already give you 11 out of 14 marks! To get O(n + k) O(n + k) time, we need a bit of analyzing to avoid redundant work. Let's think about how we find all possible substring of length k k from a string s . We can scan from left to right, checking substring s[0]..s[k-1] , then s[1]..s[k] , then s[2]..s[k+1] . Remember that, from the solution of Permutation 2, \"checking\" means that we count how many times each alphabet appears in the string s[0]..s[k-1] , in the string s[1]..s[k] etc. But do we really need to re-count everything everytime we check a new substring? The principle of avoiding repetitive work applies here -- the two substrings s[0]..s[k-1] and s[1]..s[k] share a common substring s[1]..s[k-1] so we do not really need to count those alphabets again! As such, we can just update incrementally the number of occurances of each alphabet, by decrementing the count for s[0] , and incrementing the count for s[k] . As we move from s[1]..s[k] to s[2]..s[k+1] , we decrement the count for s[1] and increment the count for s[k+1] , etc. This can be done in constant time (irrespective of k k and n n ), or O(1) O(1) time. So now, we can start by setting up an array counting how many times each of the k k characters appear -- this takes O(k) O(k) time. Then scan through O(n) O(n) substring, for each one update the counting array and compare in O(1) O(1) time. /** * Update the frequency table for a new subtring of length k of s2, * starting from position start. * * @pre start >= 1 && start <= n - k. The input string s2 contains * only 'a'-'z'. * @param[in,out] freq The frequency table to update. * @param[in] s2 The string. * @param[in] start The beginning position of the substring. * @param[in] k The length of the substring. */ void update_frequency ( long freq2 [ 26 ], const char * s2 , int start , int k ) { freq2 [ s2 [ start - 1 ] - 'a' ] -= 1 ; freq2 [ s2 [ start + k - 1 ] - 'a' ] += 1 ; } /** * Find if s1 is a permutation of a substring of s2. * * @param[in] s1 The (shorter) string. * @param[in] s2 The string to search for a permutation of s1 in. * * @return true if s1 is a permutation of a substring of s2. */ bool find_permutation ( char * s1 , char * s2 ) { long k = strlen ( s1 ); long n = strlen ( s2 ); long freq1 [ 26 ]; long freq2 [ 26 ]; build_frequency_array ( k , s1 , freq1 ); build_frequency_array ( k , s2 , freq2 ); if ( is_permutation ( freq1 , freq2 )) { return true ; } for ( long start = 1 ; start <= n - k ; start += 1 ) { update_frequency ( freq2 , s2 , start , k ); if ( is_permutation ( freq1 , freq2 )) { return true ; } } return false ; }","title":"Permutation 3"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html","text":"Assignment 7: Comments Notes on Marking Schemes For brevity, I won't repeat the detailed marking scheme, as it is the same as before. One major change is that we start to deduct marks for documentation format errors. The other major change is that we start to award marks based on the efficiency of the solution. Answer Keys Peak For an array with distinct elements, we need to take O(\\log n) O(\\log n) steps. This hints that we need to cut down the possiblity of where the peak is by half at every comparison. We can do something similar to binary search -- to check the middle element, and use it to decide where the peak could be. Here are the six cases: The more tricky case is what happen when the middle point has the same elevation on either side. In which case, we cannot tell where the peak is and we will have to search both sides for the peak. This is the reason why if the elevation is not distinct, then the running time is more than O(\\log n) O(\\log n) (but still less than O(n) O(n) ). ** * Check if there ' s a peak ( an elevation that is higher than * both points on its left and right side ) in the range * a [ start ].. a [ end ]. * * @ param [ in ] a The array of elevations . * @ param [ in ] start The staring index . * @ param [ in ] end The ending index . * @ return Return the index of peak , or NO_PEAK if no peak exists */ #define NO_PEAK (-1) long find_peak ( const long a [], long start , long end ) { // There is no peak if less than 3 elements. if ( end < start + 2 ) { return NO_PEAK ; } long mid = ( start + end ) / 2 ; // mid is higher than the nearby points, and hence it's a peak if ( a [ mid - 1 ] < a [ mid ] && a [ mid + 1 ] < a [ mid ]) { return mid ; } // mid is at the same height as both left and right. We have to // check both sides for peak. Let's do the left side first. if ( a [ mid - 1 ] == a [ mid ] && a [ mid + 1 ] == a [ mid ]) { long position = find_peak ( a , start , mid ); if ( position != NO_PEAK ) { return position ; } // There is no peak on the left side. Check the right side. return find_peak ( a , mid , end ); } // Check for peak on the right side. if ( a [ mid - 1 ] <= a [ mid ] && a [ mid + 1 ] >= a [ mid ]) { return find_peak ( a , mid , end ); } // Check for peak on the left side. // { (a[mid - 1] >= a[mid] && a[mid + 1] <= a[mid]) } return find_peak ( a , start , mid ); } Scripts The hint for this one is actually pretty obvious. So there is nothing to say :) Here is the code: /** * Given an array in[] of integers containing an increasing sequence * followed by a decresing sequence, rearrange the array so that * it becomes sorted. * @param[in] len The length of the array in[]. * @param[in] in The input array to be sorted. * @param[out] out The output array. * @pre The array in contains a (possibly empty) increasing sequence * followed by a decreasing sequence. * @post The array out is sorted. */ void sort ( long len , const long in [ len ], long * out ) { long left = 0 ; long right = len - 1 ; long out_pos = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { out [ out_pos ] = in [ left ]; left += 1 ; } else { out [ out_pos ] = in [ right ]; right -= 1 ; } out_pos += 1 ; } } I can, however, add a few more words on this. This algorithm, which merges two sorted array into one, is better known as, well, the merge algorithm, and it is a basic step in a fast sorting algorithm called merge sort, which runs in O(n \\log n) O(n \\log n) . The basic idea of merge sort is to split an input array into two halves, recursively sort each half. Now you have a situation similar to John's, which you can merge into a sorted array in O(n) O(n) time. It's pretty cool. You can check out the animation from Visualgo Inversion For 20 marks, you just need one line of code -- if you know what you are doing. Let me show you the solution first -- which is a modified version of the sort function from scripts : long count_inversions ( long len , long in [ len ]) { long left = 0 ; long right = len - 1 ; long sum = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { left += 1 ; } else { sum += right - left ; // <- 20 marks right -= 1 ; } } return sum ; } Let's analyze the problem and see how to come up with this solution. When we count inversions, we need to be careful about counting every pair once. This is something you should have learned from kendall . So we have to decide, for an element, whether we want to count inversions to the left or to the right of the element (but not both). In our solution, we decided to count the inversions for elements to the left -- in other words, for an element in[i] , we count the number of elements from in[0]..in[i-1] that are bigger than in[i] . An O(n^2) O(n^2) solution scans from in[0] to in[i-1] , for each i . This is a double-loop solution that will given you 0 marks. To get a faster solution, let's look at an example input below: The blue elements are already sorted, so each element in[i] here does not contribute to the count on the number of inversions. The purple elements, however, are inversely sorted so they contributes to the number of inversions. Every purple elements on the left of in[i] is one inversion. But that is not all, some of the blue elements are larger than in[i] , so we have to count those inversions as well. The figure below shows that in[6] contributes 4 to the number of inversions since there are 4 elements to its left that is larger. Now, the question is how to find how many blue elements are larger than in[i] . The hints give some ideas. The first hint is to use binary search. Since the blue elements are sorted, we can use binary search to find the position in which we should insert in[i] . (There is a in-class tutorial programming exercise on this). That takes O(\\log n) O(\\log n) time for each element. So the running time for this approach is O(n \\log n) O(n \\log n) . The second hint is to use sort, which we just solved in the problem scripts . Here is the sorting algorithm, again: void sort ( long len , const long in [ len ], long * out ) { long left = 0 ; long right = len - 1 ; long out_pos = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { out [ out_pos ] = in [ left ]; left += 1 ; } else { out [ out_pos ] = in [ right ]; right -= 1 ; } out_pos += 1 ; } } Why does this algorithm work? This algorithm actually maintains the following invariant Every element in in[0]..in[left-1] < min(in[left], in[right]) Every element in in[right+1]..in[len-1] < min(in[left], in[right]) Every element in in[left+1]..in[right-1] > min(in[left], in[right]) which is why putting the minimum of in[left] and in[right] to the output array ensures that it is in sorted order. The figures below illustrate this invariant -- elements in in[0]..in[left-1] and in[right+1]..in[len-1] are in gray. Since we only move left or right on the smaller of the in[left] or in[right] , the invariant is maintained in every loop. Let's consider the case where in[right] < in[left] . We can simplify the invariants to: Every element in in[0]..in[left-1] < in[right] Every element in in[right+1]..in[len-1] < in[right] Every element in in[left]..in[right-1] > in[right] The last invariant is the key to count the inversions -- we can conclude that in[right] contributes ( right - 1) - left + 1 inversions to the total count. Hence the line: long count_inversions ( long len , long in [ len ]) { long left = 0 ; long right = len - 1 ; long sum = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { left += 1 ; } else { sum += right - left ; // <- 20 marks right -= 1 ; } } return sum ; } I think this question illustrates strongly my point at the very first lecture: writing code is easy, but knowing what to write is not!","title":"Assignment 7: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html#assignment-7-comments","text":"","title":"Assignment 7: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html#notes-on-marking-schemes","text":"For brevity, I won't repeat the detailed marking scheme, as it is the same as before. One major change is that we start to deduct marks for documentation format errors. The other major change is that we start to award marks based on the efficiency of the solution.","title":"Notes on Marking Schemes"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html#peak","text":"For an array with distinct elements, we need to take O(\\log n) O(\\log n) steps. This hints that we need to cut down the possiblity of where the peak is by half at every comparison. We can do something similar to binary search -- to check the middle element, and use it to decide where the peak could be. Here are the six cases: The more tricky case is what happen when the middle point has the same elevation on either side. In which case, we cannot tell where the peak is and we will have to search both sides for the peak. This is the reason why if the elevation is not distinct, then the running time is more than O(\\log n) O(\\log n) (but still less than O(n) O(n) ). ** * Check if there ' s a peak ( an elevation that is higher than * both points on its left and right side ) in the range * a [ start ].. a [ end ]. * * @ param [ in ] a The array of elevations . * @ param [ in ] start The staring index . * @ param [ in ] end The ending index . * @ return Return the index of peak , or NO_PEAK if no peak exists */ #define NO_PEAK (-1) long find_peak ( const long a [], long start , long end ) { // There is no peak if less than 3 elements. if ( end < start + 2 ) { return NO_PEAK ; } long mid = ( start + end ) / 2 ; // mid is higher than the nearby points, and hence it's a peak if ( a [ mid - 1 ] < a [ mid ] && a [ mid + 1 ] < a [ mid ]) { return mid ; } // mid is at the same height as both left and right. We have to // check both sides for peak. Let's do the left side first. if ( a [ mid - 1 ] == a [ mid ] && a [ mid + 1 ] == a [ mid ]) { long position = find_peak ( a , start , mid ); if ( position != NO_PEAK ) { return position ; } // There is no peak on the left side. Check the right side. return find_peak ( a , mid , end ); } // Check for peak on the right side. if ( a [ mid - 1 ] <= a [ mid ] && a [ mid + 1 ] >= a [ mid ]) { return find_peak ( a , mid , end ); } // Check for peak on the left side. // { (a[mid - 1] >= a[mid] && a[mid + 1] <= a[mid]) } return find_peak ( a , start , mid ); }","title":"Peak"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html#scripts","text":"The hint for this one is actually pretty obvious. So there is nothing to say :) Here is the code: /** * Given an array in[] of integers containing an increasing sequence * followed by a decresing sequence, rearrange the array so that * it becomes sorted. * @param[in] len The length of the array in[]. * @param[in] in The input array to be sorted. * @param[out] out The output array. * @pre The array in contains a (possibly empty) increasing sequence * followed by a decreasing sequence. * @post The array out is sorted. */ void sort ( long len , const long in [ len ], long * out ) { long left = 0 ; long right = len - 1 ; long out_pos = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { out [ out_pos ] = in [ left ]; left += 1 ; } else { out [ out_pos ] = in [ right ]; right -= 1 ; } out_pos += 1 ; } } I can, however, add a few more words on this. This algorithm, which merges two sorted array into one, is better known as, well, the merge algorithm, and it is a basic step in a fast sorting algorithm called merge sort, which runs in O(n \\log n) O(n \\log n) . The basic idea of merge sort is to split an input array into two halves, recursively sort each half. Now you have a situation similar to John's, which you can merge into a sorted array in O(n) O(n) time. It's pretty cool. You can check out the animation from Visualgo","title":"Scripts"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as07-comments.html#inversion","text":"For 20 marks, you just need one line of code -- if you know what you are doing. Let me show you the solution first -- which is a modified version of the sort function from scripts : long count_inversions ( long len , long in [ len ]) { long left = 0 ; long right = len - 1 ; long sum = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { left += 1 ; } else { sum += right - left ; // <- 20 marks right -= 1 ; } } return sum ; } Let's analyze the problem and see how to come up with this solution. When we count inversions, we need to be careful about counting every pair once. This is something you should have learned from kendall . So we have to decide, for an element, whether we want to count inversions to the left or to the right of the element (but not both). In our solution, we decided to count the inversions for elements to the left -- in other words, for an element in[i] , we count the number of elements from in[0]..in[i-1] that are bigger than in[i] . An O(n^2) O(n^2) solution scans from in[0] to in[i-1] , for each i . This is a double-loop solution that will given you 0 marks. To get a faster solution, let's look at an example input below: The blue elements are already sorted, so each element in[i] here does not contribute to the count on the number of inversions. The purple elements, however, are inversely sorted so they contributes to the number of inversions. Every purple elements on the left of in[i] is one inversion. But that is not all, some of the blue elements are larger than in[i] , so we have to count those inversions as well. The figure below shows that in[6] contributes 4 to the number of inversions since there are 4 elements to its left that is larger. Now, the question is how to find how many blue elements are larger than in[i] . The hints give some ideas. The first hint is to use binary search. Since the blue elements are sorted, we can use binary search to find the position in which we should insert in[i] . (There is a in-class tutorial programming exercise on this). That takes O(\\log n) O(\\log n) time for each element. So the running time for this approach is O(n \\log n) O(n \\log n) . The second hint is to use sort, which we just solved in the problem scripts . Here is the sorting algorithm, again: void sort ( long len , const long in [ len ], long * out ) { long left = 0 ; long right = len - 1 ; long out_pos = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { out [ out_pos ] = in [ left ]; left += 1 ; } else { out [ out_pos ] = in [ right ]; right -= 1 ; } out_pos += 1 ; } } Why does this algorithm work? This algorithm actually maintains the following invariant Every element in in[0]..in[left-1] < min(in[left], in[right]) Every element in in[right+1]..in[len-1] < min(in[left], in[right]) Every element in in[left+1]..in[right-1] > min(in[left], in[right]) which is why putting the minimum of in[left] and in[right] to the output array ensures that it is in sorted order. The figures below illustrate this invariant -- elements in in[0]..in[left-1] and in[right+1]..in[len-1] are in gray. Since we only move left or right on the smaller of the in[left] or in[right] , the invariant is maintained in every loop. Let's consider the case where in[right] < in[left] . We can simplify the invariants to: Every element in in[0]..in[left-1] < in[right] Every element in in[right+1]..in[len-1] < in[right] Every element in in[left]..in[right-1] > in[right] The last invariant is the key to count the inversions -- we can conclude that in[right] contributes ( right - 1) - left + 1 inversions to the total count. Hence the line: long count_inversions ( long len , long in [ len ]) { long left = 0 ; long right = len - 1 ; long sum = 0 ; while ( left <= right ) { if ( in [ left ] < in [ right ]) { left += 1 ; } else { sum += right - left ; // <- 20 marks right -= 1 ; } } return sum ; } I think this question illustrates strongly my point at the very first lecture: writing code is easy, but knowing what to write is not!","title":"Inversion"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as08-comments.html","text":"Assignment 8: Comments Answer Keys Maze The general idea to solve this problem involves recursively attempting to move up, right, down, left. Unlike the past recursive problems, however, here we need to keep track of whether Scully has visited a cell before so that she does not repeatedly visit the same cell over and over again. Like any recursive problem, we need to first consider the base (most trivial) case. For this problem, the simplest case is when Scully is already at the border so she has already escaped. If Scully is still in the maze, then she should try to escape by moving up. If she escaped, then we are done! Otherwise, she should move one step back to where she was previously, and try to escape by moving right, and so on. The following pseudocode (English-like, informal, code) explains this: can_escape() { if already at the border return true for each direction up, right, down, left: move in that direction if possible if can_escape() return true else move back return false (since cannot escape in all four directions) Moving back is important since this is where Scully back tracks to try another path. Translating the idea above into C, we have the following: /** * Try to move one step in the maze in the given direction. * * @param[in,out] maze The 2D array representing the maze. * @param[in] x The current x position. * @param[in] y The current y position. * @param[in] dx The x direction to move (-1, 0, 1). * @param[in] dy The y direction to move (-1, 0, 1). * @param[in,out] steps The number of steps taken so far. * * @return true if we successfully moved. false otherwise. */ bool move_one_step ( char ** maze , long x , long y , long dx , long dy , long * steps ) { if ( maze [ x + dx ][ y + dy ] != EMPTY ) { return false ; } maze [ x ][ y ] = EMPTY ; maze [ x + dx ][ y + dy ] = USER ; * steps += 1 ; return true ; } /** * Try to escape the maze from the position x, y. * * @param[in] maze The 2D array representing the maze. * @param[in,out] visited The 2D array to remember whether a cell has been * visited before. * @param[in] m The number of rows in the maze. * @param[in] n The number of cols in the maze. * @param[in] x The x position of Scully. * @param[in] y The y position of Scully. * @param[in,out] steps The num of steps that has been taken. */ #define NUM_OF_DIRS 4 #define X 0 #define Y 1 bool can_escape ( char ** maze , bool ** visited , long m , long n , long x , long y , long * steps ){ visited [ x ][ y ] = true ; // If already at the border, then escape. if ( x == 0 || x == m - 1 || y == 0 || y == n - 1 ) { return true ; } for ( long dir = 0 ; dir < NUM_OF_DIRS ; dir += 1 ) { // For each direction. char delta [ NUM_OF_DIRS ][ 2 ] = { { - 1 , 0 }, { 0 , 1 }, { 1 , 0 }, { 0 , - 1 } }; char dx = delta [ dir ][ X ]; char dy = delta [ dir ][ Y ]; if ( ! visited [ x + dx ][ y + dy ]) { bool can_move = move_one_step ( maze , x , y , dx , dy , steps ); if ( can_move ) { print_maze ( maze , m , * steps ); if ( can_escape ( maze , visited , m , n , x + dx , y + dy , steps )) { return true ; } move_one_step ( maze , x + dx , y + dy , - dx , - dy , steps ); print_maze ( maze , m , * steps ); } } } return false ; } Fill The idea of fill is similar to maze , except that now, we fill the different neighboring pixels with color, and we do not back track. This question meant to contrast between the execution of a recursive function with and without backtracking. /** * Fill a 2D canvas of size m x n, starting from position (x, y), replacing * current color `curr`, with color `new`. * * @param[in,out] canvas The 2D canvas to flood fill with new color. * @param[in] m The width of the canvas. * @param[in] n The height of the canvas. * @param[in] x The starting x position to fill. * @param[in] y The starting y position to fill. * @param[in] curr The color to be replaced. * @param[in] new The new color. */ void fill ( char ** canvas , long m , long n , long x , long y , char curr , char new ) { long delta [ NUM_OR_DIRS ][ 2 ] = { { 0 , 1 }, { 0 , - 1 }, { 1 , 0 }, { - 1 , 0 }}; for ( long dir = 0 ; dir < NUM_OR_DIRS ; dir += 1 ) { long new_x = x + delta [ dir ][ X ]; long new_y = y + delta [ dir ][ Y ]; if ( new_x >= 0 && new_x < m && new_y >= 0 && new_y < n && canvas [ new_x ][ new_y ] == curr ) { canvas [ new_x ][ new_y ] = new ; fill ( canvas , m , n , new_x , new_y , curr , new ); } } }","title":"Assignment 8: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as08-comments.html#assignment-8-comments","text":"","title":"Assignment 8: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as08-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as08-comments.html#maze","text":"The general idea to solve this problem involves recursively attempting to move up, right, down, left. Unlike the past recursive problems, however, here we need to keep track of whether Scully has visited a cell before so that she does not repeatedly visit the same cell over and over again. Like any recursive problem, we need to first consider the base (most trivial) case. For this problem, the simplest case is when Scully is already at the border so she has already escaped. If Scully is still in the maze, then she should try to escape by moving up. If she escaped, then we are done! Otherwise, she should move one step back to where she was previously, and try to escape by moving right, and so on. The following pseudocode (English-like, informal, code) explains this: can_escape() { if already at the border return true for each direction up, right, down, left: move in that direction if possible if can_escape() return true else move back return false (since cannot escape in all four directions) Moving back is important since this is where Scully back tracks to try another path. Translating the idea above into C, we have the following: /** * Try to move one step in the maze in the given direction. * * @param[in,out] maze The 2D array representing the maze. * @param[in] x The current x position. * @param[in] y The current y position. * @param[in] dx The x direction to move (-1, 0, 1). * @param[in] dy The y direction to move (-1, 0, 1). * @param[in,out] steps The number of steps taken so far. * * @return true if we successfully moved. false otherwise. */ bool move_one_step ( char ** maze , long x , long y , long dx , long dy , long * steps ) { if ( maze [ x + dx ][ y + dy ] != EMPTY ) { return false ; } maze [ x ][ y ] = EMPTY ; maze [ x + dx ][ y + dy ] = USER ; * steps += 1 ; return true ; } /** * Try to escape the maze from the position x, y. * * @param[in] maze The 2D array representing the maze. * @param[in,out] visited The 2D array to remember whether a cell has been * visited before. * @param[in] m The number of rows in the maze. * @param[in] n The number of cols in the maze. * @param[in] x The x position of Scully. * @param[in] y The y position of Scully. * @param[in,out] steps The num of steps that has been taken. */ #define NUM_OF_DIRS 4 #define X 0 #define Y 1 bool can_escape ( char ** maze , bool ** visited , long m , long n , long x , long y , long * steps ){ visited [ x ][ y ] = true ; // If already at the border, then escape. if ( x == 0 || x == m - 1 || y == 0 || y == n - 1 ) { return true ; } for ( long dir = 0 ; dir < NUM_OF_DIRS ; dir += 1 ) { // For each direction. char delta [ NUM_OF_DIRS ][ 2 ] = { { - 1 , 0 }, { 0 , 1 }, { 1 , 0 }, { 0 , - 1 } }; char dx = delta [ dir ][ X ]; char dy = delta [ dir ][ Y ]; if ( ! visited [ x + dx ][ y + dy ]) { bool can_move = move_one_step ( maze , x , y , dx , dy , steps ); if ( can_move ) { print_maze ( maze , m , * steps ); if ( can_escape ( maze , visited , m , n , x + dx , y + dy , steps )) { return true ; } move_one_step ( maze , x + dx , y + dy , - dx , - dy , steps ); print_maze ( maze , m , * steps ); } } } return false ; }","title":"Maze"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as08-comments.html#fill","text":"The idea of fill is similar to maze , except that now, we fill the different neighboring pixels with color, and we do not back track. This question meant to contrast between the execution of a recursive function with and without backtracking. /** * Fill a 2D canvas of size m x n, starting from position (x, y), replacing * current color `curr`, with color `new`. * * @param[in,out] canvas The 2D canvas to flood fill with new color. * @param[in] m The width of the canvas. * @param[in] n The height of the canvas. * @param[in] x The starting x position to fill. * @param[in] y The starting y position to fill. * @param[in] curr The color to be replaced. * @param[in] new The new color. */ void fill ( char ** canvas , long m , long n , long x , long y , char curr , char new ) { long delta [ NUM_OR_DIRS ][ 2 ] = { { 0 , 1 }, { 0 , - 1 }, { 1 , 0 }, { - 1 , 0 }}; for ( long dir = 0 ; dir < NUM_OR_DIRS ; dir += 1 ) { long new_x = x + delta [ dir ][ X ]; long new_y = y + delta [ dir ][ Y ]; if ( new_x >= 0 && new_x < m && new_y >= 0 && new_y < n && canvas [ new_x ][ new_y ] == curr ) { canvas [ new_x ][ new_y ] = new ; fill ( canvas , m , n , new_x , new_y , curr , new ); } } }","title":"Fill"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html","text":"Assignment 9: Comments Answer Keys Digits This assignment involves many concepts that you have learnt over the semester. Constants There are a few constants involved in this assignment. So let's define that first. #define NCOLS 28 #define NROWS 28 #define WHITE '.' #define BLACK '#' #define K 5 Representing A Digit We should put all the information that are logically related to a digit together in a structure. Let's start with the most straightforward one: typedef struct { char * input [ NROWS ]; long label ; } digit ; We will change it later. Here is an example of how we use this struct : void digit_read ( digit * sample ) { sample -> label = cs1010_read_long (); for ( long i = 0 ; i < NROWS ; i += 1 ) { sample -> input [ i ] = cs1010_read_word (); } } The above read a sample digit (either training of testing) from the standard input. The following is how to find the distance between two digits: long find_distance ( digit a , digit b ) { long d = 0 ; for ( long i = 0 ; i < NROWS ; i += 1 ) { for ( long j = 0 ; j < NCOLS ; j += 1 ) { if (( a . input [ i ][ j ] == BLACK && b . input [ i ][ j ] == WHITE ) || ( a . input [ i ][ j ] == WHITE && b . input [ i ][ j ] == BLACK )) { d += 1 ; } } } return d ; } Finding K Nearest Neighbors After we find the distance from the testing sample (the digit we want to recognize) and one of the training samples, we need to check if it is among the k k nearest neighbors. This subproblem can be formulated as the following: given an input of n n numbers, find the k k smallest. This is a generalization of the midterm problem (find the second largest number from a list). One possible solution is to sort the n n numbers and get the first k k . This takes O(n^2) O(n^2) time using the sorting algorithms that you have learned or O(n \\log n) O(n \\log n) if you use quick sort or merge sort (from CS2040C). We can't use counting sort even though the maximum among the numbers to be sorted is only 28^2 28^2 , because it is not enough to sort the distances, we need to keep track of the training samples (the digit variables) associated with the distances as well. To solve this in O(kn) O(kn) time, one way is to keep the closest k k neighbors so far in a sorted array of size k k , and perform insertion into this array, similar to the procedure of insertion sort. We would need to keep the corresponding distance values as well. Let's create a new struct to store the neigbours: typedef struct { digit sample ; long distance ; } neighbor ; and declare an array of K neighbors with the distance initialized to infinity: neighbor nearest [ K ]; for ( long i = 0 ; i < K ; i += 1 ) { nearest [ i ]. distance = LONG_MAX ; } Now, given a test sample test , a list of training samples trains , we can do the following: for ( long i = 0 ; i < num_of_samples ; i += 1 ) { long d = find_distance ( test , trains [ i ]); insert ( trains [ i ], d , nearest ); } Where the function insert is: void insert ( digit sample , long distance , neighbor nearest []) { if ( distance > nearest [ K - 1 ]. distance ) { return ; } if ( distance == nearest [ K - 1 ]. distance && sample . label > nearest [ K - 1 ]. sample . label ) { return ; } long i = K - 1 ; do { nearest [ i ] = nearest [ i - 1 ]; i -= 1 ; } while ( i >= 0 && ( nearest [ i ]. distance > distance || ( nearest [ i ]. distance == distance && nearest [ i ]. sample . label > sample . label ))); // { nearest[i].distance <= sample.distance } nearest [ i + 1 ]. sample = sample ; nearest [ i + 1 ]. distance = distance ; } The insert function takes O(k) O(k) times. After we identify the k k nearest neighbors for a test sample, the final step is to find the most common label that appears in these k k neighbors. We can use something similar to counting sort to count the number of occurances of each digit, and return the most frequent one. This takes O(k) O(k) times. long most_common_digit ( const neighbor nearest [ K ]) { long freq [ 10 ] = { 0 }; for ( long i = 0 ; i < K ; i += 1 ) { freq [ nearest [ i ]. sample . label ] += 1 ; } long max_so_far = freq [ 0 ]; long max_digit = 0 ; for ( long i = 1 ; i < 10 ; i += 1 ) { if ( freq [ i ] > max_so_far ) { max_so_far = freq [ i ]; max_digit = i ; } } return max_digit ; } Avoiding Redundant Work We can further improve the code by pruning unnecessary computation. Observe that, any training sample with distance larger than nearest[k-1] will have no chance of \"making it\" into the k k nearest neighbors. We can thus prune these computations and speed up find_distance . The modified find_distance method below has a new limit parameter. Once d exceeds that, the function returns d . It won't be returning the true distance between the digits a and b , but it will not matter anyway. long find_distance ( digit a , digit b , long limit ) { long d = 0 ; for ( long i = 0 ; i < NROWS ; i += 1 ) { for ( long j = 0 ; j < NCOLS ; j += 1 ) { if (( a . input [ i ][ j ] == BLACK && b . input [ i ][ j ] == WHITE ) || ( a . input [ i ][ j ] == WHITE && b . input [ i ][ j ] == BLACK )) { d += 1 ; if ( d > limit ) { return d ; } } } } return d ; } The new find_distance is called as follows: for ( long i = 0 ; i < num_of_samples ; i += 1 ) { long d = find_distance ( test , trains [ i ], nearest [ k - 1 ]. distance ); insert ( trains [ i ], d , nearest ); } This simple act of pruning reduces the actual running time by 60% for my case (your milage may vary).","title":"Assignment 9: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#assignment-9-comments","text":"","title":"Assignment 9: Comments"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#answer-keys","text":"","title":"Answer Keys"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#digits","text":"This assignment involves many concepts that you have learnt over the semester.","title":"Digits"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#constants","text":"There are a few constants involved in this assignment. So let's define that first. #define NCOLS 28 #define NROWS 28 #define WHITE '.' #define BLACK '#' #define K 5","title":"Constants"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#representing-a-digit","text":"We should put all the information that are logically related to a digit together in a structure. Let's start with the most straightforward one: typedef struct { char * input [ NROWS ]; long label ; } digit ; We will change it later. Here is an example of how we use this struct : void digit_read ( digit * sample ) { sample -> label = cs1010_read_long (); for ( long i = 0 ; i < NROWS ; i += 1 ) { sample -> input [ i ] = cs1010_read_word (); } } The above read a sample digit (either training of testing) from the standard input. The following is how to find the distance between two digits: long find_distance ( digit a , digit b ) { long d = 0 ; for ( long i = 0 ; i < NROWS ; i += 1 ) { for ( long j = 0 ; j < NCOLS ; j += 1 ) { if (( a . input [ i ][ j ] == BLACK && b . input [ i ][ j ] == WHITE ) || ( a . input [ i ][ j ] == WHITE && b . input [ i ][ j ] == BLACK )) { d += 1 ; } } } return d ; }","title":"Representing A Digit"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#finding-k-nearest-neighbors","text":"After we find the distance from the testing sample (the digit we want to recognize) and one of the training samples, we need to check if it is among the k k nearest neighbors. This subproblem can be formulated as the following: given an input of n n numbers, find the k k smallest. This is a generalization of the midterm problem (find the second largest number from a list). One possible solution is to sort the n n numbers and get the first k k . This takes O(n^2) O(n^2) time using the sorting algorithms that you have learned or O(n \\log n) O(n \\log n) if you use quick sort or merge sort (from CS2040C). We can't use counting sort even though the maximum among the numbers to be sorted is only 28^2 28^2 , because it is not enough to sort the distances, we need to keep track of the training samples (the digit variables) associated with the distances as well. To solve this in O(kn) O(kn) time, one way is to keep the closest k k neighbors so far in a sorted array of size k k , and perform insertion into this array, similar to the procedure of insertion sort. We would need to keep the corresponding distance values as well. Let's create a new struct to store the neigbours: typedef struct { digit sample ; long distance ; } neighbor ; and declare an array of K neighbors with the distance initialized to infinity: neighbor nearest [ K ]; for ( long i = 0 ; i < K ; i += 1 ) { nearest [ i ]. distance = LONG_MAX ; } Now, given a test sample test , a list of training samples trains , we can do the following: for ( long i = 0 ; i < num_of_samples ; i += 1 ) { long d = find_distance ( test , trains [ i ]); insert ( trains [ i ], d , nearest ); } Where the function insert is: void insert ( digit sample , long distance , neighbor nearest []) { if ( distance > nearest [ K - 1 ]. distance ) { return ; } if ( distance == nearest [ K - 1 ]. distance && sample . label > nearest [ K - 1 ]. sample . label ) { return ; } long i = K - 1 ; do { nearest [ i ] = nearest [ i - 1 ]; i -= 1 ; } while ( i >= 0 && ( nearest [ i ]. distance > distance || ( nearest [ i ]. distance == distance && nearest [ i ]. sample . label > sample . label ))); // { nearest[i].distance <= sample.distance } nearest [ i + 1 ]. sample = sample ; nearest [ i + 1 ]. distance = distance ; } The insert function takes O(k) O(k) times. After we identify the k k nearest neighbors for a test sample, the final step is to find the most common label that appears in these k k neighbors. We can use something similar to counting sort to count the number of occurances of each digit, and return the most frequent one. This takes O(k) O(k) times. long most_common_digit ( const neighbor nearest [ K ]) { long freq [ 10 ] = { 0 }; for ( long i = 0 ; i < K ; i += 1 ) { freq [ nearest [ i ]. sample . label ] += 1 ; } long max_so_far = freq [ 0 ]; long max_digit = 0 ; for ( long i = 1 ; i < 10 ; i += 1 ) { if ( freq [ i ] > max_so_far ) { max_so_far = freq [ i ]; max_digit = i ; } } return max_digit ; }","title":"Finding K Nearest Neighbors"},{"location":"55ccd425a600ce233a85335d5c15eaaf/as09-comments.html#avoiding-redundant-work","text":"We can further improve the code by pruning unnecessary computation. Observe that, any training sample with distance larger than nearest[k-1] will have no chance of \"making it\" into the k k nearest neighbors. We can thus prune these computations and speed up find_distance . The modified find_distance method below has a new limit parameter. Once d exceeds that, the function returns d . It won't be returning the true distance between the digits a and b , but it will not matter anyway. long find_distance ( digit a , digit b , long limit ) { long d = 0 ; for ( long i = 0 ; i < NROWS ; i += 1 ) { for ( long j = 0 ; j < NCOLS ; j += 1 ) { if (( a . input [ i ][ j ] == BLACK && b . input [ i ][ j ] == WHITE ) || ( a . input [ i ][ j ] == WHITE && b . input [ i ][ j ] == BLACK )) { d += 1 ; if ( d > limit ) { return d ; } } } } return d ; } The new find_distance is called as follows: for ( long i = 0 ; i < num_of_samples ; i += 1 ) { long d = find_distance ( test , trains [ i ], nearest [ k - 1 ]. distance ); insert ( trains [ i ], d , nearest ); } This simple act of pruning reduces the actual running time by 60% for my case (your milage may vary).","title":"Avoiding Redundant Work"}]}